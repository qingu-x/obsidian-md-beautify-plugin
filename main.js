"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/build/index.cjs.js
var require_index_cjs = __commonJS({
  "../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/build/index.cjs.js"(exports) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      let cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (let i = 0; i < 128; i++) {
        const ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (let i = 0; i < exclude.length; i++) {
        const ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      const cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        let result = "";
        for (let i = 0, l = seq.length; i < l; i += 3) {
          const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              const chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      let cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (let i = 0; i < 128; i++) {
        const ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (let i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      const cache = getEncodeCache(exclude);
      let result = "";
      for (let i = 0, l = string.length; i < l; i++) {
        const code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            const nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    function format(url) {
      let result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    }
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url)
        return url;
      const u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      let lowerProto, hec, slashes;
      let rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        const simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      let proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        let hostEnd = -1;
        for (let i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        let auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (let i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        const host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          const hostparts = this.hostname.split(/\./);
          for (let i = 0, l = hostparts.length; i < l; i++) {
            const part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              let newpart = "";
              for (let j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                const validParts = hostparts.slice(0, i);
                const notHost = hostparts.slice(i + 1);
                const bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      const hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      const qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      let port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports.decode = decode;
    exports.encode = encode;
    exports.format = format;
    exports.parse = urlParse;
  }
});

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/build/index.cjs.js
var require_index_cjs2 = __commonJS({
  "../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/build/index.cjs.js"(exports) {
    "use strict";
    var regex$5 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regex$4 = /[\0-\x1F\x7F-\x9F]/;
    var regex$3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
    var regex$2 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
    var regex$1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
    var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    exports.Any = regex$5;
    exports.Cc = regex$4;
    exports.Cf = regex$3;
    exports.P = regex$2;
    exports.S = regex$1;
    exports.Z = regex;
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
      return c.charCodeAt(0);
    }));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
      return c.charCodeAt(0);
    }));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
        if (start !== end) {
          var digitCount = end - start;
          this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }();
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(str, offset + 1);
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : function(c, index) {
      return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
    };
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i) + next;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i + 1 < str.length) {
            var nextChar = str.charCodeAt(i + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// ../../node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/build/index.cjs.js
var require_index_cjs3 = __commonJS({
  "../../node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/build/index.cjs.js"(exports, module2) {
    "use strict";
    var uc_micro = require_index_cjs2();
    function reFactory(opts) {
      const re = {};
      opts = opts || {};
      re.src_Any = uc_micro.Any.source;
      re.src_Cc = uc_micro.Cc.source;
      re.src_Z = uc_micro.Z.source;
      re.src_P = uc_micro.P.source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      const text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    }
    function assign(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          const tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          const tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          const tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        const tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      const re = self2.re = reFactory(self2.__opts__);
      const tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      const aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        const val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        const compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      const slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      const start = self2.__index__;
      const end = self2.__last_index__;
      const text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      const match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      let m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      const result = [];
      let shift = 0;
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      let tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      const m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      const len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// ../../node_modules/.pnpm/punycode.js@2.3.1/node_modules/punycode.js/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/.pnpm/punycode.js@2.3.1/node_modules/punycode.js/punycode.js"(exports, module2) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7F]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, callback) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback(array[length]);
      }
      return result;
    }
    function mapDomain(domain, callback) {
      const parts = domain.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map(labels, callback).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    var basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    var encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t2) {
                break;
              }
              const qMinusT = q - t2;
              const baseMinusT = base - t2;
              output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.3.1",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module2.exports = punycode;
  }
});

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/dist/index.cjs.js
var require_index_cjs4 = __commonJS({
  "../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/dist/index.cjs.js"(exports, module2) {
    "use strict";
    var mdurl = require_index_cjs();
    var ucmicro = require_index_cjs2();
    var entities = require_lib();
    var LinkifyIt = require_index_cjs3();
    var punycode = require_punycode();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var mdurl__namespace = /* @__PURE__ */ _interopNamespaceDefault(mdurl);
    var ucmicro__namespace = /* @__PURE__ */ _interopNamespaceDefault(ucmicro);
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        const surrogate1 = 55296 + (c >> 10);
        const surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
    function replaceEntityPattern(match, name) {
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code2)) {
          return fromCodePoint(code2);
        }
        return match;
      }
      const decoded = entities.decodeHTML(match);
      if (decoded !== match) {
        return decoded;
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity2);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code2) {
      switch (code2) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code2) {
      if (code2 >= 8192 && code2 <= 8202) {
        return true;
      }
      switch (code2) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    function isPunctChar(ch) {
      return ucmicro__namespace.P.test(ch) || ucmicro__namespace.S.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(//g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    var lib = {
      mdurl: mdurl__namespace,
      ucmicro: ucmicro__namespace
    };
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      arrayReplaceAt,
      assign,
      escapeHtml,
      escapeRE,
      fromCodePoint,
      has,
      isMdAsciiPunct,
      isPunctChar,
      isSpace,
      isString,
      isValidEntityCode,
      isWhiteSpace,
      lib,
      normalizeReference,
      unescapeAll,
      unescapeMd
    });
    function parseLinkLabel(state, start, disableNested) {
      let level, found, marker, prevPos;
      const max = state.posMax;
      const oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      let labelEnd = -1;
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    }
    function parseLinkDestination(str, start, max) {
      let code2;
      let pos = start;
      const result = {
        ok: false,
        pos: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      let level = 0;
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.pos = pos;
      result.ok = true;
      return result;
    }
    function parseLinkTitle(str, start, max, prev_state) {
      let code2;
      let pos = start;
      const state = {
        ok: false,
        can_continue: false,
        pos: 0,
        str: "",
        marker: 0
      };
      if (prev_state) {
        state.str = prev_state.str;
        state.marker = prev_state.marker;
      } else {
        if (pos >= max) {
          return state;
        }
        let marker = str.charCodeAt(pos);
        if (marker !== 34 && marker !== 39 && marker !== 40) {
          return state;
        }
        start++;
        pos++;
        if (marker === 40) {
          marker = 41;
        }
        state.marker = marker;
      }
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === state.marker) {
          state.pos = pos + 1;
          state.str += unescapeAll(str.slice(start, pos));
          state.ok = true;
          return state;
        } else if (code2 === 40 && state.marker === 41) {
          return state;
        } else if (code2 === 92 && pos + 1 < max) {
          pos++;
        }
        pos++;
      }
      state.can_continue = true;
      state.str += unescapeAll(str.slice(start, pos));
      return state;
    }
    var helpers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      parseLinkDestination,
      parseLinkLabel,
      parseLinkTitle
    });
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      const token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      const token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      const token = tokens[idx];
      const info = token.info ? unescapeAll(token.info).trim() : "";
      let langName = "";
      let langAttrs = "";
      if (info) {
        const arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      let highlighted;
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        const i = token.attrIndex("class");
        const tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        const tmpToken = {
          attrs: tmpAttrs
        };
        return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
      }
      return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      const token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      let i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      const token = tokens[idx];
      let result = "";
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      let needLf = false;
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            const nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      let result = "";
      const rules = this.rules;
      for (let i = 0, len = tokens.length; i < len; i++) {
        const type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      let result = "";
      for (let i = 0, len = tokens.length; i < len; i++) {
        switch (tokens[i].type) {
          case "text":
            result += tokens[i].content;
            break;
          case "image":
            result += this.renderInlineAsText(tokens[i].children, options, env);
            break;
          case "html_inline":
          case "html_block":
            result += tokens[i].content;
            break;
          case "softbreak":
          case "hardbreak":
            result += "\n";
            break;
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      let result = "";
      const rules = this.rules;
      for (let i = 0, len = tokens.length; i < len; i++) {
        const type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (let i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      const self2 = this;
      const chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      const index = this.__find__(name);
      const opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      const index = this.__find__(beforeName);
      const opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      const index = this.__find__(afterName);
      const opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      const opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      const result = [];
      list2.forEach(function(name) {
        const idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      const result = [];
      list2.forEach(function(name) {
        const idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    function Token2(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex2(name) {
      if (!this.attrs) {
        return -1;
      }
      const attrs = this.attrs;
      for (let i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush2(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet2(name, value) {
      const idx = this.attrIndex(name);
      const attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet2(name) {
      const idx = this.attrIndex(name);
      let value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token2.prototype.attrJoin = function attrJoin2(name, value) {
      const idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token2;
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    function normalize(state) {
      let str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    }
    function block(state) {
      let token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    }
    function inline(state) {
      const tokens = state.tokens;
      for (let i = 0, l = tokens.length; i < l; i++) {
        const tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    }
    function isLinkOpen$1(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose$1(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function linkify$1(state) {
      const blockTokens = state.tokens;
      if (!state.md.options.linkify) {
        return;
      }
      for (let j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        let tokens = blockTokens[j].children;
        let htmlLinkLevel = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          const currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose$1(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            const text2 = currentToken.content;
            let links = state.md.linkify.match(text2);
            const nodes = [];
            let level = currentToken.level;
            let lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (let ln = 0; ln < links.length; ln++) {
              const url = links[ln].url;
              const fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              let urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              const pos = links[ln].index;
              if (pos > lastPos) {
                const token = new state.Token("text", "", 0);
                token.content = text2.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              const token_o = new state.Token("link_open", "a", 1);
              token_o.attrs = [["href", fullUrl]];
              token_o.level = level++;
              token_o.markup = "linkify";
              token_o.info = "auto";
              nodes.push(token_o);
              const token_t = new state.Token("text", "", 0);
              token_t.content = urlText;
              token_t.level = level;
              nodes.push(token_t);
              const token_c = new state.Token("link_close", "a", -1);
              token_c.level = --level;
              token_c.markup = "linkify";
              token_c.info = "auto";
              nodes.push(token_c);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              const token = new state.Token("text", "", 0);
              token.content = text2.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    }
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      let inside_autolink = 0;
      for (let i = inlineTokens.length - 1; i >= 0; i--) {
        const token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      let inside_autolink = 0;
      for (let i = inlineTokens.length - 1; i >= 0; i--) {
        const token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace(state) {
      let blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    }
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      let j;
      const stack = [];
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        let text2 = token.content;
        let pos = 0;
        let max = text2.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            const t2 = QUOTE_RE.exec(text2);
            if (!t2) {
              break;
            }
            let canOpen = true;
            let canClose = true;
            pos = t2.index + 1;
            const isSingle = t2[0] === "'";
            let lastChar = 32;
            if (t2.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t2.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            let nextChar = 32;
            if (pos < max) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            const isLastWhiteSpace = isWhiteSpace(lastChar);
            const isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t2[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t2.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                let item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  let openQuote;
                  let closeQuote;
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t2.index, closeQuote);
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token.content;
                  max = text2.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t2.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
          }
      }
    }
    function smartquotes(state) {
      if (!state.md.options.typographer) {
        return;
      }
      for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    }
    function text_join(state) {
      let curr, last;
      const blockTokens = state.tokens;
      const l = blockTokens.length;
      for (let j = 0; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        const tokens = blockTokens[j].children;
        const max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    }
    var _rules$2 = [
      ["normalize", normalize],
      ["block", block],
      ["inline", inline],
      ["linkify", linkify$1],
      ["replacements", replace],
      ["smartquotes", smartquotes],
      ["text_join", text_join]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (let i = 0; i < _rules$2.length; i++) {
        this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      const rules = this.ruler.getRules("");
      for (let i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = StateCore;
    function StateBlock(src, md, env, tokens) {
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      const s = this.src;
      for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
        const ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      const token = new Token2(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (let max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      for (let max = this.src.length; pos < max; pos++) {
        const ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (let max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      if (begin >= end) {
        return "";
      }
      const queue = new Array(end - begin);
      for (let i = 0, line = begin; line < end; line++, i++) {
        let lineIndent = 0;
        const lineStart = this.bMarks[line];
        let first = lineStart;
        let last;
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          const ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token2;
    var MAX_AUTOCOMPLETED_CELLS = 65536;
    function getLine(state, line) {
      const pos = state.bMarks[line] + state.tShift[line];
      const max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str) {
      const result = [];
      const max = str.length;
      let pos = 0;
      let ch = str.charCodeAt(pos);
      let isEscaped = false;
      let lastPos = 0;
      let current = "";
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    function table(state, startLine, endLine, silent) {
      if (startLine + 2 > endLine) {
        return false;
      }
      let nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      const firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      const secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        const ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      let lineText = getLine(state, startLine + 1);
      let columns = lineText.split("|");
      const aligns = [];
      for (let i = 0; i < columns.length; i++) {
        const t2 = columns[i].trim();
        if (!t2) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t2)) {
          return false;
        }
        if (t2.charCodeAt(t2.length - 1) === 58) {
          aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t2.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      const columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      const oldParentType = state.parentType;
      state.parentType = "table";
      const terminatorRules = state.md.block.ruler.getRules("blockquote");
      const token_to = state.push("table_open", "table", 1);
      const tableLines = [startLine, 0];
      token_to.map = tableLines;
      const token_tho = state.push("thead_open", "thead", 1);
      token_tho.map = [startLine, startLine + 1];
      const token_htro = state.push("tr_open", "tr", 1);
      token_htro.map = [startLine, startLine + 1];
      for (let i = 0; i < columns.length; i++) {
        const token_ho = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token_ho.attrs = [["style", "text-align:" + aligns[i]]];
        }
        const token_il = state.push("inline", "", 0);
        token_il.content = columns[i].trim();
        token_il.children = [];
        state.push("th_close", "th", -1);
      }
      state.push("tr_close", "tr", -1);
      state.push("thead_close", "thead", -1);
      let tbodyLines;
      let autocompletedCells = 0;
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        autocompletedCells += columnCount - columns.length;
        if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
          break;
        }
        if (nextLine === startLine + 2) {
          const token_tbo = state.push("tbody_open", "tbody", 1);
          token_tbo.map = tbodyLines = [startLine + 2, 0];
        }
        const token_tro = state.push("tr_open", "tr", 1);
        token_tro.map = [nextLine, nextLine + 1];
        for (let i = 0; i < columnCount; i++) {
          const token_tdo = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
          }
          const token_il = state.push("inline", "", 0);
          token_il.content = columns[i] ? columns[i].trim() : "";
          token_il.children = [];
          state.push("td_close", "td", -1);
        }
        state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    }
    function code(state, startLine, endLine) {
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      let nextLine = startLine + 1;
      let last = nextLine;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      const token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    }
    function fence(state, startLine, endLine, silent) {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      const marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      let mem = pos;
      pos = state.skipChars(pos, marker);
      let len = pos - mem;
      if (len < 3) {
        return false;
      }
      const markup = state.src.slice(mem, pos);
      const params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      let nextLine = startLine;
      let haveEndMarker = false;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      const token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    }
    function blockquote(state, startLine, endLine, silent) {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      const oldLineMax = state.lineMax;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      const oldBMarks = [];
      const oldBSCount = [];
      const oldSCount = [];
      const oldTShift = [];
      const terminatorRules = state.md.block.ruler.getRules("blockquote");
      const oldParentType = state.parentType;
      state.parentType = "blockquote";
      let lastLineEmpty = false;
      let nextLine;
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        const isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          let initial = state.sCount[nextLine] + 1;
          let spaceAfterMarker;
          let adjustTab;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial) % 4 === 3) {
              pos++;
              initial++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          let offset = initial;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            const ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      const oldIndent = state.blkIndent;
      state.blkIndent = 0;
      const token_o = state.push("blockquote_open", "blockquote", 1);
      token_o.markup = ">";
      const lines = [startLine, 0];
      token_o.map = lines;
      state.md.block.tokenize(state, startLine, nextLine);
      const token_c = state.push("blockquote_close", "blockquote", -1);
      token_c.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (let i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    }
    function hr(state, startLine, endLine, silent) {
      const max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      const marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      let cnt = 1;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      const token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    }
    function skipBulletListMarker(state, startLine) {
      const max = state.eMarks[startLine];
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      const marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      const start = state.bMarks[startLine] + state.tShift[startLine];
      const max = state.eMarks[startLine];
      let pos = start;
      if (pos + 1 >= max) {
        return -1;
      }
      let ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      const level = state.level + 2;
      for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    function list(state, startLine, endLine, silent) {
      let max, pos, start, token;
      let nextLine = startLine;
      let tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      let isTerminatingParagraph = false;
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      let isOrdered;
      let markerValue;
      let posAfterMarker;
      if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      const listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      const listLines = [nextLine, 0];
      token.map = listLines;
      token.markup = String.fromCharCode(markerCharCode);
      let prevEmptyEnd = false;
      const terminatorRules = state.md.block.ruler.getRules("list");
      const oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        let offset = initial;
        while (pos < max) {
          const ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        const contentStart = pos;
        let indentAfterMarker;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        const indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        const itemLines = [nextLine, 0];
        token.map = itemLines;
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        const oldTight = state.tight;
        const oldTShift = state.tShift[nextLine];
        const oldSCount = state.sCount[nextLine];
        const oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    }
    function reference(state, startLine, _endLine, silent) {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      let nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      function getNextLine(nextLine2) {
        const endLine = state.lineMax;
        if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
          return null;
        }
        let isContinuation = false;
        if (state.sCount[nextLine2] - state.blkIndent > 3) {
          isContinuation = true;
        }
        if (state.sCount[nextLine2] < 0) {
          isContinuation = true;
        }
        if (!isContinuation) {
          const terminatorRules = state.md.block.ruler.getRules("reference");
          const oldParentType = state.parentType;
          state.parentType = "reference";
          let terminate = false;
          for (let i = 0, l = terminatorRules.length; i < l; i++) {
            if (terminatorRules[i](state, nextLine2, endLine, true)) {
              terminate = true;
              break;
            }
          }
          state.parentType = oldParentType;
          if (terminate) {
            return null;
          }
        }
        const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
        const max2 = state.eMarks[nextLine2];
        return state.src.slice(pos2, max2 + 1);
      }
      let str = state.src.slice(pos, max + 1);
      max = str.length;
      let labelEnd = -1;
      for (pos = 1; pos < max; pos++) {
        const ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          const lineContent = getNextLine(nextLine);
          if (lineContent !== null) {
            str += lineContent;
            max = str.length;
            nextLine++;
          }
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            const lineContent = getNextLine(nextLine);
            if (lineContent !== null) {
              str += lineContent;
              max = str.length;
              nextLine++;
            }
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        const ch = str.charCodeAt(pos);
        if (ch === 10) {
          const lineContent = getNextLine(nextLine);
          if (lineContent !== null) {
            str += lineContent;
            max = str.length;
            nextLine++;
          }
        } else if (isSpace(ch))
          ;
        else {
          break;
        }
      }
      const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!destRes.ok) {
        return false;
      }
      const href = state.md.normalizeLink(destRes.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = destRes.pos;
      const destEndPos = pos;
      const destEndLineNo = nextLine;
      const start = pos;
      for (; pos < max; pos++) {
        const ch = str.charCodeAt(pos);
        if (ch === 10) {
          const lineContent = getNextLine(nextLine);
          if (lineContent !== null) {
            str += lineContent;
            max = str.length;
            nextLine++;
          }
        } else if (isSpace(ch))
          ;
        else {
          break;
        }
      }
      let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
      while (titleRes.can_continue) {
        const lineContent = getNextLine(nextLine);
        if (lineContent === null)
          break;
        str += lineContent;
        pos = max;
        max = str.length;
        nextLine++;
        titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
      }
      let title;
      if (pos < max && start !== pos && titleRes.ok) {
        title = titleRes.str;
        pos = titleRes.pos;
      } else {
        title = "";
        pos = destEndPos;
        nextLine = destEndLineNo;
      }
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          nextLine = destEndLineNo;
          while (pos < max) {
            const ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      const label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = {
          title,
          href
        };
      }
      state.line = nextLine;
      return true;
    }
    var block_names = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"];
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Za-z][^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    var HTML_SEQUENCES = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]];
    function html_block(state, startLine, endLine, silent) {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      let lineText = state.src.slice(pos, max);
      let i = 0;
      for (; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      let nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      const token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    }
    function heading(state, startLine, endLine, silent) {
      let pos = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      let ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      let level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      const tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      const token_o = state.push("heading_open", "h" + String(level), 1);
      token_o.markup = "########".slice(0, level);
      token_o.map = [startLine, state.line];
      const token_i = state.push("inline", "", 0);
      token_i.content = state.src.slice(pos, max).trim();
      token_i.map = [startLine, state.line];
      token_i.children = [];
      const token_c = state.push("heading_close", "h" + String(level), -1);
      token_c.markup = "########".slice(0, level);
      return true;
    }
    function lheading(state, startLine, endLine) {
      const terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      const oldParentType = state.parentType;
      state.parentType = "paragraph";
      let level = 0;
      let marker;
      let nextLine = startLine + 1;
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          let pos = state.bMarks[nextLine] + state.tShift[nextLine];
          const max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      const token_o = state.push("heading_open", "h" + String(level), 1);
      token_o.markup = String.fromCharCode(marker);
      token_o.map = [startLine, state.line];
      const token_i = state.push("inline", "", 0);
      token_i.content = content;
      token_i.map = [startLine, state.line - 1];
      token_i.children = [];
      const token_c = state.push("heading_close", "h" + String(level), -1);
      token_c.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    }
    function paragraph(state, startLine, endLine) {
      const terminatorRules = state.md.block.ruler.getRules("paragraph");
      const oldParentType = state.parentType;
      let nextLine = startLine + 1;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      const token_o = state.push("paragraph_open", "p", 1);
      token_o.map = [startLine, state.line];
      const token_i = state.push("inline", "", 0);
      token_i.content = content;
      token_i.map = [startLine, state.line];
      token_i.children = [];
      state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    }
    var _rules$1 = [
      ["table", table, ["paragraph", "reference"]],
      ["code", code],
      ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
      ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
      ["list", list, ["paragraph", "reference", "blockquote"]],
      ["reference", reference],
      ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
      ["heading", heading, ["paragraph", "reference", "blockquote"]],
      ["lheading", lheading],
      ["paragraph", paragraph]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (let i = 0; i < _rules$1.length; i++) {
        this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
          alt: (_rules$1[i][2] || []).slice()
        });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      const rules = this.ruler.getRules("");
      const len = rules.length;
      const maxNesting = state.md.options.maxNesting;
      let line = startLine;
      let hasEmptyLines = false;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        const prevLine = state.line;
        let ok = false;
        for (let i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      if (!src) {
        return;
      }
      const state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = StateBlock;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      const token = new Token2("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      const token = new Token2(type, tag, nesting);
      let token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = {
          delimiters: this.delimiters
        };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      const max = this.posMax;
      const marker = this.src.charCodeAt(start);
      const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      let pos = start;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      const count = pos - start;
      const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      const isLastWhiteSpace = isWhiteSpace(lastChar);
      const isNextWhiteSpace = isWhiteSpace(nextChar);
      const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
      const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
      const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
      const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token2;
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function text(state, silent) {
      let pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    }
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    function linkify(state, silent) {
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      const pos = state.pos;
      const max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      const match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      const proto = match[1];
      const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link2)
        return false;
      let url = link2.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      const fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        const token_o = state.push("link_open", "a", 1);
        token_o.attrs = [["href", fullUrl]];
        token_o.markup = "linkify";
        token_o.info = "auto";
        const token_t = state.push("text", "", 0);
        token_t.content = state.md.normalizeLinkText(url);
        const token_c = state.push("link_close", "a", -1);
        token_c.markup = "linkify";
        token_c.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    }
    function newline(state, silent) {
      let pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      const pmax = state.pending.length - 1;
      const max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            let ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    }
    var ESCAPED = [];
    for (let i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    function escape(state, silent) {
      let pos = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      let ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      let escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        const ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      const origStr = "\\" + escapedStr;
      if (!silent) {
        const token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    }
    function backtick(state, silent) {
      let pos = state.pos;
      const ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      const start = pos;
      pos++;
      const max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      const marker = state.src.slice(start, pos);
      const openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      let matchEnd = pos;
      let matchStart;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        const closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            const token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    function strikethrough_tokenize(state, silent) {
      const start = state.pos;
      const marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      const scanned = state.scanDelims(state.pos, true);
      let len = scanned.length;
      const ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      let token;
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (let i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    }
    function postProcess$1(state, delimiters) {
      let token;
      const loneMarkers = [];
      const max = delimiters.length;
      for (let i = 0; i < max; i++) {
        const startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        const endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        const i = loneMarkers.pop();
        let j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    function strikethrough_postProcess(state) {
      const tokens_meta = state.tokens_meta;
      const max = state.tokens_meta.length;
      postProcess$1(state, state.delimiters);
      for (let curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess$1(state, tokens_meta[curr].delimiters);
        }
      }
    }
    var r_strikethrough = {
      tokenize: strikethrough_tokenize,
      postProcess: strikethrough_postProcess
    };
    function emphasis_tokenize(state, silent) {
      const start = state.pos;
      const marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      const scanned = state.scanDelims(state.pos, marker === 42);
      for (let i = 0; i < scanned.length; i++) {
        const token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    }
    function postProcess(state, delimiters) {
      const max = delimiters.length;
      for (let i = max - 1; i >= 0; i--) {
        const startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        const endDelim = delimiters[startDelim.end];
        const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        const ch = String.fromCharCode(startDelim.marker);
        const token_o = state.tokens[startDelim.token];
        token_o.type = isStrong ? "strong_open" : "em_open";
        token_o.tag = isStrong ? "strong" : "em";
        token_o.nesting = 1;
        token_o.markup = isStrong ? ch + ch : ch;
        token_o.content = "";
        const token_c = state.tokens[endDelim.token];
        token_c.type = isStrong ? "strong_close" : "em_close";
        token_c.tag = isStrong ? "strong" : "em";
        token_c.nesting = -1;
        token_c.markup = isStrong ? ch + ch : ch;
        token_c.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    function emphasis_post_process(state) {
      const tokens_meta = state.tokens_meta;
      const max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (let curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    }
    var r_emphasis = {
      tokenize: emphasis_tokenize,
      postProcess: emphasis_post_process
    };
    function link(state, silent) {
      let code2, label, res, ref;
      let href = "";
      let title = "";
      let start = state.pos;
      let parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      const oldPos = state.pos;
      const max = state.posMax;
      const labelStart = state.pos + 1;
      const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      let pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        const token_o = state.push("link_open", "a", 1);
        const attrs = [["href", href]];
        token_o.attrs = attrs;
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    }
    function image(state, silent) {
      let code2, content, label, pos, ref, res, title, start;
      let href = "";
      const oldPos = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      const labelStart = state.pos + 2;
      const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        const tokens = [];
        state.md.inline.parse(content, state.md, state.env, tokens);
        const token = state.push("image", "img", 0);
        const attrs = [["src", href], ["alt", ""]];
        token.attrs = attrs;
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    }
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
    function autolink(state, silent) {
      let pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      const start = state.pos;
      const max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        const ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      const url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        const fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          const token_o = state.push("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.markup = "autolink";
          token_o.info = "auto";
          const token_t = state.push("text", "", 0);
          token_t.content = state.md.normalizeLinkText(url);
          const token_c = state.push("link_close", "a", -1);
          token_c.markup = "autolink";
          token_c.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        const fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          const token_o = state.push("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.markup = "autolink";
          token_o.info = "auto";
          const token_t = state.push("text", "", 0);
          token_t.content = state.md.normalizeLinkText(url);
          const token_c = state.push("link_close", "a", -1);
          token_c.markup = "autolink";
          token_c.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    }
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      const lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    function html_inline(state, silent) {
      if (!state.md.options.html) {
        return false;
      }
      const max = state.posMax;
      const pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      const ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      const match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        const token = state.push("html_inline", "", 0);
        token.content = match[0];
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    }
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    function entity(state, silent) {
      const pos = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      const ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        const match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            const code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            const token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        const match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          const decoded = entities.decodeHTML(match[0]);
          if (decoded !== match[0]) {
            if (!silent) {
              const token = state.push("text_special", "", 0);
              token.content = decoded;
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    }
    function processDelimiters(delimiters) {
      const openersBottom = {};
      const max = delimiters.length;
      if (!max)
        return;
      let headerIdx = 0;
      let lastTokenIdx = -2;
      const jumps = [];
      for (let closerIdx = 0; closerIdx < max; closerIdx++) {
        const closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        let openerIdx = headerIdx - jumps[headerIdx] - 1;
        let newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          const opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            let isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    function link_pairs(state) {
      const tokens_meta = state.tokens_meta;
      const max = state.tokens_meta.length;
      processDelimiters(state.delimiters);
      for (let curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(tokens_meta[curr].delimiters);
        }
      }
    }
    function fragments_join(state) {
      let curr, last;
      let level = 0;
      const tokens = state.tokens;
      const max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    }
    var _rules = [["text", text], ["linkify", linkify], ["newline", newline], ["escape", escape], ["backticks", backtick], ["strikethrough", r_strikethrough.tokenize], ["emphasis", r_emphasis.tokenize], ["link", link], ["image", image], ["autolink", autolink], ["html_inline", html_inline], ["entity", entity]];
    var _rules2 = [
      ["balance_pairs", link_pairs],
      ["strikethrough", r_strikethrough.postProcess],
      ["emphasis", r_emphasis.postProcess],
      ["fragments_join", fragments_join]
    ];
    function ParserInline() {
      this.ruler = new Ruler();
      for (let i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (let i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      const pos = state.pos;
      const rules = this.ruler.getRules("");
      const len = rules.length;
      const maxNesting = state.md.options.maxNesting;
      const cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      let ok = false;
      if (state.level < maxNesting) {
        for (let i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      const rules = this.ruler.getRules("");
      const len = rules.length;
      const end = state.posMax;
      const maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        const prevPos = state.pos;
        let ok = false;
        if (state.level < maxNesting) {
          for (let i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      const state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      const rules = this.ruler2.getRules("");
      const len = rules.length;
      for (let i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = StateInline;
    var cfg_default = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
    var cfg_zero = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: ["normalize", "block", "inline", "text_join"]
        },
        block: {
          rules: ["paragraph"]
        },
        inline: {
          rules: ["text"],
          rules2: ["balance_pairs", "fragments_join"]
        }
      }
    };
    var cfg_commonmark = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: ["normalize", "block", "inline", "text_join"]
        },
        block: {
          rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"]
        },
        inline: {
          rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"],
          rules2: ["balance_pairs", "emphasis", "fragments_join"]
        }
      }
    };
    var config = {
      default: cfg_default,
      zero: cfg_zero,
      commonmark: cfg_commonmark
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      const str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      const parsed = mdurl__namespace.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl__namespace.encode(mdurl__namespace.format(parsed));
    }
    function normalizeLinkText(url) {
      const parsed = mdurl__namespace.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl__namespace.decode(mdurl__namespace.format(parsed), mdurl__namespace.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }
      if (!options) {
        if (!isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new Core();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt.prototype.set = function(options) {
      assign(this.options, options);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      const self2 = this;
      if (isString(presets)) {
        const presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
      let result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      const missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
      let result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      const missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      const args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      const state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      const state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt;
  }
});

// ../../node_modules/.pnpm/markdown-it-deflist@2.1.0/node_modules/markdown-it-deflist/index.js
var require_markdown_it_deflist = __commonJS({
  "../../node_modules/.pnpm/markdown-it-deflist@2.1.0/node_modules/markdown-it-deflist/index.js"(exports, module2) {
    "use strict";
    module2.exports = function deflist_plugin(md) {
      var isSpace = md.utils.isSpace;
      function skipMarker(state, line) {
        var pos, marker, start = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
        if (start >= max) {
          return -1;
        }
        marker = state.src.charCodeAt(start++);
        if (marker !== 126 && marker !== 58) {
          return -1;
        }
        pos = state.skipSpaces(start);
        if (start === pos) {
          return -1;
        }
        if (pos >= max) {
          return -1;
        }
        return start;
      }
      function markTightParagraphs(state, idx) {
        var i, l, level = state.level + 2;
        for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
          if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
            state.tokens[i + 2].hidden = true;
            state.tokens[i].hidden = true;
            i += 2;
          }
        }
      }
      function deflist(state, startLine, endLine, silent) {
        var ch, contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, max, nextLine, offset, oldDDIndent, oldIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, prevEmptyEnd, tight, token;
        if (silent) {
          if (state.ddIndent < 0) {
            return false;
          }
          return skipMarker(state, startLine) >= 0;
        }
        nextLine = startLine + 1;
        if (nextLine >= endLine) {
          return false;
        }
        if (state.isEmpty(nextLine)) {
          nextLine++;
          if (nextLine >= endLine) {
            return false;
          }
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          return false;
        }
        contentStart = skipMarker(state, nextLine);
        if (contentStart < 0) {
          return false;
        }
        listTokIdx = state.tokens.length;
        tight = true;
        token = state.push("dl_open", "dl", 1);
        token.map = listLines = [startLine, 0];
        dtLine = startLine;
        ddLine = nextLine;
        OUTER:
          for (; ; ) {
            prevEmptyEnd = false;
            token = state.push("dt_open", "dt", 1);
            token.map = [dtLine, dtLine];
            token = state.push("inline", "", 0);
            token.map = [dtLine, dtLine];
            token.content = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();
            token.children = [];
            token = state.push("dt_close", "dt", -1);
            for (; ; ) {
              token = state.push("dd_open", "dd", 1);
              token.map = itemLines = [nextLine, 0];
              pos = contentStart;
              max = state.eMarks[ddLine];
              offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);
              while (pos < max) {
                ch = state.src.charCodeAt(pos);
                if (isSpace(ch)) {
                  if (ch === 9) {
                    offset += 4 - offset % 4;
                  } else {
                    offset++;
                  }
                } else {
                  break;
                }
                pos++;
              }
              contentStart = pos;
              oldTight = state.tight;
              oldDDIndent = state.ddIndent;
              oldIndent = state.blkIndent;
              oldTShift = state.tShift[ddLine];
              oldSCount = state.sCount[ddLine];
              oldParentType = state.parentType;
              state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;
              state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
              state.sCount[ddLine] = offset;
              state.tight = true;
              state.parentType = "deflist";
              state.md.block.tokenize(state, ddLine, endLine, true);
              if (!state.tight || prevEmptyEnd) {
                tight = false;
              }
              prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);
              state.tShift[ddLine] = oldTShift;
              state.sCount[ddLine] = oldSCount;
              state.tight = oldTight;
              state.parentType = oldParentType;
              state.blkIndent = oldIndent;
              state.ddIndent = oldDDIndent;
              token = state.push("dd_close", "dd", -1);
              itemLines[1] = nextLine = state.line;
              if (nextLine >= endLine) {
                break OUTER;
              }
              if (state.sCount[nextLine] < state.blkIndent) {
                break OUTER;
              }
              contentStart = skipMarker(state, nextLine);
              if (contentStart < 0) {
                break;
              }
              ddLine = nextLine;
            }
            if (nextLine >= endLine) {
              break;
            }
            dtLine = nextLine;
            if (state.isEmpty(dtLine)) {
              break;
            }
            if (state.sCount[dtLine] < state.blkIndent) {
              break;
            }
            ddLine = dtLine + 1;
            if (ddLine >= endLine) {
              break;
            }
            if (state.isEmpty(ddLine)) {
              ddLine++;
            }
            if (ddLine >= endLine) {
              break;
            }
            if (state.sCount[ddLine] < state.blkIndent) {
              break;
            }
            contentStart = skipMarker(state, ddLine);
            if (contentStart < 0) {
              break;
            }
          }
        token = state.push("dl_close", "dl", -1);
        listLines[1] = nextLine;
        state.line = nextLine;
        if (tight) {
          markTightParagraphs(state, listTokIdx);
        }
        return true;
      }
      md.block.ruler.before("paragraph", "deflist", deflist, { alt: ["paragraph", "reference", "blockquote"] });
    };
  }
});

// ../../node_modules/.pnpm/markdown-it-implicit-figures@0.9.0/node_modules/markdown-it-implicit-figures/index.js
var require_markdown_it_implicit_figures = __commonJS({
  "../../node_modules/.pnpm/markdown-it-implicit-figures@0.9.0/node_modules/markdown-it-implicit-figures/index.js"(exports, module2) {
    "use strict";
    module2.exports = function implicitFiguresPlugin(md, options) {
      options = options || {};
      function implicitFigures(state) {
        var tabIndex = 1;
        for (var i = 1, l = state.tokens.length; i < l - 1; ++i) {
          var token = state.tokens[i];
          if (token.type !== "inline") {
            continue;
          }
          if (!token.children || token.children.length !== 1 && token.children.length !== 3) {
            continue;
          }
          if (token.children.length === 1 && token.children[0].type !== "image") {
            continue;
          }
          if (token.children.length === 3 && (token.children[0].type !== "link_open" || token.children[1].type !== "image" || token.children[2].type !== "link_close")) {
            continue;
          }
          if (i !== 0 && state.tokens[i - 1].type !== "paragraph_open") {
            continue;
          }
          if (i !== l - 1 && state.tokens[i + 1].type !== "paragraph_close") {
            continue;
          }
          var figure = state.tokens[i - 1];
          figure.type = "figure_open";
          figure.tag = "figure";
          state.tokens[i + 1].type = "figure_close";
          state.tokens[i + 1].tag = "figure";
          if (options.dataType == true) {
            state.tokens[i - 1].attrPush(["data-type", "image"]);
          }
          var image;
          if (options.link == true && token.children.length === 1) {
            image = token.children[0];
            token.children.unshift(new state.Token("link_open", "a", 1));
            token.children[0].attrPush(["href", image.attrGet("src")]);
            token.children.push(new state.Token("link_close", "a", -1));
          }
          image = token.children.length === 1 ? token.children[0] : token.children[1];
          if (options.figcaption == true) {
            if (image.children && image.children.length) {
              token.children.push(new state.Token("figcaption_open", "figcaption", 1));
              token.children.splice(token.children.length, 0, ...image.children);
              token.children.push(new state.Token("figcaption_close", "figcaption", -1));
            }
          }
          if (options.copyAttrs && image.attrs) {
            const f = options.copyAttrs === true ? "" : options.copyAttrs;
            figure.attrs = image.attrs.filter(([k, v]) => k.match(f));
          }
          if (options.tabindex == true) {
            state.tokens[i - 1].attrPush(["tabindex", tabIndex]);
            tabIndex++;
          }
        }
      }
      md.core.ruler.before("linkify", "implicit_figures", implicitFigures);
    };
  }
});

// ../../node_modules/.pnpm/markdown-it-table-of-contents@0.4.4/node_modules/markdown-it-table-of-contents/index.js
var require_markdown_it_table_of_contents = __commonJS({
  "../../node_modules/.pnpm/markdown-it-table-of-contents@0.4.4/node_modules/markdown-it-table-of-contents/index.js"(exports, module2) {
    "use strict";
    var slugify = (s) => encodeURIComponent(String(s).trim().toLowerCase().replace(/\s+/g, "-"));
    var defaults = {
      includeLevel: [1, 2],
      containerClass: "table-of-contents",
      slugify,
      markerPattern: /^\[\[toc\]\]/im,
      listType: "ul",
      format: void 0,
      forceFullToc: false,
      containerHeaderHtml: void 0,
      containerFooterHtml: void 0,
      transformLink: void 0
    };
    module2.exports = (md, o) => {
      const options = Object.assign({}, defaults, o);
      const tocRegexp = options.markerPattern;
      let gstate;
      function toc(state, silent) {
        var token;
        var match;
        if (state.src.charCodeAt(state.pos) !== 91) {
          return false;
        }
        if (silent) {
          return false;
        }
        match = tocRegexp.exec(state.src.substr(state.pos));
        match = !match ? [] : match.filter(function(m) {
          return m;
        });
        if (match.length < 1) {
          return false;
        }
        token = state.push("toc_open", "toc", 1);
        token.markup = "[[toc]]";
        token = state.push("toc_body", "", 0);
        token = state.push("toc_close", "toc", -1);
        var newline = state.src.indexOf("\n", state.pos);
        if (newline !== -1) {
          state.pos = newline;
        } else {
          state.pos = state.pos + state.posMax + 1;
        }
        return true;
      }
      md.renderer.rules.toc_open = function(tokens, index) {
        var tocOpenHtml = `<div class="${options.containerClass}">`;
        if (options.containerHeaderHtml) {
          tocOpenHtml += options.containerHeaderHtml;
        }
        return tocOpenHtml;
      };
      md.renderer.rules.toc_close = function(tokens, index) {
        var tocFooterHtml = "";
        if (options.containerFooterHtml) {
          tocFooterHtml = options.containerFooterHtml;
        }
        return tocFooterHtml + `</div>`;
      };
      md.renderer.rules.toc_body = function(tokens, index) {
        if (options.forceFullToc) {
          var tocBody = "";
          var pos = 0;
          var tokenLength = gstate && gstate.tokens && gstate.tokens.length;
          while (pos < tokenLength) {
            var tocHierarchy = renderChildsTokens(pos, gstate.tokens);
            pos = tocHierarchy[0];
            tocBody += tocHierarchy[1];
          }
          return tocBody;
        } else {
          return renderChildsTokens(0, gstate.tokens)[1];
        }
      };
      function renderChildsTokens(pos, tokens) {
        var headings = [], buffer = "", currentLevel, subHeadings, size = tokens.length, i = pos;
        while (i < size) {
          var token = tokens[i];
          var heading = tokens[i - 1];
          var level = token.tag && parseInt(token.tag.substr(1, 1));
          if (token.type !== "heading_close" || options.includeLevel.indexOf(level) == -1 || heading.type !== "inline") {
            i++;
            continue;
          }
          if (!currentLevel) {
            currentLevel = level;
          } else {
            if (level > currentLevel) {
              subHeadings = renderChildsTokens(i, tokens);
              buffer += subHeadings[1];
              i = subHeadings[0];
              continue;
            }
            if (level < currentLevel) {
              buffer += `</li>`;
              headings.push(buffer);
              return [i, `<${options.listType}>${headings.join("")}</${options.listType}>`];
            }
            if (level == currentLevel) {
              buffer += `</li>`;
              headings.push(buffer);
            }
          }
          var slugifiedContent = options.slugify(heading.content);
          var link = "#" + slugifiedContent;
          if (options.transformLink) {
            link = options.transformLink(link);
          }
          buffer = `<li><a href="${link}">`;
          buffer += typeof options.format === "function" ? options.format(heading.content) : heading.content;
          buffer += `</a>`;
          i++;
        }
        buffer += buffer === "" ? "" : `</li>`;
        headings.push(buffer);
        return [i, `<${options.listType}>${headings.join("")}</${options.listType}>`];
      }
      md.core.ruler.push("grab_state", function(state) {
        gstate = state;
      });
      md.inline.ruler.after("emphasis", "toc", toc);
    };
  }
});

// ../../node_modules/.pnpm/markdown-it-ruby@0.1.1/node_modules/markdown-it-ruby/index.js
var require_markdown_it_ruby = __commonJS({
  "../../node_modules/.pnpm/markdown-it-ruby@0.1.1/node_modules/markdown-it-ruby/index.js"(exports, module2) {
    "use strict";
    function ddmd_ruby(state, silent) {
      var token, tokens, max = state.posMax, start = state.pos, devPos, closePos, baseText, rubyText, baseArray, rubyArray;
      if (silent) {
        return false;
      }
      if (state.src.charCodeAt(start) !== 123) {
        return false;
      }
      if (start + 4 >= max) {
        return false;
      }
      state.pos = start + 1;
      while (state.pos < max) {
        if (devPos) {
          if (state.src.charCodeAt(state.pos) === 125 && state.src.charCodeAt(state.pos - 1) !== 92) {
            closePos = state.pos;
            break;
          }
        } else if (state.src.charCodeAt(state.pos) === 124 && state.src.charCodeAt(state.pos - 1) !== 92) {
          devPos = state.pos;
        }
        state.pos++;
      }
      if (!closePos || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      token = state.push("ruby_open", "ruby", 1);
      token.markup = "{";
      baseText = state.src.slice(start + 1, devPos);
      rubyText = state.src.slice(devPos + 1, closePos);
      baseArray = baseText.split("");
      rubyArray = rubyText.split("|");
      if (baseArray.length === rubyArray.length) {
        baseArray.forEach(function(content, idx) {
          state.md.inline.parse(content, state.md, state.env, tokens = []);
          tokens.forEach(function(t2) {
            state.tokens.push(t2);
          });
          token = state.push("rt_open", "rt", 1);
          state.md.inline.parse(rubyArray[idx], state.md, state.env, tokens = []);
          tokens.forEach(function(t2) {
            state.tokens.push(t2);
          });
          token = state.push("rt_close", "rt", -1);
        });
      } else {
        state.md.inline.parse(baseText, state.md, state.env, tokens = []);
        tokens.forEach(function(t2) {
          state.tokens.push(t2);
        });
        token = state.push("rt_open", "rt", 1);
        state.md.inline.parse(rubyText, state.md, state.env, tokens = []);
        tokens.forEach(function(t2) {
          state.tokens.push(t2);
        });
        token = state.push("rt_close", "rt", -1);
      }
      token = state.push("ruby_close", "ruby", -1);
      token.markup = "}";
      state.pos = state.posMax + 1;
      state.posMax = max;
      return true;
    }
    module2.exports = function ruby_plugin(md) {
      md.inline.ruler.before("text", "ddmd_ruby", ddmd_ruby);
    };
  }
});

// ../../node_modules/.pnpm/markdown-it-mark@4.0.0/node_modules/markdown-it-mark/dist/index.cjs.js
var require_index_cjs5 = __commonJS({
  "../../node_modules/.pnpm/markdown-it-mark@4.0.0/node_modules/markdown-it-mark/dist/index.cjs.js"(exports, module2) {
    "use strict";
    function ins_plugin(md) {
      function tokenize(state, silent) {
        const start = state.pos;
        const marker = state.src.charCodeAt(start);
        if (silent) {
          return false;
        }
        if (marker !== 61) {
          return false;
        }
        const scanned = state.scanDelims(state.pos, true);
        let len = scanned.length;
        const ch = String.fromCharCode(marker);
        if (len < 2) {
          return false;
        }
        if (len % 2) {
          const token = state.push("text", "", 0);
          token.content = ch;
          len--;
        }
        for (let i = 0; i < len; i += 2) {
          const token = state.push("text", "", 0);
          token.content = ch + ch;
          if (!scanned.can_open && !scanned.can_close) {
            continue;
          }
          state.delimiters.push({
            marker,
            length: 0,
            jump: i / 2,
            token: state.tokens.length - 1,
            end: -1,
            open: scanned.can_open,
            close: scanned.can_close
          });
        }
        state.pos += scanned.length;
        return true;
      }
      function postProcess(state, delimiters) {
        const loneMarkers = [];
        const max = delimiters.length;
        for (let i = 0; i < max; i++) {
          const startDelim = delimiters[i];
          if (startDelim.marker !== 61) {
            continue;
          }
          if (startDelim.end === -1) {
            continue;
          }
          const endDelim = delimiters[startDelim.end];
          const token_o = state.tokens[startDelim.token];
          token_o.type = "mark_open";
          token_o.tag = "mark";
          token_o.nesting = 1;
          token_o.markup = "==";
          token_o.content = "";
          const token_c = state.tokens[endDelim.token];
          token_c.type = "mark_close";
          token_c.tag = "mark";
          token_c.nesting = -1;
          token_c.markup = "==";
          token_c.content = "";
          if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
            loneMarkers.push(endDelim.token - 1);
          }
        }
        while (loneMarkers.length) {
          const i = loneMarkers.pop();
          let j = i + 1;
          while (j < state.tokens.length && state.tokens[j].type === "mark_close") {
            j++;
          }
          j--;
          if (i !== j) {
            const token = state.tokens[j];
            state.tokens[j] = state.tokens[i];
            state.tokens[i] = token;
          }
        }
      }
      md.inline.ruler.before("emphasis", "mark", tokenize);
      md.inline.ruler2.before("emphasis", "mark", function(state) {
        let curr;
        const tokens_meta = state.tokens_meta;
        const max = (state.tokens_meta || []).length;
        postProcess(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            postProcess(state, tokens_meta[curr].delimiters);
          }
        }
      });
    }
    module2.exports = ins_plugin;
  }
});

// ../../node_modules/.pnpm/markdown-it-sub@2.0.0/node_modules/markdown-it-sub/dist/index.cjs.js
var require_index_cjs6 = __commonJS({
  "../../node_modules/.pnpm/markdown-it-sub@2.0.0/node_modules/markdown-it-sub/dist/index.cjs.js"(exports, module2) {
    "use strict";
    var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
    function subscript(state, silent) {
      const max = state.posMax;
      const start = state.pos;
      if (state.src.charCodeAt(start) !== 126) {
        return false;
      }
      if (silent) {
        return false;
      }
      if (start + 2 >= max) {
        return false;
      }
      state.pos = start + 1;
      let found = false;
      while (state.pos < max) {
        if (state.src.charCodeAt(state.pos) === 126) {
          found = true;
          break;
        }
        state.md.inline.skipToken(state);
      }
      if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      const content = state.src.slice(start + 1, state.pos);
      if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      const token_so = state.push("sub_open", "sub", 1);
      token_so.markup = "~";
      const token_t = state.push("text", "", 0);
      token_t.content = content.replace(UNESCAPE_RE, "$1");
      const token_sc = state.push("sub_close", "sub", -1);
      token_sc.markup = "~";
      state.pos = state.posMax + 1;
      state.posMax = max;
      return true;
    }
    function sub_plugin(md) {
      md.inline.ruler.after("emphasis", "sub", subscript);
    }
    module2.exports = sub_plugin;
  }
});

// ../../node_modules/.pnpm/markdown-it-sup@2.0.0/node_modules/markdown-it-sup/dist/index.cjs.js
var require_index_cjs7 = __commonJS({
  "../../node_modules/.pnpm/markdown-it-sup@2.0.0/node_modules/markdown-it-sup/dist/index.cjs.js"(exports, module2) {
    "use strict";
    var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
    function superscript(state, silent) {
      const max = state.posMax;
      const start = state.pos;
      if (state.src.charCodeAt(start) !== 94) {
        return false;
      }
      if (silent) {
        return false;
      }
      if (start + 2 >= max) {
        return false;
      }
      state.pos = start + 1;
      let found = false;
      while (state.pos < max) {
        if (state.src.charCodeAt(state.pos) === 94) {
          found = true;
          break;
        }
        state.md.inline.skipToken(state);
      }
      if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      const content = state.src.slice(start + 1, state.pos);
      if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      const token_so = state.push("sup_open", "sup", 1);
      token_so.markup = "^";
      const token_t = state.push("text", "", 0);
      token_t.content = content.replace(UNESCAPE_RE, "$1");
      const token_sc = state.push("sup_close", "sup", -1);
      token_sc.markup = "^";
      state.pos = state.posMax + 1;
      state.posMax = max;
      return true;
    }
    function sup_plugin(md) {
      md.inline.ruler.after("emphasis", "sup", superscript);
    }
    module2.exports = sup_plugin;
  }
});

// ../../node_modules/.pnpm/markdown-it-emoji@3.0.0/node_modules/markdown-it-emoji/dist/index.cjs.js
var require_index_cjs8 = __commonJS({
  "../../node_modules/.pnpm/markdown-it-emoji@3.0.0/node_modules/markdown-it-emoji/dist/index.cjs.js"(exports) {
    "use strict";
    function emoji_html(tokens, idx) {
      return tokens[idx].content;
    }
    function create_rule(md, emojies, shortcuts, scanRE, replaceRE) {
      const arrayReplaceAt = md.utils.arrayReplaceAt;
      const ucm = md.utils.lib.ucmicro;
      const has = md.utils.has;
      const ZPCc = new RegExp([ucm.Z.source, ucm.P.source, ucm.Cc.source].join("|"));
      function splitTextToken(text, level, Token2) {
        let last_pos = 0;
        const nodes = [];
        text.replace(replaceRE, function(match, offset, src) {
          let emoji_name;
          if (has(shortcuts, match)) {
            emoji_name = shortcuts[match];
            if (offset > 0 && !ZPCc.test(src[offset - 1]))
              return;
            if (offset + match.length < src.length && !ZPCc.test(src[offset + match.length])) {
              return;
            }
          } else {
            emoji_name = match.slice(1, -1);
          }
          if (offset > last_pos) {
            const token2 = new Token2("text", "", 0);
            token2.content = text.slice(last_pos, offset);
            nodes.push(token2);
          }
          const token = new Token2("emoji", "", 0);
          token.markup = emoji_name;
          token.content = emojies[emoji_name];
          nodes.push(token);
          last_pos = offset + match.length;
        });
        if (last_pos < text.length) {
          const token = new Token2("text", "", 0);
          token.content = text.slice(last_pos);
          nodes.push(token);
        }
        return nodes;
      }
      return function emoji_replace(state) {
        let token;
        const blockTokens = state.tokens;
        let autolinkLevel = 0;
        for (let j = 0, l = blockTokens.length; j < l; j++) {
          if (blockTokens[j].type !== "inline") {
            continue;
          }
          let tokens = blockTokens[j].children;
          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token.type === "link_open" || token.type === "link_close") {
              if (token.info === "auto") {
                autolinkLevel -= token.nesting;
              }
            }
            if (token.type === "text" && autolinkLevel === 0 && scanRE.test(token.content)) {
              blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, splitTextToken(token.content, token.level, state.Token));
            }
          }
        }
      };
    }
    function quoteRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    function normalize_opts(options) {
      let emojies = options.defs;
      if (options.enabled.length) {
        emojies = Object.keys(emojies).reduce((acc, key) => {
          if (options.enabled.indexOf(key) >= 0)
            acc[key] = emojies[key];
          return acc;
        }, {});
      }
      const shortcuts = Object.keys(options.shortcuts).reduce((acc, key) => {
        if (!emojies[key])
          return acc;
        if (Array.isArray(options.shortcuts[key])) {
          options.shortcuts[key].forEach((alias) => {
            acc[alias] = key;
          });
          return acc;
        }
        acc[options.shortcuts[key]] = key;
        return acc;
      }, {});
      const keys = Object.keys(emojies);
      let names;
      if (keys.length === 0) {
        names = "^$";
      } else {
        names = keys.map((name) => {
          return `:${name}:`;
        }).concat(Object.keys(shortcuts)).sort().reverse().map((name) => {
          return quoteRE(name);
        }).join("|");
      }
      const scanRE = RegExp(names);
      const replaceRE = RegExp(names, "g");
      return {
        defs: emojies,
        shortcuts,
        scanRE,
        replaceRE
      };
    }
    function emoji_plugin$2(md, options) {
      const defaults = {
        defs: {},
        shortcuts: {},
        enabled: []
      };
      const opts = normalize_opts(md.utils.assign({}, defaults, options || {}));
      md.renderer.rules.emoji = emoji_html;
      md.core.ruler.after("linkify", "emoji", create_rule(md, opts.defs, opts.shortcuts, opts.scanRE, opts.replaceRE));
    }
    var emojies_defs$1 = {
      "grinning": "\u{1F600}",
      "smiley": "\u{1F603}",
      "smile": "\u{1F604}",
      "grin": "\u{1F601}",
      "laughing": "\u{1F606}",
      "satisfied": "\u{1F606}",
      "sweat_smile": "\u{1F605}",
      "joy": "\u{1F602}",
      "wink": "\u{1F609}",
      "blush": "\u{1F60A}",
      "innocent": "\u{1F607}",
      "heart_eyes": "\u{1F60D}",
      "kissing_heart": "\u{1F618}",
      "kissing": "\u{1F617}",
      "kissing_closed_eyes": "\u{1F61A}",
      "kissing_smiling_eyes": "\u{1F619}",
      "yum": "\u{1F60B}",
      "stuck_out_tongue": "\u{1F61B}",
      "stuck_out_tongue_winking_eye": "\u{1F61C}",
      "stuck_out_tongue_closed_eyes": "\u{1F61D}",
      "neutral_face": "\u{1F610}",
      "expressionless": "\u{1F611}",
      "no_mouth": "\u{1F636}",
      "smirk": "\u{1F60F}",
      "unamused": "\u{1F612}",
      "relieved": "\u{1F60C}",
      "pensive": "\u{1F614}",
      "sleepy": "\u{1F62A}",
      "sleeping": "\u{1F634}",
      "mask": "\u{1F637}",
      "dizzy_face": "\u{1F635}",
      "sunglasses": "\u{1F60E}",
      "confused": "\u{1F615}",
      "worried": "\u{1F61F}",
      "open_mouth": "\u{1F62E}",
      "hushed": "\u{1F62F}",
      "astonished": "\u{1F632}",
      "flushed": "\u{1F633}",
      "frowning": "\u{1F626}",
      "anguished": "\u{1F627}",
      "fearful": "\u{1F628}",
      "cold_sweat": "\u{1F630}",
      "disappointed_relieved": "\u{1F625}",
      "cry": "\u{1F622}",
      "sob": "\u{1F62D}",
      "scream": "\u{1F631}",
      "confounded": "\u{1F616}",
      "persevere": "\u{1F623}",
      "disappointed": "\u{1F61E}",
      "sweat": "\u{1F613}",
      "weary": "\u{1F629}",
      "tired_face": "\u{1F62B}",
      "rage": "\u{1F621}",
      "pout": "\u{1F621}",
      "angry": "\u{1F620}",
      "smiling_imp": "\u{1F608}",
      "smiley_cat": "\u{1F63A}",
      "smile_cat": "\u{1F638}",
      "joy_cat": "\u{1F639}",
      "heart_eyes_cat": "\u{1F63B}",
      "smirk_cat": "\u{1F63C}",
      "kissing_cat": "\u{1F63D}",
      "scream_cat": "\u{1F640}",
      "crying_cat_face": "\u{1F63F}",
      "pouting_cat": "\u{1F63E}",
      "heart": "\u2764\uFE0F",
      "hand": "\u270B",
      "raised_hand": "\u270B",
      "v": "\u270C\uFE0F",
      "point_up": "\u261D\uFE0F",
      "fist_raised": "\u270A",
      "fist": "\u270A",
      "monkey_face": "\u{1F435}",
      "cat": "\u{1F431}",
      "cow": "\u{1F42E}",
      "mouse": "\u{1F42D}",
      "coffee": "\u2615",
      "hotsprings": "\u2668\uFE0F",
      "anchor": "\u2693",
      "airplane": "\u2708\uFE0F",
      "hourglass": "\u231B",
      "watch": "\u231A",
      "sunny": "\u2600\uFE0F",
      "star": "\u2B50",
      "cloud": "\u2601\uFE0F",
      "umbrella": "\u2614",
      "zap": "\u26A1",
      "snowflake": "\u2744\uFE0F",
      "sparkles": "\u2728",
      "black_joker": "\u{1F0CF}",
      "mahjong": "\u{1F004}",
      "phone": "\u260E\uFE0F",
      "telephone": "\u260E\uFE0F",
      "envelope": "\u2709\uFE0F",
      "pencil2": "\u270F\uFE0F",
      "black_nib": "\u2712\uFE0F",
      "scissors": "\u2702\uFE0F",
      "wheelchair": "\u267F",
      "warning": "\u26A0\uFE0F",
      "aries": "\u2648",
      "taurus": "\u2649",
      "gemini": "\u264A",
      "cancer": "\u264B",
      "leo": "\u264C",
      "virgo": "\u264D",
      "libra": "\u264E",
      "scorpius": "\u264F",
      "sagittarius": "\u2650",
      "capricorn": "\u2651",
      "aquarius": "\u2652",
      "pisces": "\u2653",
      "heavy_multiplication_x": "\u2716\uFE0F",
      "heavy_plus_sign": "\u2795",
      "heavy_minus_sign": "\u2796",
      "heavy_division_sign": "\u2797",
      "bangbang": "\u203C\uFE0F",
      "interrobang": "\u2049\uFE0F",
      "question": "\u2753",
      "grey_question": "\u2754",
      "grey_exclamation": "\u2755",
      "exclamation": "\u2757",
      "heavy_exclamation_mark": "\u2757",
      "wavy_dash": "\u3030\uFE0F",
      "recycle": "\u267B\uFE0F",
      "white_check_mark": "\u2705",
      "ballot_box_with_check": "\u2611\uFE0F",
      "heavy_check_mark": "\u2714\uFE0F",
      "x": "\u274C",
      "negative_squared_cross_mark": "\u274E",
      "curly_loop": "\u27B0",
      "loop": "\u27BF",
      "part_alternation_mark": "\u303D\uFE0F",
      "eight_spoked_asterisk": "\u2733\uFE0F",
      "eight_pointed_black_star": "\u2734\uFE0F",
      "sparkle": "\u2747\uFE0F",
      "copyright": "\xA9\uFE0F",
      "registered": "\xAE\uFE0F",
      "tm": "\u2122\uFE0F",
      "information_source": "\u2139\uFE0F",
      "m": "\u24C2\uFE0F",
      "black_circle": "\u26AB",
      "white_circle": "\u26AA",
      "black_large_square": "\u2B1B",
      "white_large_square": "\u2B1C",
      "black_medium_square": "\u25FC\uFE0F",
      "white_medium_square": "\u25FB\uFE0F",
      "black_medium_small_square": "\u25FE",
      "white_medium_small_square": "\u25FD",
      "black_small_square": "\u25AA\uFE0F",
      "white_small_square": "\u25AB\uFE0F"
    };
    var emojies_shortcuts = {
      angry: [">:(", ">:-("],
      blush: [':")', ':-")'],
      broken_heart: ["</3", "<\\3"],
      confused: [":/", ":-/"],
      cry: [":'(", ":'-(", ":,(", ":,-("],
      frowning: [":(", ":-("],
      heart: ["<3"],
      imp: ["]:(", "]:-("],
      innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
      joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
      kissing: [":*", ":-*"],
      laughing: ["x-)", "X-)"],
      neutral_face: [":|", ":-|"],
      open_mouth: [":o", ":-o", ":O", ":-O"],
      rage: [":@", ":-@"],
      smile: [":D", ":-D"],
      smiley: [":)", ":-)"],
      smiling_imp: ["]:)", "]:-)"],
      sob: [":,'(", ":,'-(", ";(", ";-("],
      stuck_out_tongue: [":P", ":-P"],
      sunglasses: ["8-)", "B-)"],
      sweat: [",:(", ",:-("],
      sweat_smile: [",:)", ",:-)"],
      unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
      wink: [";)", ";-)"]
    };
    function emoji_plugin$1(md, options) {
      const defaults = {
        defs: emojies_defs$1,
        shortcuts: emojies_shortcuts,
        enabled: []
      };
      const opts = md.utils.assign({}, defaults, options || {});
      emoji_plugin$2(md, opts);
    }
    var emojies_defs = {
      "100": "\u{1F4AF}",
      "1234": "\u{1F522}",
      "grinning": "\u{1F600}",
      "smiley": "\u{1F603}",
      "smile": "\u{1F604}",
      "grin": "\u{1F601}",
      "laughing": "\u{1F606}",
      "satisfied": "\u{1F606}",
      "sweat_smile": "\u{1F605}",
      "rofl": "\u{1F923}",
      "joy": "\u{1F602}",
      "slightly_smiling_face": "\u{1F642}",
      "upside_down_face": "\u{1F643}",
      "melting_face": "\u{1FAE0}",
      "wink": "\u{1F609}",
      "blush": "\u{1F60A}",
      "innocent": "\u{1F607}",
      "smiling_face_with_three_hearts": "\u{1F970}",
      "heart_eyes": "\u{1F60D}",
      "star_struck": "\u{1F929}",
      "kissing_heart": "\u{1F618}",
      "kissing": "\u{1F617}",
      "relaxed": "\u263A\uFE0F",
      "kissing_closed_eyes": "\u{1F61A}",
      "kissing_smiling_eyes": "\u{1F619}",
      "smiling_face_with_tear": "\u{1F972}",
      "yum": "\u{1F60B}",
      "stuck_out_tongue": "\u{1F61B}",
      "stuck_out_tongue_winking_eye": "\u{1F61C}",
      "zany_face": "\u{1F92A}",
      "stuck_out_tongue_closed_eyes": "\u{1F61D}",
      "money_mouth_face": "\u{1F911}",
      "hugs": "\u{1F917}",
      "hand_over_mouth": "\u{1F92D}",
      "face_with_open_eyes_and_hand_over_mouth": "\u{1FAE2}",
      "face_with_peeking_eye": "\u{1FAE3}",
      "shushing_face": "\u{1F92B}",
      "thinking": "\u{1F914}",
      "saluting_face": "\u{1FAE1}",
      "zipper_mouth_face": "\u{1F910}",
      "raised_eyebrow": "\u{1F928}",
      "neutral_face": "\u{1F610}",
      "expressionless": "\u{1F611}",
      "no_mouth": "\u{1F636}",
      "dotted_line_face": "\u{1FAE5}",
      "face_in_clouds": "\u{1F636}\u200D\u{1F32B}\uFE0F",
      "smirk": "\u{1F60F}",
      "unamused": "\u{1F612}",
      "roll_eyes": "\u{1F644}",
      "grimacing": "\u{1F62C}",
      "face_exhaling": "\u{1F62E}\u200D\u{1F4A8}",
      "lying_face": "\u{1F925}",
      "shaking_face": "\u{1FAE8}",
      "relieved": "\u{1F60C}",
      "pensive": "\u{1F614}",
      "sleepy": "\u{1F62A}",
      "drooling_face": "\u{1F924}",
      "sleeping": "\u{1F634}",
      "mask": "\u{1F637}",
      "face_with_thermometer": "\u{1F912}",
      "face_with_head_bandage": "\u{1F915}",
      "nauseated_face": "\u{1F922}",
      "vomiting_face": "\u{1F92E}",
      "sneezing_face": "\u{1F927}",
      "hot_face": "\u{1F975}",
      "cold_face": "\u{1F976}",
      "woozy_face": "\u{1F974}",
      "dizzy_face": "\u{1F635}",
      "face_with_spiral_eyes": "\u{1F635}\u200D\u{1F4AB}",
      "exploding_head": "\u{1F92F}",
      "cowboy_hat_face": "\u{1F920}",
      "partying_face": "\u{1F973}",
      "disguised_face": "\u{1F978}",
      "sunglasses": "\u{1F60E}",
      "nerd_face": "\u{1F913}",
      "monocle_face": "\u{1F9D0}",
      "confused": "\u{1F615}",
      "face_with_diagonal_mouth": "\u{1FAE4}",
      "worried": "\u{1F61F}",
      "slightly_frowning_face": "\u{1F641}",
      "frowning_face": "\u2639\uFE0F",
      "open_mouth": "\u{1F62E}",
      "hushed": "\u{1F62F}",
      "astonished": "\u{1F632}",
      "flushed": "\u{1F633}",
      "pleading_face": "\u{1F97A}",
      "face_holding_back_tears": "\u{1F979}",
      "frowning": "\u{1F626}",
      "anguished": "\u{1F627}",
      "fearful": "\u{1F628}",
      "cold_sweat": "\u{1F630}",
      "disappointed_relieved": "\u{1F625}",
      "cry": "\u{1F622}",
      "sob": "\u{1F62D}",
      "scream": "\u{1F631}",
      "confounded": "\u{1F616}",
      "persevere": "\u{1F623}",
      "disappointed": "\u{1F61E}",
      "sweat": "\u{1F613}",
      "weary": "\u{1F629}",
      "tired_face": "\u{1F62B}",
      "yawning_face": "\u{1F971}",
      "triumph": "\u{1F624}",
      "rage": "\u{1F621}",
      "pout": "\u{1F621}",
      "angry": "\u{1F620}",
      "cursing_face": "\u{1F92C}",
      "smiling_imp": "\u{1F608}",
      "imp": "\u{1F47F}",
      "skull": "\u{1F480}",
      "skull_and_crossbones": "\u2620\uFE0F",
      "hankey": "\u{1F4A9}",
      "poop": "\u{1F4A9}",
      "shit": "\u{1F4A9}",
      "clown_face": "\u{1F921}",
      "japanese_ogre": "\u{1F479}",
      "japanese_goblin": "\u{1F47A}",
      "ghost": "\u{1F47B}",
      "alien": "\u{1F47D}",
      "space_invader": "\u{1F47E}",
      "robot": "\u{1F916}",
      "smiley_cat": "\u{1F63A}",
      "smile_cat": "\u{1F638}",
      "joy_cat": "\u{1F639}",
      "heart_eyes_cat": "\u{1F63B}",
      "smirk_cat": "\u{1F63C}",
      "kissing_cat": "\u{1F63D}",
      "scream_cat": "\u{1F640}",
      "crying_cat_face": "\u{1F63F}",
      "pouting_cat": "\u{1F63E}",
      "see_no_evil": "\u{1F648}",
      "hear_no_evil": "\u{1F649}",
      "speak_no_evil": "\u{1F64A}",
      "love_letter": "\u{1F48C}",
      "cupid": "\u{1F498}",
      "gift_heart": "\u{1F49D}",
      "sparkling_heart": "\u{1F496}",
      "heartpulse": "\u{1F497}",
      "heartbeat": "\u{1F493}",
      "revolving_hearts": "\u{1F49E}",
      "two_hearts": "\u{1F495}",
      "heart_decoration": "\u{1F49F}",
      "heavy_heart_exclamation": "\u2763\uFE0F",
      "broken_heart": "\u{1F494}",
      "heart_on_fire": "\u2764\uFE0F\u200D\u{1F525}",
      "mending_heart": "\u2764\uFE0F\u200D\u{1FA79}",
      "heart": "\u2764\uFE0F",
      "pink_heart": "\u{1FA77}",
      "orange_heart": "\u{1F9E1}",
      "yellow_heart": "\u{1F49B}",
      "green_heart": "\u{1F49A}",
      "blue_heart": "\u{1F499}",
      "light_blue_heart": "\u{1FA75}",
      "purple_heart": "\u{1F49C}",
      "brown_heart": "\u{1F90E}",
      "black_heart": "\u{1F5A4}",
      "grey_heart": "\u{1FA76}",
      "white_heart": "\u{1F90D}",
      "kiss": "\u{1F48B}",
      "anger": "\u{1F4A2}",
      "boom": "\u{1F4A5}",
      "collision": "\u{1F4A5}",
      "dizzy": "\u{1F4AB}",
      "sweat_drops": "\u{1F4A6}",
      "dash": "\u{1F4A8}",
      "hole": "\u{1F573}\uFE0F",
      "speech_balloon": "\u{1F4AC}",
      "eye_speech_bubble": "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F",
      "left_speech_bubble": "\u{1F5E8}\uFE0F",
      "right_anger_bubble": "\u{1F5EF}\uFE0F",
      "thought_balloon": "\u{1F4AD}",
      "zzz": "\u{1F4A4}",
      "wave": "\u{1F44B}",
      "raised_back_of_hand": "\u{1F91A}",
      "raised_hand_with_fingers_splayed": "\u{1F590}\uFE0F",
      "hand": "\u270B",
      "raised_hand": "\u270B",
      "vulcan_salute": "\u{1F596}",
      "rightwards_hand": "\u{1FAF1}",
      "leftwards_hand": "\u{1FAF2}",
      "palm_down_hand": "\u{1FAF3}",
      "palm_up_hand": "\u{1FAF4}",
      "leftwards_pushing_hand": "\u{1FAF7}",
      "rightwards_pushing_hand": "\u{1FAF8}",
      "ok_hand": "\u{1F44C}",
      "pinched_fingers": "\u{1F90C}",
      "pinching_hand": "\u{1F90F}",
      "v": "\u270C\uFE0F",
      "crossed_fingers": "\u{1F91E}",
      "hand_with_index_finger_and_thumb_crossed": "\u{1FAF0}",
      "love_you_gesture": "\u{1F91F}",
      "metal": "\u{1F918}",
      "call_me_hand": "\u{1F919}",
      "point_left": "\u{1F448}",
      "point_right": "\u{1F449}",
      "point_up_2": "\u{1F446}",
      "middle_finger": "\u{1F595}",
      "fu": "\u{1F595}",
      "point_down": "\u{1F447}",
      "point_up": "\u261D\uFE0F",
      "index_pointing_at_the_viewer": "\u{1FAF5}",
      "+1": "\u{1F44D}",
      "thumbsup": "\u{1F44D}",
      "-1": "\u{1F44E}",
      "thumbsdown": "\u{1F44E}",
      "fist_raised": "\u270A",
      "fist": "\u270A",
      "fist_oncoming": "\u{1F44A}",
      "facepunch": "\u{1F44A}",
      "punch": "\u{1F44A}",
      "fist_left": "\u{1F91B}",
      "fist_right": "\u{1F91C}",
      "clap": "\u{1F44F}",
      "raised_hands": "\u{1F64C}",
      "heart_hands": "\u{1FAF6}",
      "open_hands": "\u{1F450}",
      "palms_up_together": "\u{1F932}",
      "handshake": "\u{1F91D}",
      "pray": "\u{1F64F}",
      "writing_hand": "\u270D\uFE0F",
      "nail_care": "\u{1F485}",
      "selfie": "\u{1F933}",
      "muscle": "\u{1F4AA}",
      "mechanical_arm": "\u{1F9BE}",
      "mechanical_leg": "\u{1F9BF}",
      "leg": "\u{1F9B5}",
      "foot": "\u{1F9B6}",
      "ear": "\u{1F442}",
      "ear_with_hearing_aid": "\u{1F9BB}",
      "nose": "\u{1F443}",
      "brain": "\u{1F9E0}",
      "anatomical_heart": "\u{1FAC0}",
      "lungs": "\u{1FAC1}",
      "tooth": "\u{1F9B7}",
      "bone": "\u{1F9B4}",
      "eyes": "\u{1F440}",
      "eye": "\u{1F441}\uFE0F",
      "tongue": "\u{1F445}",
      "lips": "\u{1F444}",
      "biting_lip": "\u{1FAE6}",
      "baby": "\u{1F476}",
      "child": "\u{1F9D2}",
      "boy": "\u{1F466}",
      "girl": "\u{1F467}",
      "adult": "\u{1F9D1}",
      "blond_haired_person": "\u{1F471}",
      "man": "\u{1F468}",
      "bearded_person": "\u{1F9D4}",
      "man_beard": "\u{1F9D4}\u200D\u2642\uFE0F",
      "woman_beard": "\u{1F9D4}\u200D\u2640\uFE0F",
      "red_haired_man": "\u{1F468}\u200D\u{1F9B0}",
      "curly_haired_man": "\u{1F468}\u200D\u{1F9B1}",
      "white_haired_man": "\u{1F468}\u200D\u{1F9B3}",
      "bald_man": "\u{1F468}\u200D\u{1F9B2}",
      "woman": "\u{1F469}",
      "red_haired_woman": "\u{1F469}\u200D\u{1F9B0}",
      "person_red_hair": "\u{1F9D1}\u200D\u{1F9B0}",
      "curly_haired_woman": "\u{1F469}\u200D\u{1F9B1}",
      "person_curly_hair": "\u{1F9D1}\u200D\u{1F9B1}",
      "white_haired_woman": "\u{1F469}\u200D\u{1F9B3}",
      "person_white_hair": "\u{1F9D1}\u200D\u{1F9B3}",
      "bald_woman": "\u{1F469}\u200D\u{1F9B2}",
      "person_bald": "\u{1F9D1}\u200D\u{1F9B2}",
      "blond_haired_woman": "\u{1F471}\u200D\u2640\uFE0F",
      "blonde_woman": "\u{1F471}\u200D\u2640\uFE0F",
      "blond_haired_man": "\u{1F471}\u200D\u2642\uFE0F",
      "older_adult": "\u{1F9D3}",
      "older_man": "\u{1F474}",
      "older_woman": "\u{1F475}",
      "frowning_person": "\u{1F64D}",
      "frowning_man": "\u{1F64D}\u200D\u2642\uFE0F",
      "frowning_woman": "\u{1F64D}\u200D\u2640\uFE0F",
      "pouting_face": "\u{1F64E}",
      "pouting_man": "\u{1F64E}\u200D\u2642\uFE0F",
      "pouting_woman": "\u{1F64E}\u200D\u2640\uFE0F",
      "no_good": "\u{1F645}",
      "no_good_man": "\u{1F645}\u200D\u2642\uFE0F",
      "ng_man": "\u{1F645}\u200D\u2642\uFE0F",
      "no_good_woman": "\u{1F645}\u200D\u2640\uFE0F",
      "ng_woman": "\u{1F645}\u200D\u2640\uFE0F",
      "ok_person": "\u{1F646}",
      "ok_man": "\u{1F646}\u200D\u2642\uFE0F",
      "ok_woman": "\u{1F646}\u200D\u2640\uFE0F",
      "tipping_hand_person": "\u{1F481}",
      "information_desk_person": "\u{1F481}",
      "tipping_hand_man": "\u{1F481}\u200D\u2642\uFE0F",
      "sassy_man": "\u{1F481}\u200D\u2642\uFE0F",
      "tipping_hand_woman": "\u{1F481}\u200D\u2640\uFE0F",
      "sassy_woman": "\u{1F481}\u200D\u2640\uFE0F",
      "raising_hand": "\u{1F64B}",
      "raising_hand_man": "\u{1F64B}\u200D\u2642\uFE0F",
      "raising_hand_woman": "\u{1F64B}\u200D\u2640\uFE0F",
      "deaf_person": "\u{1F9CF}",
      "deaf_man": "\u{1F9CF}\u200D\u2642\uFE0F",
      "deaf_woman": "\u{1F9CF}\u200D\u2640\uFE0F",
      "bow": "\u{1F647}",
      "bowing_man": "\u{1F647}\u200D\u2642\uFE0F",
      "bowing_woman": "\u{1F647}\u200D\u2640\uFE0F",
      "facepalm": "\u{1F926}",
      "man_facepalming": "\u{1F926}\u200D\u2642\uFE0F",
      "woman_facepalming": "\u{1F926}\u200D\u2640\uFE0F",
      "shrug": "\u{1F937}",
      "man_shrugging": "\u{1F937}\u200D\u2642\uFE0F",
      "woman_shrugging": "\u{1F937}\u200D\u2640\uFE0F",
      "health_worker": "\u{1F9D1}\u200D\u2695\uFE0F",
      "man_health_worker": "\u{1F468}\u200D\u2695\uFE0F",
      "woman_health_worker": "\u{1F469}\u200D\u2695\uFE0F",
      "student": "\u{1F9D1}\u200D\u{1F393}",
      "man_student": "\u{1F468}\u200D\u{1F393}",
      "woman_student": "\u{1F469}\u200D\u{1F393}",
      "teacher": "\u{1F9D1}\u200D\u{1F3EB}",
      "man_teacher": "\u{1F468}\u200D\u{1F3EB}",
      "woman_teacher": "\u{1F469}\u200D\u{1F3EB}",
      "judge": "\u{1F9D1}\u200D\u2696\uFE0F",
      "man_judge": "\u{1F468}\u200D\u2696\uFE0F",
      "woman_judge": "\u{1F469}\u200D\u2696\uFE0F",
      "farmer": "\u{1F9D1}\u200D\u{1F33E}",
      "man_farmer": "\u{1F468}\u200D\u{1F33E}",
      "woman_farmer": "\u{1F469}\u200D\u{1F33E}",
      "cook": "\u{1F9D1}\u200D\u{1F373}",
      "man_cook": "\u{1F468}\u200D\u{1F373}",
      "woman_cook": "\u{1F469}\u200D\u{1F373}",
      "mechanic": "\u{1F9D1}\u200D\u{1F527}",
      "man_mechanic": "\u{1F468}\u200D\u{1F527}",
      "woman_mechanic": "\u{1F469}\u200D\u{1F527}",
      "factory_worker": "\u{1F9D1}\u200D\u{1F3ED}",
      "man_factory_worker": "\u{1F468}\u200D\u{1F3ED}",
      "woman_factory_worker": "\u{1F469}\u200D\u{1F3ED}",
      "office_worker": "\u{1F9D1}\u200D\u{1F4BC}",
      "man_office_worker": "\u{1F468}\u200D\u{1F4BC}",
      "woman_office_worker": "\u{1F469}\u200D\u{1F4BC}",
      "scientist": "\u{1F9D1}\u200D\u{1F52C}",
      "man_scientist": "\u{1F468}\u200D\u{1F52C}",
      "woman_scientist": "\u{1F469}\u200D\u{1F52C}",
      "technologist": "\u{1F9D1}\u200D\u{1F4BB}",
      "man_technologist": "\u{1F468}\u200D\u{1F4BB}",
      "woman_technologist": "\u{1F469}\u200D\u{1F4BB}",
      "singer": "\u{1F9D1}\u200D\u{1F3A4}",
      "man_singer": "\u{1F468}\u200D\u{1F3A4}",
      "woman_singer": "\u{1F469}\u200D\u{1F3A4}",
      "artist": "\u{1F9D1}\u200D\u{1F3A8}",
      "man_artist": "\u{1F468}\u200D\u{1F3A8}",
      "woman_artist": "\u{1F469}\u200D\u{1F3A8}",
      "pilot": "\u{1F9D1}\u200D\u2708\uFE0F",
      "man_pilot": "\u{1F468}\u200D\u2708\uFE0F",
      "woman_pilot": "\u{1F469}\u200D\u2708\uFE0F",
      "astronaut": "\u{1F9D1}\u200D\u{1F680}",
      "man_astronaut": "\u{1F468}\u200D\u{1F680}",
      "woman_astronaut": "\u{1F469}\u200D\u{1F680}",
      "firefighter": "\u{1F9D1}\u200D\u{1F692}",
      "man_firefighter": "\u{1F468}\u200D\u{1F692}",
      "woman_firefighter": "\u{1F469}\u200D\u{1F692}",
      "police_officer": "\u{1F46E}",
      "cop": "\u{1F46E}",
      "policeman": "\u{1F46E}\u200D\u2642\uFE0F",
      "policewoman": "\u{1F46E}\u200D\u2640\uFE0F",
      "detective": "\u{1F575}\uFE0F",
      "male_detective": "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
      "female_detective": "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
      "guard": "\u{1F482}",
      "guardsman": "\u{1F482}\u200D\u2642\uFE0F",
      "guardswoman": "\u{1F482}\u200D\u2640\uFE0F",
      "ninja": "\u{1F977}",
      "construction_worker": "\u{1F477}",
      "construction_worker_man": "\u{1F477}\u200D\u2642\uFE0F",
      "construction_worker_woman": "\u{1F477}\u200D\u2640\uFE0F",
      "person_with_crown": "\u{1FAC5}",
      "prince": "\u{1F934}",
      "princess": "\u{1F478}",
      "person_with_turban": "\u{1F473}",
      "man_with_turban": "\u{1F473}\u200D\u2642\uFE0F",
      "woman_with_turban": "\u{1F473}\u200D\u2640\uFE0F",
      "man_with_gua_pi_mao": "\u{1F472}",
      "woman_with_headscarf": "\u{1F9D5}",
      "person_in_tuxedo": "\u{1F935}",
      "man_in_tuxedo": "\u{1F935}\u200D\u2642\uFE0F",
      "woman_in_tuxedo": "\u{1F935}\u200D\u2640\uFE0F",
      "person_with_veil": "\u{1F470}",
      "man_with_veil": "\u{1F470}\u200D\u2642\uFE0F",
      "woman_with_veil": "\u{1F470}\u200D\u2640\uFE0F",
      "bride_with_veil": "\u{1F470}\u200D\u2640\uFE0F",
      "pregnant_woman": "\u{1F930}",
      "pregnant_man": "\u{1FAC3}",
      "pregnant_person": "\u{1FAC4}",
      "breast_feeding": "\u{1F931}",
      "woman_feeding_baby": "\u{1F469}\u200D\u{1F37C}",
      "man_feeding_baby": "\u{1F468}\u200D\u{1F37C}",
      "person_feeding_baby": "\u{1F9D1}\u200D\u{1F37C}",
      "angel": "\u{1F47C}",
      "santa": "\u{1F385}",
      "mrs_claus": "\u{1F936}",
      "mx_claus": "\u{1F9D1}\u200D\u{1F384}",
      "superhero": "\u{1F9B8}",
      "superhero_man": "\u{1F9B8}\u200D\u2642\uFE0F",
      "superhero_woman": "\u{1F9B8}\u200D\u2640\uFE0F",
      "supervillain": "\u{1F9B9}",
      "supervillain_man": "\u{1F9B9}\u200D\u2642\uFE0F",
      "supervillain_woman": "\u{1F9B9}\u200D\u2640\uFE0F",
      "mage": "\u{1F9D9}",
      "mage_man": "\u{1F9D9}\u200D\u2642\uFE0F",
      "mage_woman": "\u{1F9D9}\u200D\u2640\uFE0F",
      "fairy": "\u{1F9DA}",
      "fairy_man": "\u{1F9DA}\u200D\u2642\uFE0F",
      "fairy_woman": "\u{1F9DA}\u200D\u2640\uFE0F",
      "vampire": "\u{1F9DB}",
      "vampire_man": "\u{1F9DB}\u200D\u2642\uFE0F",
      "vampire_woman": "\u{1F9DB}\u200D\u2640\uFE0F",
      "merperson": "\u{1F9DC}",
      "merman": "\u{1F9DC}\u200D\u2642\uFE0F",
      "mermaid": "\u{1F9DC}\u200D\u2640\uFE0F",
      "elf": "\u{1F9DD}",
      "elf_man": "\u{1F9DD}\u200D\u2642\uFE0F",
      "elf_woman": "\u{1F9DD}\u200D\u2640\uFE0F",
      "genie": "\u{1F9DE}",
      "genie_man": "\u{1F9DE}\u200D\u2642\uFE0F",
      "genie_woman": "\u{1F9DE}\u200D\u2640\uFE0F",
      "zombie": "\u{1F9DF}",
      "zombie_man": "\u{1F9DF}\u200D\u2642\uFE0F",
      "zombie_woman": "\u{1F9DF}\u200D\u2640\uFE0F",
      "troll": "\u{1F9CC}",
      "massage": "\u{1F486}",
      "massage_man": "\u{1F486}\u200D\u2642\uFE0F",
      "massage_woman": "\u{1F486}\u200D\u2640\uFE0F",
      "haircut": "\u{1F487}",
      "haircut_man": "\u{1F487}\u200D\u2642\uFE0F",
      "haircut_woman": "\u{1F487}\u200D\u2640\uFE0F",
      "walking": "\u{1F6B6}",
      "walking_man": "\u{1F6B6}\u200D\u2642\uFE0F",
      "walking_woman": "\u{1F6B6}\u200D\u2640\uFE0F",
      "standing_person": "\u{1F9CD}",
      "standing_man": "\u{1F9CD}\u200D\u2642\uFE0F",
      "standing_woman": "\u{1F9CD}\u200D\u2640\uFE0F",
      "kneeling_person": "\u{1F9CE}",
      "kneeling_man": "\u{1F9CE}\u200D\u2642\uFE0F",
      "kneeling_woman": "\u{1F9CE}\u200D\u2640\uFE0F",
      "person_with_probing_cane": "\u{1F9D1}\u200D\u{1F9AF}",
      "man_with_probing_cane": "\u{1F468}\u200D\u{1F9AF}",
      "woman_with_probing_cane": "\u{1F469}\u200D\u{1F9AF}",
      "person_in_motorized_wheelchair": "\u{1F9D1}\u200D\u{1F9BC}",
      "man_in_motorized_wheelchair": "\u{1F468}\u200D\u{1F9BC}",
      "woman_in_motorized_wheelchair": "\u{1F469}\u200D\u{1F9BC}",
      "person_in_manual_wheelchair": "\u{1F9D1}\u200D\u{1F9BD}",
      "man_in_manual_wheelchair": "\u{1F468}\u200D\u{1F9BD}",
      "woman_in_manual_wheelchair": "\u{1F469}\u200D\u{1F9BD}",
      "runner": "\u{1F3C3}",
      "running": "\u{1F3C3}",
      "running_man": "\u{1F3C3}\u200D\u2642\uFE0F",
      "running_woman": "\u{1F3C3}\u200D\u2640\uFE0F",
      "woman_dancing": "\u{1F483}",
      "dancer": "\u{1F483}",
      "man_dancing": "\u{1F57A}",
      "business_suit_levitating": "\u{1F574}\uFE0F",
      "dancers": "\u{1F46F}",
      "dancing_men": "\u{1F46F}\u200D\u2642\uFE0F",
      "dancing_women": "\u{1F46F}\u200D\u2640\uFE0F",
      "sauna_person": "\u{1F9D6}",
      "sauna_man": "\u{1F9D6}\u200D\u2642\uFE0F",
      "sauna_woman": "\u{1F9D6}\u200D\u2640\uFE0F",
      "climbing": "\u{1F9D7}",
      "climbing_man": "\u{1F9D7}\u200D\u2642\uFE0F",
      "climbing_woman": "\u{1F9D7}\u200D\u2640\uFE0F",
      "person_fencing": "\u{1F93A}",
      "horse_racing": "\u{1F3C7}",
      "skier": "\u26F7\uFE0F",
      "snowboarder": "\u{1F3C2}",
      "golfing": "\u{1F3CC}\uFE0F",
      "golfing_man": "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
      "golfing_woman": "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
      "surfer": "\u{1F3C4}",
      "surfing_man": "\u{1F3C4}\u200D\u2642\uFE0F",
      "surfing_woman": "\u{1F3C4}\u200D\u2640\uFE0F",
      "rowboat": "\u{1F6A3}",
      "rowing_man": "\u{1F6A3}\u200D\u2642\uFE0F",
      "rowing_woman": "\u{1F6A3}\u200D\u2640\uFE0F",
      "swimmer": "\u{1F3CA}",
      "swimming_man": "\u{1F3CA}\u200D\u2642\uFE0F",
      "swimming_woman": "\u{1F3CA}\u200D\u2640\uFE0F",
      "bouncing_ball_person": "\u26F9\uFE0F",
      "bouncing_ball_man": "\u26F9\uFE0F\u200D\u2642\uFE0F",
      "basketball_man": "\u26F9\uFE0F\u200D\u2642\uFE0F",
      "bouncing_ball_woman": "\u26F9\uFE0F\u200D\u2640\uFE0F",
      "basketball_woman": "\u26F9\uFE0F\u200D\u2640\uFE0F",
      "weight_lifting": "\u{1F3CB}\uFE0F",
      "weight_lifting_man": "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
      "weight_lifting_woman": "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
      "bicyclist": "\u{1F6B4}",
      "biking_man": "\u{1F6B4}\u200D\u2642\uFE0F",
      "biking_woman": "\u{1F6B4}\u200D\u2640\uFE0F",
      "mountain_bicyclist": "\u{1F6B5}",
      "mountain_biking_man": "\u{1F6B5}\u200D\u2642\uFE0F",
      "mountain_biking_woman": "\u{1F6B5}\u200D\u2640\uFE0F",
      "cartwheeling": "\u{1F938}",
      "man_cartwheeling": "\u{1F938}\u200D\u2642\uFE0F",
      "woman_cartwheeling": "\u{1F938}\u200D\u2640\uFE0F",
      "wrestling": "\u{1F93C}",
      "men_wrestling": "\u{1F93C}\u200D\u2642\uFE0F",
      "women_wrestling": "\u{1F93C}\u200D\u2640\uFE0F",
      "water_polo": "\u{1F93D}",
      "man_playing_water_polo": "\u{1F93D}\u200D\u2642\uFE0F",
      "woman_playing_water_polo": "\u{1F93D}\u200D\u2640\uFE0F",
      "handball_person": "\u{1F93E}",
      "man_playing_handball": "\u{1F93E}\u200D\u2642\uFE0F",
      "woman_playing_handball": "\u{1F93E}\u200D\u2640\uFE0F",
      "juggling_person": "\u{1F939}",
      "man_juggling": "\u{1F939}\u200D\u2642\uFE0F",
      "woman_juggling": "\u{1F939}\u200D\u2640\uFE0F",
      "lotus_position": "\u{1F9D8}",
      "lotus_position_man": "\u{1F9D8}\u200D\u2642\uFE0F",
      "lotus_position_woman": "\u{1F9D8}\u200D\u2640\uFE0F",
      "bath": "\u{1F6C0}",
      "sleeping_bed": "\u{1F6CC}",
      "people_holding_hands": "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}",
      "two_women_holding_hands": "\u{1F46D}",
      "couple": "\u{1F46B}",
      "two_men_holding_hands": "\u{1F46C}",
      "couplekiss": "\u{1F48F}",
      "couplekiss_man_woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "couplekiss_man_man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "couplekiss_woman_woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
      "couple_with_heart": "\u{1F491}",
      "couple_with_heart_woman_man": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "couple_with_heart_man_man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "couple_with_heart_woman_woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
      "family": "\u{1F46A}",
      "family_man_woman_boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
      "family_man_woman_girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
      "family_man_woman_girl_boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "family_man_woman_boy_boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "family_man_woman_girl_girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "family_man_man_boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
      "family_man_man_girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
      "family_man_man_girl_boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "family_man_man_boy_boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "family_man_man_girl_girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "family_woman_woman_boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
      "family_woman_woman_girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
      "family_woman_woman_girl_boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "family_woman_woman_boy_boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "family_woman_woman_girl_girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "family_man_boy": "\u{1F468}\u200D\u{1F466}",
      "family_man_boy_boy": "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "family_man_girl": "\u{1F468}\u200D\u{1F467}",
      "family_man_girl_boy": "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "family_man_girl_girl": "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "family_woman_boy": "\u{1F469}\u200D\u{1F466}",
      "family_woman_boy_boy": "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "family_woman_girl": "\u{1F469}\u200D\u{1F467}",
      "family_woman_girl_boy": "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "family_woman_girl_girl": "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "speaking_head": "\u{1F5E3}\uFE0F",
      "bust_in_silhouette": "\u{1F464}",
      "busts_in_silhouette": "\u{1F465}",
      "people_hugging": "\u{1FAC2}",
      "footprints": "\u{1F463}",
      "monkey_face": "\u{1F435}",
      "monkey": "\u{1F412}",
      "gorilla": "\u{1F98D}",
      "orangutan": "\u{1F9A7}",
      "dog": "\u{1F436}",
      "dog2": "\u{1F415}",
      "guide_dog": "\u{1F9AE}",
      "service_dog": "\u{1F415}\u200D\u{1F9BA}",
      "poodle": "\u{1F429}",
      "wolf": "\u{1F43A}",
      "fox_face": "\u{1F98A}",
      "raccoon": "\u{1F99D}",
      "cat": "\u{1F431}",
      "cat2": "\u{1F408}",
      "black_cat": "\u{1F408}\u200D\u2B1B",
      "lion": "\u{1F981}",
      "tiger": "\u{1F42F}",
      "tiger2": "\u{1F405}",
      "leopard": "\u{1F406}",
      "horse": "\u{1F434}",
      "moose": "\u{1FACE}",
      "donkey": "\u{1FACF}",
      "racehorse": "\u{1F40E}",
      "unicorn": "\u{1F984}",
      "zebra": "\u{1F993}",
      "deer": "\u{1F98C}",
      "bison": "\u{1F9AC}",
      "cow": "\u{1F42E}",
      "ox": "\u{1F402}",
      "water_buffalo": "\u{1F403}",
      "cow2": "\u{1F404}",
      "pig": "\u{1F437}",
      "pig2": "\u{1F416}",
      "boar": "\u{1F417}",
      "pig_nose": "\u{1F43D}",
      "ram": "\u{1F40F}",
      "sheep": "\u{1F411}",
      "goat": "\u{1F410}",
      "dromedary_camel": "\u{1F42A}",
      "camel": "\u{1F42B}",
      "llama": "\u{1F999}",
      "giraffe": "\u{1F992}",
      "elephant": "\u{1F418}",
      "mammoth": "\u{1F9A3}",
      "rhinoceros": "\u{1F98F}",
      "hippopotamus": "\u{1F99B}",
      "mouse": "\u{1F42D}",
      "mouse2": "\u{1F401}",
      "rat": "\u{1F400}",
      "hamster": "\u{1F439}",
      "rabbit": "\u{1F430}",
      "rabbit2": "\u{1F407}",
      "chipmunk": "\u{1F43F}\uFE0F",
      "beaver": "\u{1F9AB}",
      "hedgehog": "\u{1F994}",
      "bat": "\u{1F987}",
      "bear": "\u{1F43B}",
      "polar_bear": "\u{1F43B}\u200D\u2744\uFE0F",
      "koala": "\u{1F428}",
      "panda_face": "\u{1F43C}",
      "sloth": "\u{1F9A5}",
      "otter": "\u{1F9A6}",
      "skunk": "\u{1F9A8}",
      "kangaroo": "\u{1F998}",
      "badger": "\u{1F9A1}",
      "feet": "\u{1F43E}",
      "paw_prints": "\u{1F43E}",
      "turkey": "\u{1F983}",
      "chicken": "\u{1F414}",
      "rooster": "\u{1F413}",
      "hatching_chick": "\u{1F423}",
      "baby_chick": "\u{1F424}",
      "hatched_chick": "\u{1F425}",
      "bird": "\u{1F426}",
      "penguin": "\u{1F427}",
      "dove": "\u{1F54A}\uFE0F",
      "eagle": "\u{1F985}",
      "duck": "\u{1F986}",
      "swan": "\u{1F9A2}",
      "owl": "\u{1F989}",
      "dodo": "\u{1F9A4}",
      "feather": "\u{1FAB6}",
      "flamingo": "\u{1F9A9}",
      "peacock": "\u{1F99A}",
      "parrot": "\u{1F99C}",
      "wing": "\u{1FABD}",
      "black_bird": "\u{1F426}\u200D\u2B1B",
      "goose": "\u{1FABF}",
      "frog": "\u{1F438}",
      "crocodile": "\u{1F40A}",
      "turtle": "\u{1F422}",
      "lizard": "\u{1F98E}",
      "snake": "\u{1F40D}",
      "dragon_face": "\u{1F432}",
      "dragon": "\u{1F409}",
      "sauropod": "\u{1F995}",
      "t-rex": "\u{1F996}",
      "whale": "\u{1F433}",
      "whale2": "\u{1F40B}",
      "dolphin": "\u{1F42C}",
      "flipper": "\u{1F42C}",
      "seal": "\u{1F9AD}",
      "fish": "\u{1F41F}",
      "tropical_fish": "\u{1F420}",
      "blowfish": "\u{1F421}",
      "shark": "\u{1F988}",
      "octopus": "\u{1F419}",
      "shell": "\u{1F41A}",
      "coral": "\u{1FAB8}",
      "jellyfish": "\u{1FABC}",
      "snail": "\u{1F40C}",
      "butterfly": "\u{1F98B}",
      "bug": "\u{1F41B}",
      "ant": "\u{1F41C}",
      "bee": "\u{1F41D}",
      "honeybee": "\u{1F41D}",
      "beetle": "\u{1FAB2}",
      "lady_beetle": "\u{1F41E}",
      "cricket": "\u{1F997}",
      "cockroach": "\u{1FAB3}",
      "spider": "\u{1F577}\uFE0F",
      "spider_web": "\u{1F578}\uFE0F",
      "scorpion": "\u{1F982}",
      "mosquito": "\u{1F99F}",
      "fly": "\u{1FAB0}",
      "worm": "\u{1FAB1}",
      "microbe": "\u{1F9A0}",
      "bouquet": "\u{1F490}",
      "cherry_blossom": "\u{1F338}",
      "white_flower": "\u{1F4AE}",
      "lotus": "\u{1FAB7}",
      "rosette": "\u{1F3F5}\uFE0F",
      "rose": "\u{1F339}",
      "wilted_flower": "\u{1F940}",
      "hibiscus": "\u{1F33A}",
      "sunflower": "\u{1F33B}",
      "blossom": "\u{1F33C}",
      "tulip": "\u{1F337}",
      "hyacinth": "\u{1FABB}",
      "seedling": "\u{1F331}",
      "potted_plant": "\u{1FAB4}",
      "evergreen_tree": "\u{1F332}",
      "deciduous_tree": "\u{1F333}",
      "palm_tree": "\u{1F334}",
      "cactus": "\u{1F335}",
      "ear_of_rice": "\u{1F33E}",
      "herb": "\u{1F33F}",
      "shamrock": "\u2618\uFE0F",
      "four_leaf_clover": "\u{1F340}",
      "maple_leaf": "\u{1F341}",
      "fallen_leaf": "\u{1F342}",
      "leaves": "\u{1F343}",
      "empty_nest": "\u{1FAB9}",
      "nest_with_eggs": "\u{1FABA}",
      "mushroom": "\u{1F344}",
      "grapes": "\u{1F347}",
      "melon": "\u{1F348}",
      "watermelon": "\u{1F349}",
      "tangerine": "\u{1F34A}",
      "orange": "\u{1F34A}",
      "mandarin": "\u{1F34A}",
      "lemon": "\u{1F34B}",
      "banana": "\u{1F34C}",
      "pineapple": "\u{1F34D}",
      "mango": "\u{1F96D}",
      "apple": "\u{1F34E}",
      "green_apple": "\u{1F34F}",
      "pear": "\u{1F350}",
      "peach": "\u{1F351}",
      "cherries": "\u{1F352}",
      "strawberry": "\u{1F353}",
      "blueberries": "\u{1FAD0}",
      "kiwi_fruit": "\u{1F95D}",
      "tomato": "\u{1F345}",
      "olive": "\u{1FAD2}",
      "coconut": "\u{1F965}",
      "avocado": "\u{1F951}",
      "eggplant": "\u{1F346}",
      "potato": "\u{1F954}",
      "carrot": "\u{1F955}",
      "corn": "\u{1F33D}",
      "hot_pepper": "\u{1F336}\uFE0F",
      "bell_pepper": "\u{1FAD1}",
      "cucumber": "\u{1F952}",
      "leafy_green": "\u{1F96C}",
      "broccoli": "\u{1F966}",
      "garlic": "\u{1F9C4}",
      "onion": "\u{1F9C5}",
      "peanuts": "\u{1F95C}",
      "beans": "\u{1FAD8}",
      "chestnut": "\u{1F330}",
      "ginger_root": "\u{1FADA}",
      "pea_pod": "\u{1FADB}",
      "bread": "\u{1F35E}",
      "croissant": "\u{1F950}",
      "baguette_bread": "\u{1F956}",
      "flatbread": "\u{1FAD3}",
      "pretzel": "\u{1F968}",
      "bagel": "\u{1F96F}",
      "pancakes": "\u{1F95E}",
      "waffle": "\u{1F9C7}",
      "cheese": "\u{1F9C0}",
      "meat_on_bone": "\u{1F356}",
      "poultry_leg": "\u{1F357}",
      "cut_of_meat": "\u{1F969}",
      "bacon": "\u{1F953}",
      "hamburger": "\u{1F354}",
      "fries": "\u{1F35F}",
      "pizza": "\u{1F355}",
      "hotdog": "\u{1F32D}",
      "sandwich": "\u{1F96A}",
      "taco": "\u{1F32E}",
      "burrito": "\u{1F32F}",
      "tamale": "\u{1FAD4}",
      "stuffed_flatbread": "\u{1F959}",
      "falafel": "\u{1F9C6}",
      "egg": "\u{1F95A}",
      "fried_egg": "\u{1F373}",
      "shallow_pan_of_food": "\u{1F958}",
      "stew": "\u{1F372}",
      "fondue": "\u{1FAD5}",
      "bowl_with_spoon": "\u{1F963}",
      "green_salad": "\u{1F957}",
      "popcorn": "\u{1F37F}",
      "butter": "\u{1F9C8}",
      "salt": "\u{1F9C2}",
      "canned_food": "\u{1F96B}",
      "bento": "\u{1F371}",
      "rice_cracker": "\u{1F358}",
      "rice_ball": "\u{1F359}",
      "rice": "\u{1F35A}",
      "curry": "\u{1F35B}",
      "ramen": "\u{1F35C}",
      "spaghetti": "\u{1F35D}",
      "sweet_potato": "\u{1F360}",
      "oden": "\u{1F362}",
      "sushi": "\u{1F363}",
      "fried_shrimp": "\u{1F364}",
      "fish_cake": "\u{1F365}",
      "moon_cake": "\u{1F96E}",
      "dango": "\u{1F361}",
      "dumpling": "\u{1F95F}",
      "fortune_cookie": "\u{1F960}",
      "takeout_box": "\u{1F961}",
      "crab": "\u{1F980}",
      "lobster": "\u{1F99E}",
      "shrimp": "\u{1F990}",
      "squid": "\u{1F991}",
      "oyster": "\u{1F9AA}",
      "icecream": "\u{1F366}",
      "shaved_ice": "\u{1F367}",
      "ice_cream": "\u{1F368}",
      "doughnut": "\u{1F369}",
      "cookie": "\u{1F36A}",
      "birthday": "\u{1F382}",
      "cake": "\u{1F370}",
      "cupcake": "\u{1F9C1}",
      "pie": "\u{1F967}",
      "chocolate_bar": "\u{1F36B}",
      "candy": "\u{1F36C}",
      "lollipop": "\u{1F36D}",
      "custard": "\u{1F36E}",
      "honey_pot": "\u{1F36F}",
      "baby_bottle": "\u{1F37C}",
      "milk_glass": "\u{1F95B}",
      "coffee": "\u2615",
      "teapot": "\u{1FAD6}",
      "tea": "\u{1F375}",
      "sake": "\u{1F376}",
      "champagne": "\u{1F37E}",
      "wine_glass": "\u{1F377}",
      "cocktail": "\u{1F378}",
      "tropical_drink": "\u{1F379}",
      "beer": "\u{1F37A}",
      "beers": "\u{1F37B}",
      "clinking_glasses": "\u{1F942}",
      "tumbler_glass": "\u{1F943}",
      "pouring_liquid": "\u{1FAD7}",
      "cup_with_straw": "\u{1F964}",
      "bubble_tea": "\u{1F9CB}",
      "beverage_box": "\u{1F9C3}",
      "mate": "\u{1F9C9}",
      "ice_cube": "\u{1F9CA}",
      "chopsticks": "\u{1F962}",
      "plate_with_cutlery": "\u{1F37D}\uFE0F",
      "fork_and_knife": "\u{1F374}",
      "spoon": "\u{1F944}",
      "hocho": "\u{1F52A}",
      "knife": "\u{1F52A}",
      "jar": "\u{1FAD9}",
      "amphora": "\u{1F3FA}",
      "earth_africa": "\u{1F30D}",
      "earth_americas": "\u{1F30E}",
      "earth_asia": "\u{1F30F}",
      "globe_with_meridians": "\u{1F310}",
      "world_map": "\u{1F5FA}\uFE0F",
      "japan": "\u{1F5FE}",
      "compass": "\u{1F9ED}",
      "mountain_snow": "\u{1F3D4}\uFE0F",
      "mountain": "\u26F0\uFE0F",
      "volcano": "\u{1F30B}",
      "mount_fuji": "\u{1F5FB}",
      "camping": "\u{1F3D5}\uFE0F",
      "beach_umbrella": "\u{1F3D6}\uFE0F",
      "desert": "\u{1F3DC}\uFE0F",
      "desert_island": "\u{1F3DD}\uFE0F",
      "national_park": "\u{1F3DE}\uFE0F",
      "stadium": "\u{1F3DF}\uFE0F",
      "classical_building": "\u{1F3DB}\uFE0F",
      "building_construction": "\u{1F3D7}\uFE0F",
      "bricks": "\u{1F9F1}",
      "rock": "\u{1FAA8}",
      "wood": "\u{1FAB5}",
      "hut": "\u{1F6D6}",
      "houses": "\u{1F3D8}\uFE0F",
      "derelict_house": "\u{1F3DA}\uFE0F",
      "house": "\u{1F3E0}",
      "house_with_garden": "\u{1F3E1}",
      "office": "\u{1F3E2}",
      "post_office": "\u{1F3E3}",
      "european_post_office": "\u{1F3E4}",
      "hospital": "\u{1F3E5}",
      "bank": "\u{1F3E6}",
      "hotel": "\u{1F3E8}",
      "love_hotel": "\u{1F3E9}",
      "convenience_store": "\u{1F3EA}",
      "school": "\u{1F3EB}",
      "department_store": "\u{1F3EC}",
      "factory": "\u{1F3ED}",
      "japanese_castle": "\u{1F3EF}",
      "european_castle": "\u{1F3F0}",
      "wedding": "\u{1F492}",
      "tokyo_tower": "\u{1F5FC}",
      "statue_of_liberty": "\u{1F5FD}",
      "church": "\u26EA",
      "mosque": "\u{1F54C}",
      "hindu_temple": "\u{1F6D5}",
      "synagogue": "\u{1F54D}",
      "shinto_shrine": "\u26E9\uFE0F",
      "kaaba": "\u{1F54B}",
      "fountain": "\u26F2",
      "tent": "\u26FA",
      "foggy": "\u{1F301}",
      "night_with_stars": "\u{1F303}",
      "cityscape": "\u{1F3D9}\uFE0F",
      "sunrise_over_mountains": "\u{1F304}",
      "sunrise": "\u{1F305}",
      "city_sunset": "\u{1F306}",
      "city_sunrise": "\u{1F307}",
      "bridge_at_night": "\u{1F309}",
      "hotsprings": "\u2668\uFE0F",
      "carousel_horse": "\u{1F3A0}",
      "playground_slide": "\u{1F6DD}",
      "ferris_wheel": "\u{1F3A1}",
      "roller_coaster": "\u{1F3A2}",
      "barber": "\u{1F488}",
      "circus_tent": "\u{1F3AA}",
      "steam_locomotive": "\u{1F682}",
      "railway_car": "\u{1F683}",
      "bullettrain_side": "\u{1F684}",
      "bullettrain_front": "\u{1F685}",
      "train2": "\u{1F686}",
      "metro": "\u{1F687}",
      "light_rail": "\u{1F688}",
      "station": "\u{1F689}",
      "tram": "\u{1F68A}",
      "monorail": "\u{1F69D}",
      "mountain_railway": "\u{1F69E}",
      "train": "\u{1F68B}",
      "bus": "\u{1F68C}",
      "oncoming_bus": "\u{1F68D}",
      "trolleybus": "\u{1F68E}",
      "minibus": "\u{1F690}",
      "ambulance": "\u{1F691}",
      "fire_engine": "\u{1F692}",
      "police_car": "\u{1F693}",
      "oncoming_police_car": "\u{1F694}",
      "taxi": "\u{1F695}",
      "oncoming_taxi": "\u{1F696}",
      "car": "\u{1F697}",
      "red_car": "\u{1F697}",
      "oncoming_automobile": "\u{1F698}",
      "blue_car": "\u{1F699}",
      "pickup_truck": "\u{1F6FB}",
      "truck": "\u{1F69A}",
      "articulated_lorry": "\u{1F69B}",
      "tractor": "\u{1F69C}",
      "racing_car": "\u{1F3CE}\uFE0F",
      "motorcycle": "\u{1F3CD}\uFE0F",
      "motor_scooter": "\u{1F6F5}",
      "manual_wheelchair": "\u{1F9BD}",
      "motorized_wheelchair": "\u{1F9BC}",
      "auto_rickshaw": "\u{1F6FA}",
      "bike": "\u{1F6B2}",
      "kick_scooter": "\u{1F6F4}",
      "skateboard": "\u{1F6F9}",
      "roller_skate": "\u{1F6FC}",
      "busstop": "\u{1F68F}",
      "motorway": "\u{1F6E3}\uFE0F",
      "railway_track": "\u{1F6E4}\uFE0F",
      "oil_drum": "\u{1F6E2}\uFE0F",
      "fuelpump": "\u26FD",
      "wheel": "\u{1F6DE}",
      "rotating_light": "\u{1F6A8}",
      "traffic_light": "\u{1F6A5}",
      "vertical_traffic_light": "\u{1F6A6}",
      "stop_sign": "\u{1F6D1}",
      "construction": "\u{1F6A7}",
      "anchor": "\u2693",
      "ring_buoy": "\u{1F6DF}",
      "boat": "\u26F5",
      "sailboat": "\u26F5",
      "canoe": "\u{1F6F6}",
      "speedboat": "\u{1F6A4}",
      "passenger_ship": "\u{1F6F3}\uFE0F",
      "ferry": "\u26F4\uFE0F",
      "motor_boat": "\u{1F6E5}\uFE0F",
      "ship": "\u{1F6A2}",
      "airplane": "\u2708\uFE0F",
      "small_airplane": "\u{1F6E9}\uFE0F",
      "flight_departure": "\u{1F6EB}",
      "flight_arrival": "\u{1F6EC}",
      "parachute": "\u{1FA82}",
      "seat": "\u{1F4BA}",
      "helicopter": "\u{1F681}",
      "suspension_railway": "\u{1F69F}",
      "mountain_cableway": "\u{1F6A0}",
      "aerial_tramway": "\u{1F6A1}",
      "artificial_satellite": "\u{1F6F0}\uFE0F",
      "rocket": "\u{1F680}",
      "flying_saucer": "\u{1F6F8}",
      "bellhop_bell": "\u{1F6CE}\uFE0F",
      "luggage": "\u{1F9F3}",
      "hourglass": "\u231B",
      "hourglass_flowing_sand": "\u23F3",
      "watch": "\u231A",
      "alarm_clock": "\u23F0",
      "stopwatch": "\u23F1\uFE0F",
      "timer_clock": "\u23F2\uFE0F",
      "mantelpiece_clock": "\u{1F570}\uFE0F",
      "clock12": "\u{1F55B}",
      "clock1230": "\u{1F567}",
      "clock1": "\u{1F550}",
      "clock130": "\u{1F55C}",
      "clock2": "\u{1F551}",
      "clock230": "\u{1F55D}",
      "clock3": "\u{1F552}",
      "clock330": "\u{1F55E}",
      "clock4": "\u{1F553}",
      "clock430": "\u{1F55F}",
      "clock5": "\u{1F554}",
      "clock530": "\u{1F560}",
      "clock6": "\u{1F555}",
      "clock630": "\u{1F561}",
      "clock7": "\u{1F556}",
      "clock730": "\u{1F562}",
      "clock8": "\u{1F557}",
      "clock830": "\u{1F563}",
      "clock9": "\u{1F558}",
      "clock930": "\u{1F564}",
      "clock10": "\u{1F559}",
      "clock1030": "\u{1F565}",
      "clock11": "\u{1F55A}",
      "clock1130": "\u{1F566}",
      "new_moon": "\u{1F311}",
      "waxing_crescent_moon": "\u{1F312}",
      "first_quarter_moon": "\u{1F313}",
      "moon": "\u{1F314}",
      "waxing_gibbous_moon": "\u{1F314}",
      "full_moon": "\u{1F315}",
      "waning_gibbous_moon": "\u{1F316}",
      "last_quarter_moon": "\u{1F317}",
      "waning_crescent_moon": "\u{1F318}",
      "crescent_moon": "\u{1F319}",
      "new_moon_with_face": "\u{1F31A}",
      "first_quarter_moon_with_face": "\u{1F31B}",
      "last_quarter_moon_with_face": "\u{1F31C}",
      "thermometer": "\u{1F321}\uFE0F",
      "sunny": "\u2600\uFE0F",
      "full_moon_with_face": "\u{1F31D}",
      "sun_with_face": "\u{1F31E}",
      "ringed_planet": "\u{1FA90}",
      "star": "\u2B50",
      "star2": "\u{1F31F}",
      "stars": "\u{1F320}",
      "milky_way": "\u{1F30C}",
      "cloud": "\u2601\uFE0F",
      "partly_sunny": "\u26C5",
      "cloud_with_lightning_and_rain": "\u26C8\uFE0F",
      "sun_behind_small_cloud": "\u{1F324}\uFE0F",
      "sun_behind_large_cloud": "\u{1F325}\uFE0F",
      "sun_behind_rain_cloud": "\u{1F326}\uFE0F",
      "cloud_with_rain": "\u{1F327}\uFE0F",
      "cloud_with_snow": "\u{1F328}\uFE0F",
      "cloud_with_lightning": "\u{1F329}\uFE0F",
      "tornado": "\u{1F32A}\uFE0F",
      "fog": "\u{1F32B}\uFE0F",
      "wind_face": "\u{1F32C}\uFE0F",
      "cyclone": "\u{1F300}",
      "rainbow": "\u{1F308}",
      "closed_umbrella": "\u{1F302}",
      "open_umbrella": "\u2602\uFE0F",
      "umbrella": "\u2614",
      "parasol_on_ground": "\u26F1\uFE0F",
      "zap": "\u26A1",
      "snowflake": "\u2744\uFE0F",
      "snowman_with_snow": "\u2603\uFE0F",
      "snowman": "\u26C4",
      "comet": "\u2604\uFE0F",
      "fire": "\u{1F525}",
      "droplet": "\u{1F4A7}",
      "ocean": "\u{1F30A}",
      "jack_o_lantern": "\u{1F383}",
      "christmas_tree": "\u{1F384}",
      "fireworks": "\u{1F386}",
      "sparkler": "\u{1F387}",
      "firecracker": "\u{1F9E8}",
      "sparkles": "\u2728",
      "balloon": "\u{1F388}",
      "tada": "\u{1F389}",
      "confetti_ball": "\u{1F38A}",
      "tanabata_tree": "\u{1F38B}",
      "bamboo": "\u{1F38D}",
      "dolls": "\u{1F38E}",
      "flags": "\u{1F38F}",
      "wind_chime": "\u{1F390}",
      "rice_scene": "\u{1F391}",
      "red_envelope": "\u{1F9E7}",
      "ribbon": "\u{1F380}",
      "gift": "\u{1F381}",
      "reminder_ribbon": "\u{1F397}\uFE0F",
      "tickets": "\u{1F39F}\uFE0F",
      "ticket": "\u{1F3AB}",
      "medal_military": "\u{1F396}\uFE0F",
      "trophy": "\u{1F3C6}",
      "medal_sports": "\u{1F3C5}",
      "1st_place_medal": "\u{1F947}",
      "2nd_place_medal": "\u{1F948}",
      "3rd_place_medal": "\u{1F949}",
      "soccer": "\u26BD",
      "baseball": "\u26BE",
      "softball": "\u{1F94E}",
      "basketball": "\u{1F3C0}",
      "volleyball": "\u{1F3D0}",
      "football": "\u{1F3C8}",
      "rugby_football": "\u{1F3C9}",
      "tennis": "\u{1F3BE}",
      "flying_disc": "\u{1F94F}",
      "bowling": "\u{1F3B3}",
      "cricket_game": "\u{1F3CF}",
      "field_hockey": "\u{1F3D1}",
      "ice_hockey": "\u{1F3D2}",
      "lacrosse": "\u{1F94D}",
      "ping_pong": "\u{1F3D3}",
      "badminton": "\u{1F3F8}",
      "boxing_glove": "\u{1F94A}",
      "martial_arts_uniform": "\u{1F94B}",
      "goal_net": "\u{1F945}",
      "golf": "\u26F3",
      "ice_skate": "\u26F8\uFE0F",
      "fishing_pole_and_fish": "\u{1F3A3}",
      "diving_mask": "\u{1F93F}",
      "running_shirt_with_sash": "\u{1F3BD}",
      "ski": "\u{1F3BF}",
      "sled": "\u{1F6F7}",
      "curling_stone": "\u{1F94C}",
      "dart": "\u{1F3AF}",
      "yo_yo": "\u{1FA80}",
      "kite": "\u{1FA81}",
      "gun": "\u{1F52B}",
      "8ball": "\u{1F3B1}",
      "crystal_ball": "\u{1F52E}",
      "magic_wand": "\u{1FA84}",
      "video_game": "\u{1F3AE}",
      "joystick": "\u{1F579}\uFE0F",
      "slot_machine": "\u{1F3B0}",
      "game_die": "\u{1F3B2}",
      "jigsaw": "\u{1F9E9}",
      "teddy_bear": "\u{1F9F8}",
      "pinata": "\u{1FA85}",
      "mirror_ball": "\u{1FAA9}",
      "nesting_dolls": "\u{1FA86}",
      "spades": "\u2660\uFE0F",
      "hearts": "\u2665\uFE0F",
      "diamonds": "\u2666\uFE0F",
      "clubs": "\u2663\uFE0F",
      "chess_pawn": "\u265F\uFE0F",
      "black_joker": "\u{1F0CF}",
      "mahjong": "\u{1F004}",
      "flower_playing_cards": "\u{1F3B4}",
      "performing_arts": "\u{1F3AD}",
      "framed_picture": "\u{1F5BC}\uFE0F",
      "art": "\u{1F3A8}",
      "thread": "\u{1F9F5}",
      "sewing_needle": "\u{1FAA1}",
      "yarn": "\u{1F9F6}",
      "knot": "\u{1FAA2}",
      "eyeglasses": "\u{1F453}",
      "dark_sunglasses": "\u{1F576}\uFE0F",
      "goggles": "\u{1F97D}",
      "lab_coat": "\u{1F97C}",
      "safety_vest": "\u{1F9BA}",
      "necktie": "\u{1F454}",
      "shirt": "\u{1F455}",
      "tshirt": "\u{1F455}",
      "jeans": "\u{1F456}",
      "scarf": "\u{1F9E3}",
      "gloves": "\u{1F9E4}",
      "coat": "\u{1F9E5}",
      "socks": "\u{1F9E6}",
      "dress": "\u{1F457}",
      "kimono": "\u{1F458}",
      "sari": "\u{1F97B}",
      "one_piece_swimsuit": "\u{1FA71}",
      "swim_brief": "\u{1FA72}",
      "shorts": "\u{1FA73}",
      "bikini": "\u{1F459}",
      "womans_clothes": "\u{1F45A}",
      "folding_hand_fan": "\u{1FAAD}",
      "purse": "\u{1F45B}",
      "handbag": "\u{1F45C}",
      "pouch": "\u{1F45D}",
      "shopping": "\u{1F6CD}\uFE0F",
      "school_satchel": "\u{1F392}",
      "thong_sandal": "\u{1FA74}",
      "mans_shoe": "\u{1F45E}",
      "shoe": "\u{1F45E}",
      "athletic_shoe": "\u{1F45F}",
      "hiking_boot": "\u{1F97E}",
      "flat_shoe": "\u{1F97F}",
      "high_heel": "\u{1F460}",
      "sandal": "\u{1F461}",
      "ballet_shoes": "\u{1FA70}",
      "boot": "\u{1F462}",
      "hair_pick": "\u{1FAAE}",
      "crown": "\u{1F451}",
      "womans_hat": "\u{1F452}",
      "tophat": "\u{1F3A9}",
      "mortar_board": "\u{1F393}",
      "billed_cap": "\u{1F9E2}",
      "military_helmet": "\u{1FA96}",
      "rescue_worker_helmet": "\u26D1\uFE0F",
      "prayer_beads": "\u{1F4FF}",
      "lipstick": "\u{1F484}",
      "ring": "\u{1F48D}",
      "gem": "\u{1F48E}",
      "mute": "\u{1F507}",
      "speaker": "\u{1F508}",
      "sound": "\u{1F509}",
      "loud_sound": "\u{1F50A}",
      "loudspeaker": "\u{1F4E2}",
      "mega": "\u{1F4E3}",
      "postal_horn": "\u{1F4EF}",
      "bell": "\u{1F514}",
      "no_bell": "\u{1F515}",
      "musical_score": "\u{1F3BC}",
      "musical_note": "\u{1F3B5}",
      "notes": "\u{1F3B6}",
      "studio_microphone": "\u{1F399}\uFE0F",
      "level_slider": "\u{1F39A}\uFE0F",
      "control_knobs": "\u{1F39B}\uFE0F",
      "microphone": "\u{1F3A4}",
      "headphones": "\u{1F3A7}",
      "radio": "\u{1F4FB}",
      "saxophone": "\u{1F3B7}",
      "accordion": "\u{1FA97}",
      "guitar": "\u{1F3B8}",
      "musical_keyboard": "\u{1F3B9}",
      "trumpet": "\u{1F3BA}",
      "violin": "\u{1F3BB}",
      "banjo": "\u{1FA95}",
      "drum": "\u{1F941}",
      "long_drum": "\u{1FA98}",
      "maracas": "\u{1FA87}",
      "flute": "\u{1FA88}",
      "iphone": "\u{1F4F1}",
      "calling": "\u{1F4F2}",
      "phone": "\u260E\uFE0F",
      "telephone": "\u260E\uFE0F",
      "telephone_receiver": "\u{1F4DE}",
      "pager": "\u{1F4DF}",
      "fax": "\u{1F4E0}",
      "battery": "\u{1F50B}",
      "low_battery": "\u{1FAAB}",
      "electric_plug": "\u{1F50C}",
      "computer": "\u{1F4BB}",
      "desktop_computer": "\u{1F5A5}\uFE0F",
      "printer": "\u{1F5A8}\uFE0F",
      "keyboard": "\u2328\uFE0F",
      "computer_mouse": "\u{1F5B1}\uFE0F",
      "trackball": "\u{1F5B2}\uFE0F",
      "minidisc": "\u{1F4BD}",
      "floppy_disk": "\u{1F4BE}",
      "cd": "\u{1F4BF}",
      "dvd": "\u{1F4C0}",
      "abacus": "\u{1F9EE}",
      "movie_camera": "\u{1F3A5}",
      "film_strip": "\u{1F39E}\uFE0F",
      "film_projector": "\u{1F4FD}\uFE0F",
      "clapper": "\u{1F3AC}",
      "tv": "\u{1F4FA}",
      "camera": "\u{1F4F7}",
      "camera_flash": "\u{1F4F8}",
      "video_camera": "\u{1F4F9}",
      "vhs": "\u{1F4FC}",
      "mag": "\u{1F50D}",
      "mag_right": "\u{1F50E}",
      "candle": "\u{1F56F}\uFE0F",
      "bulb": "\u{1F4A1}",
      "flashlight": "\u{1F526}",
      "izakaya_lantern": "\u{1F3EE}",
      "lantern": "\u{1F3EE}",
      "diya_lamp": "\u{1FA94}",
      "notebook_with_decorative_cover": "\u{1F4D4}",
      "closed_book": "\u{1F4D5}",
      "book": "\u{1F4D6}",
      "open_book": "\u{1F4D6}",
      "green_book": "\u{1F4D7}",
      "blue_book": "\u{1F4D8}",
      "orange_book": "\u{1F4D9}",
      "books": "\u{1F4DA}",
      "notebook": "\u{1F4D3}",
      "ledger": "\u{1F4D2}",
      "page_with_curl": "\u{1F4C3}",
      "scroll": "\u{1F4DC}",
      "page_facing_up": "\u{1F4C4}",
      "newspaper": "\u{1F4F0}",
      "newspaper_roll": "\u{1F5DE}\uFE0F",
      "bookmark_tabs": "\u{1F4D1}",
      "bookmark": "\u{1F516}",
      "label": "\u{1F3F7}\uFE0F",
      "moneybag": "\u{1F4B0}",
      "coin": "\u{1FA99}",
      "yen": "\u{1F4B4}",
      "dollar": "\u{1F4B5}",
      "euro": "\u{1F4B6}",
      "pound": "\u{1F4B7}",
      "money_with_wings": "\u{1F4B8}",
      "credit_card": "\u{1F4B3}",
      "receipt": "\u{1F9FE}",
      "chart": "\u{1F4B9}",
      "envelope": "\u2709\uFE0F",
      "email": "\u{1F4E7}",
      "e-mail": "\u{1F4E7}",
      "incoming_envelope": "\u{1F4E8}",
      "envelope_with_arrow": "\u{1F4E9}",
      "outbox_tray": "\u{1F4E4}",
      "inbox_tray": "\u{1F4E5}",
      "package": "\u{1F4E6}",
      "mailbox": "\u{1F4EB}",
      "mailbox_closed": "\u{1F4EA}",
      "mailbox_with_mail": "\u{1F4EC}",
      "mailbox_with_no_mail": "\u{1F4ED}",
      "postbox": "\u{1F4EE}",
      "ballot_box": "\u{1F5F3}\uFE0F",
      "pencil2": "\u270F\uFE0F",
      "black_nib": "\u2712\uFE0F",
      "fountain_pen": "\u{1F58B}\uFE0F",
      "pen": "\u{1F58A}\uFE0F",
      "paintbrush": "\u{1F58C}\uFE0F",
      "crayon": "\u{1F58D}\uFE0F",
      "memo": "\u{1F4DD}",
      "pencil": "\u{1F4DD}",
      "briefcase": "\u{1F4BC}",
      "file_folder": "\u{1F4C1}",
      "open_file_folder": "\u{1F4C2}",
      "card_index_dividers": "\u{1F5C2}\uFE0F",
      "date": "\u{1F4C5}",
      "calendar": "\u{1F4C6}",
      "spiral_notepad": "\u{1F5D2}\uFE0F",
      "spiral_calendar": "\u{1F5D3}\uFE0F",
      "card_index": "\u{1F4C7}",
      "chart_with_upwards_trend": "\u{1F4C8}",
      "chart_with_downwards_trend": "\u{1F4C9}",
      "bar_chart": "\u{1F4CA}",
      "clipboard": "\u{1F4CB}",
      "pushpin": "\u{1F4CC}",
      "round_pushpin": "\u{1F4CD}",
      "paperclip": "\u{1F4CE}",
      "paperclips": "\u{1F587}\uFE0F",
      "straight_ruler": "\u{1F4CF}",
      "triangular_ruler": "\u{1F4D0}",
      "scissors": "\u2702\uFE0F",
      "card_file_box": "\u{1F5C3}\uFE0F",
      "file_cabinet": "\u{1F5C4}\uFE0F",
      "wastebasket": "\u{1F5D1}\uFE0F",
      "lock": "\u{1F512}",
      "unlock": "\u{1F513}",
      "lock_with_ink_pen": "\u{1F50F}",
      "closed_lock_with_key": "\u{1F510}",
      "key": "\u{1F511}",
      "old_key": "\u{1F5DD}\uFE0F",
      "hammer": "\u{1F528}",
      "axe": "\u{1FA93}",
      "pick": "\u26CF\uFE0F",
      "hammer_and_pick": "\u2692\uFE0F",
      "hammer_and_wrench": "\u{1F6E0}\uFE0F",
      "dagger": "\u{1F5E1}\uFE0F",
      "crossed_swords": "\u2694\uFE0F",
      "bomb": "\u{1F4A3}",
      "boomerang": "\u{1FA83}",
      "bow_and_arrow": "\u{1F3F9}",
      "shield": "\u{1F6E1}\uFE0F",
      "carpentry_saw": "\u{1FA9A}",
      "wrench": "\u{1F527}",
      "screwdriver": "\u{1FA9B}",
      "nut_and_bolt": "\u{1F529}",
      "gear": "\u2699\uFE0F",
      "clamp": "\u{1F5DC}\uFE0F",
      "balance_scale": "\u2696\uFE0F",
      "probing_cane": "\u{1F9AF}",
      "link": "\u{1F517}",
      "chains": "\u26D3\uFE0F",
      "hook": "\u{1FA9D}",
      "toolbox": "\u{1F9F0}",
      "magnet": "\u{1F9F2}",
      "ladder": "\u{1FA9C}",
      "alembic": "\u2697\uFE0F",
      "test_tube": "\u{1F9EA}",
      "petri_dish": "\u{1F9EB}",
      "dna": "\u{1F9EC}",
      "microscope": "\u{1F52C}",
      "telescope": "\u{1F52D}",
      "satellite": "\u{1F4E1}",
      "syringe": "\u{1F489}",
      "drop_of_blood": "\u{1FA78}",
      "pill": "\u{1F48A}",
      "adhesive_bandage": "\u{1FA79}",
      "crutch": "\u{1FA7C}",
      "stethoscope": "\u{1FA7A}",
      "x_ray": "\u{1FA7B}",
      "door": "\u{1F6AA}",
      "elevator": "\u{1F6D7}",
      "mirror": "\u{1FA9E}",
      "window": "\u{1FA9F}",
      "bed": "\u{1F6CF}\uFE0F",
      "couch_and_lamp": "\u{1F6CB}\uFE0F",
      "chair": "\u{1FA91}",
      "toilet": "\u{1F6BD}",
      "plunger": "\u{1FAA0}",
      "shower": "\u{1F6BF}",
      "bathtub": "\u{1F6C1}",
      "mouse_trap": "\u{1FAA4}",
      "razor": "\u{1FA92}",
      "lotion_bottle": "\u{1F9F4}",
      "safety_pin": "\u{1F9F7}",
      "broom": "\u{1F9F9}",
      "basket": "\u{1F9FA}",
      "roll_of_paper": "\u{1F9FB}",
      "bucket": "\u{1FAA3}",
      "soap": "\u{1F9FC}",
      "bubbles": "\u{1FAE7}",
      "toothbrush": "\u{1FAA5}",
      "sponge": "\u{1F9FD}",
      "fire_extinguisher": "\u{1F9EF}",
      "shopping_cart": "\u{1F6D2}",
      "smoking": "\u{1F6AC}",
      "coffin": "\u26B0\uFE0F",
      "headstone": "\u{1FAA6}",
      "funeral_urn": "\u26B1\uFE0F",
      "nazar_amulet": "\u{1F9FF}",
      "hamsa": "\u{1FAAC}",
      "moyai": "\u{1F5FF}",
      "placard": "\u{1FAA7}",
      "identification_card": "\u{1FAAA}",
      "atm": "\u{1F3E7}",
      "put_litter_in_its_place": "\u{1F6AE}",
      "potable_water": "\u{1F6B0}",
      "wheelchair": "\u267F",
      "mens": "\u{1F6B9}",
      "womens": "\u{1F6BA}",
      "restroom": "\u{1F6BB}",
      "baby_symbol": "\u{1F6BC}",
      "wc": "\u{1F6BE}",
      "passport_control": "\u{1F6C2}",
      "customs": "\u{1F6C3}",
      "baggage_claim": "\u{1F6C4}",
      "left_luggage": "\u{1F6C5}",
      "warning": "\u26A0\uFE0F",
      "children_crossing": "\u{1F6B8}",
      "no_entry": "\u26D4",
      "no_entry_sign": "\u{1F6AB}",
      "no_bicycles": "\u{1F6B3}",
      "no_smoking": "\u{1F6AD}",
      "do_not_litter": "\u{1F6AF}",
      "non-potable_water": "\u{1F6B1}",
      "no_pedestrians": "\u{1F6B7}",
      "no_mobile_phones": "\u{1F4F5}",
      "underage": "\u{1F51E}",
      "radioactive": "\u2622\uFE0F",
      "biohazard": "\u2623\uFE0F",
      "arrow_up": "\u2B06\uFE0F",
      "arrow_upper_right": "\u2197\uFE0F",
      "arrow_right": "\u27A1\uFE0F",
      "arrow_lower_right": "\u2198\uFE0F",
      "arrow_down": "\u2B07\uFE0F",
      "arrow_lower_left": "\u2199\uFE0F",
      "arrow_left": "\u2B05\uFE0F",
      "arrow_upper_left": "\u2196\uFE0F",
      "arrow_up_down": "\u2195\uFE0F",
      "left_right_arrow": "\u2194\uFE0F",
      "leftwards_arrow_with_hook": "\u21A9\uFE0F",
      "arrow_right_hook": "\u21AA\uFE0F",
      "arrow_heading_up": "\u2934\uFE0F",
      "arrow_heading_down": "\u2935\uFE0F",
      "arrows_clockwise": "\u{1F503}",
      "arrows_counterclockwise": "\u{1F504}",
      "back": "\u{1F519}",
      "end": "\u{1F51A}",
      "on": "\u{1F51B}",
      "soon": "\u{1F51C}",
      "top": "\u{1F51D}",
      "place_of_worship": "\u{1F6D0}",
      "atom_symbol": "\u269B\uFE0F",
      "om": "\u{1F549}\uFE0F",
      "star_of_david": "\u2721\uFE0F",
      "wheel_of_dharma": "\u2638\uFE0F",
      "yin_yang": "\u262F\uFE0F",
      "latin_cross": "\u271D\uFE0F",
      "orthodox_cross": "\u2626\uFE0F",
      "star_and_crescent": "\u262A\uFE0F",
      "peace_symbol": "\u262E\uFE0F",
      "menorah": "\u{1F54E}",
      "six_pointed_star": "\u{1F52F}",
      "khanda": "\u{1FAAF}",
      "aries": "\u2648",
      "taurus": "\u2649",
      "gemini": "\u264A",
      "cancer": "\u264B",
      "leo": "\u264C",
      "virgo": "\u264D",
      "libra": "\u264E",
      "scorpius": "\u264F",
      "sagittarius": "\u2650",
      "capricorn": "\u2651",
      "aquarius": "\u2652",
      "pisces": "\u2653",
      "ophiuchus": "\u26CE",
      "twisted_rightwards_arrows": "\u{1F500}",
      "repeat": "\u{1F501}",
      "repeat_one": "\u{1F502}",
      "arrow_forward": "\u25B6\uFE0F",
      "fast_forward": "\u23E9",
      "next_track_button": "\u23ED\uFE0F",
      "play_or_pause_button": "\u23EF\uFE0F",
      "arrow_backward": "\u25C0\uFE0F",
      "rewind": "\u23EA",
      "previous_track_button": "\u23EE\uFE0F",
      "arrow_up_small": "\u{1F53C}",
      "arrow_double_up": "\u23EB",
      "arrow_down_small": "\u{1F53D}",
      "arrow_double_down": "\u23EC",
      "pause_button": "\u23F8\uFE0F",
      "stop_button": "\u23F9\uFE0F",
      "record_button": "\u23FA\uFE0F",
      "eject_button": "\u23CF\uFE0F",
      "cinema": "\u{1F3A6}",
      "low_brightness": "\u{1F505}",
      "high_brightness": "\u{1F506}",
      "signal_strength": "\u{1F4F6}",
      "wireless": "\u{1F6DC}",
      "vibration_mode": "\u{1F4F3}",
      "mobile_phone_off": "\u{1F4F4}",
      "female_sign": "\u2640\uFE0F",
      "male_sign": "\u2642\uFE0F",
      "transgender_symbol": "\u26A7\uFE0F",
      "heavy_multiplication_x": "\u2716\uFE0F",
      "heavy_plus_sign": "\u2795",
      "heavy_minus_sign": "\u2796",
      "heavy_division_sign": "\u2797",
      "heavy_equals_sign": "\u{1F7F0}",
      "infinity": "\u267E\uFE0F",
      "bangbang": "\u203C\uFE0F",
      "interrobang": "\u2049\uFE0F",
      "question": "\u2753",
      "grey_question": "\u2754",
      "grey_exclamation": "\u2755",
      "exclamation": "\u2757",
      "heavy_exclamation_mark": "\u2757",
      "wavy_dash": "\u3030\uFE0F",
      "currency_exchange": "\u{1F4B1}",
      "heavy_dollar_sign": "\u{1F4B2}",
      "medical_symbol": "\u2695\uFE0F",
      "recycle": "\u267B\uFE0F",
      "fleur_de_lis": "\u269C\uFE0F",
      "trident": "\u{1F531}",
      "name_badge": "\u{1F4DB}",
      "beginner": "\u{1F530}",
      "o": "\u2B55",
      "white_check_mark": "\u2705",
      "ballot_box_with_check": "\u2611\uFE0F",
      "heavy_check_mark": "\u2714\uFE0F",
      "x": "\u274C",
      "negative_squared_cross_mark": "\u274E",
      "curly_loop": "\u27B0",
      "loop": "\u27BF",
      "part_alternation_mark": "\u303D\uFE0F",
      "eight_spoked_asterisk": "\u2733\uFE0F",
      "eight_pointed_black_star": "\u2734\uFE0F",
      "sparkle": "\u2747\uFE0F",
      "copyright": "\xA9\uFE0F",
      "registered": "\xAE\uFE0F",
      "tm": "\u2122\uFE0F",
      "hash": "#\uFE0F\u20E3",
      "asterisk": "*\uFE0F\u20E3",
      "zero": "0\uFE0F\u20E3",
      "one": "1\uFE0F\u20E3",
      "two": "2\uFE0F\u20E3",
      "three": "3\uFE0F\u20E3",
      "four": "4\uFE0F\u20E3",
      "five": "5\uFE0F\u20E3",
      "six": "6\uFE0F\u20E3",
      "seven": "7\uFE0F\u20E3",
      "eight": "8\uFE0F\u20E3",
      "nine": "9\uFE0F\u20E3",
      "keycap_ten": "\u{1F51F}",
      "capital_abcd": "\u{1F520}",
      "abcd": "\u{1F521}",
      "symbols": "\u{1F523}",
      "abc": "\u{1F524}",
      "a": "\u{1F170}\uFE0F",
      "ab": "\u{1F18E}",
      "b": "\u{1F171}\uFE0F",
      "cl": "\u{1F191}",
      "cool": "\u{1F192}",
      "free": "\u{1F193}",
      "information_source": "\u2139\uFE0F",
      "id": "\u{1F194}",
      "m": "\u24C2\uFE0F",
      "new": "\u{1F195}",
      "ng": "\u{1F196}",
      "o2": "\u{1F17E}\uFE0F",
      "ok": "\u{1F197}",
      "parking": "\u{1F17F}\uFE0F",
      "sos": "\u{1F198}",
      "up": "\u{1F199}",
      "vs": "\u{1F19A}",
      "koko": "\u{1F201}",
      "sa": "\u{1F202}\uFE0F",
      "ideograph_advantage": "\u{1F250}",
      "accept": "\u{1F251}",
      "congratulations": "\u3297\uFE0F",
      "secret": "\u3299\uFE0F",
      "u6e80": "\u{1F235}",
      "red_circle": "\u{1F534}",
      "orange_circle": "\u{1F7E0}",
      "yellow_circle": "\u{1F7E1}",
      "green_circle": "\u{1F7E2}",
      "large_blue_circle": "\u{1F535}",
      "purple_circle": "\u{1F7E3}",
      "brown_circle": "\u{1F7E4}",
      "black_circle": "\u26AB",
      "white_circle": "\u26AA",
      "red_square": "\u{1F7E5}",
      "orange_square": "\u{1F7E7}",
      "yellow_square": "\u{1F7E8}",
      "green_square": "\u{1F7E9}",
      "blue_square": "\u{1F7E6}",
      "purple_square": "\u{1F7EA}",
      "brown_square": "\u{1F7EB}",
      "black_large_square": "\u2B1B",
      "white_large_square": "\u2B1C",
      "black_medium_square": "\u25FC\uFE0F",
      "white_medium_square": "\u25FB\uFE0F",
      "black_medium_small_square": "\u25FE",
      "white_medium_small_square": "\u25FD",
      "black_small_square": "\u25AA\uFE0F",
      "white_small_square": "\u25AB\uFE0F",
      "large_orange_diamond": "\u{1F536}",
      "large_blue_diamond": "\u{1F537}",
      "small_orange_diamond": "\u{1F538}",
      "small_blue_diamond": "\u{1F539}",
      "small_red_triangle": "\u{1F53A}",
      "small_red_triangle_down": "\u{1F53B}",
      "diamond_shape_with_a_dot_inside": "\u{1F4A0}",
      "radio_button": "\u{1F518}",
      "white_square_button": "\u{1F533}",
      "black_square_button": "\u{1F532}",
      "checkered_flag": "\u{1F3C1}",
      "triangular_flag_on_post": "\u{1F6A9}",
      "crossed_flags": "\u{1F38C}",
      "black_flag": "\u{1F3F4}",
      "white_flag": "\u{1F3F3}\uFE0F",
      "rainbow_flag": "\u{1F3F3}\uFE0F\u200D\u{1F308}",
      "transgender_flag": "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F",
      "pirate_flag": "\u{1F3F4}\u200D\u2620\uFE0F",
      "ascension_island": "\u{1F1E6}\u{1F1E8}",
      "andorra": "\u{1F1E6}\u{1F1E9}",
      "united_arab_emirates": "\u{1F1E6}\u{1F1EA}",
      "afghanistan": "\u{1F1E6}\u{1F1EB}",
      "antigua_barbuda": "\u{1F1E6}\u{1F1EC}",
      "anguilla": "\u{1F1E6}\u{1F1EE}",
      "albania": "\u{1F1E6}\u{1F1F1}",
      "armenia": "\u{1F1E6}\u{1F1F2}",
      "angola": "\u{1F1E6}\u{1F1F4}",
      "antarctica": "\u{1F1E6}\u{1F1F6}",
      "argentina": "\u{1F1E6}\u{1F1F7}",
      "american_samoa": "\u{1F1E6}\u{1F1F8}",
      "austria": "\u{1F1E6}\u{1F1F9}",
      "australia": "\u{1F1E6}\u{1F1FA}",
      "aruba": "\u{1F1E6}\u{1F1FC}",
      "aland_islands": "\u{1F1E6}\u{1F1FD}",
      "azerbaijan": "\u{1F1E6}\u{1F1FF}",
      "bosnia_herzegovina": "\u{1F1E7}\u{1F1E6}",
      "barbados": "\u{1F1E7}\u{1F1E7}",
      "bangladesh": "\u{1F1E7}\u{1F1E9}",
      "belgium": "\u{1F1E7}\u{1F1EA}",
      "burkina_faso": "\u{1F1E7}\u{1F1EB}",
      "bulgaria": "\u{1F1E7}\u{1F1EC}",
      "bahrain": "\u{1F1E7}\u{1F1ED}",
      "burundi": "\u{1F1E7}\u{1F1EE}",
      "benin": "\u{1F1E7}\u{1F1EF}",
      "st_barthelemy": "\u{1F1E7}\u{1F1F1}",
      "bermuda": "\u{1F1E7}\u{1F1F2}",
      "brunei": "\u{1F1E7}\u{1F1F3}",
      "bolivia": "\u{1F1E7}\u{1F1F4}",
      "caribbean_netherlands": "\u{1F1E7}\u{1F1F6}",
      "brazil": "\u{1F1E7}\u{1F1F7}",
      "bahamas": "\u{1F1E7}\u{1F1F8}",
      "bhutan": "\u{1F1E7}\u{1F1F9}",
      "bouvet_island": "\u{1F1E7}\u{1F1FB}",
      "botswana": "\u{1F1E7}\u{1F1FC}",
      "belarus": "\u{1F1E7}\u{1F1FE}",
      "belize": "\u{1F1E7}\u{1F1FF}",
      "canada": "\u{1F1E8}\u{1F1E6}",
      "cocos_islands": "\u{1F1E8}\u{1F1E8}",
      "congo_kinshasa": "\u{1F1E8}\u{1F1E9}",
      "central_african_republic": "\u{1F1E8}\u{1F1EB}",
      "congo_brazzaville": "\u{1F1E8}\u{1F1EC}",
      "switzerland": "\u{1F1E8}\u{1F1ED}",
      "cote_divoire": "\u{1F1E8}\u{1F1EE}",
      "cook_islands": "\u{1F1E8}\u{1F1F0}",
      "chile": "\u{1F1E8}\u{1F1F1}",
      "cameroon": "\u{1F1E8}\u{1F1F2}",
      "cn": "\u{1F1E8}\u{1F1F3}",
      "colombia": "\u{1F1E8}\u{1F1F4}",
      "clipperton_island": "\u{1F1E8}\u{1F1F5}",
      "costa_rica": "\u{1F1E8}\u{1F1F7}",
      "cuba": "\u{1F1E8}\u{1F1FA}",
      "cape_verde": "\u{1F1E8}\u{1F1FB}",
      "curacao": "\u{1F1E8}\u{1F1FC}",
      "christmas_island": "\u{1F1E8}\u{1F1FD}",
      "cyprus": "\u{1F1E8}\u{1F1FE}",
      "czech_republic": "\u{1F1E8}\u{1F1FF}",
      "de": "\u{1F1E9}\u{1F1EA}",
      "diego_garcia": "\u{1F1E9}\u{1F1EC}",
      "djibouti": "\u{1F1E9}\u{1F1EF}",
      "denmark": "\u{1F1E9}\u{1F1F0}",
      "dominica": "\u{1F1E9}\u{1F1F2}",
      "dominican_republic": "\u{1F1E9}\u{1F1F4}",
      "algeria": "\u{1F1E9}\u{1F1FF}",
      "ceuta_melilla": "\u{1F1EA}\u{1F1E6}",
      "ecuador": "\u{1F1EA}\u{1F1E8}",
      "estonia": "\u{1F1EA}\u{1F1EA}",
      "egypt": "\u{1F1EA}\u{1F1EC}",
      "western_sahara": "\u{1F1EA}\u{1F1ED}",
      "eritrea": "\u{1F1EA}\u{1F1F7}",
      "es": "\u{1F1EA}\u{1F1F8}",
      "ethiopia": "\u{1F1EA}\u{1F1F9}",
      "eu": "\u{1F1EA}\u{1F1FA}",
      "european_union": "\u{1F1EA}\u{1F1FA}",
      "finland": "\u{1F1EB}\u{1F1EE}",
      "fiji": "\u{1F1EB}\u{1F1EF}",
      "falkland_islands": "\u{1F1EB}\u{1F1F0}",
      "micronesia": "\u{1F1EB}\u{1F1F2}",
      "faroe_islands": "\u{1F1EB}\u{1F1F4}",
      "fr": "\u{1F1EB}\u{1F1F7}",
      "gabon": "\u{1F1EC}\u{1F1E6}",
      "gb": "\u{1F1EC}\u{1F1E7}",
      "uk": "\u{1F1EC}\u{1F1E7}",
      "grenada": "\u{1F1EC}\u{1F1E9}",
      "georgia": "\u{1F1EC}\u{1F1EA}",
      "french_guiana": "\u{1F1EC}\u{1F1EB}",
      "guernsey": "\u{1F1EC}\u{1F1EC}",
      "ghana": "\u{1F1EC}\u{1F1ED}",
      "gibraltar": "\u{1F1EC}\u{1F1EE}",
      "greenland": "\u{1F1EC}\u{1F1F1}",
      "gambia": "\u{1F1EC}\u{1F1F2}",
      "guinea": "\u{1F1EC}\u{1F1F3}",
      "guadeloupe": "\u{1F1EC}\u{1F1F5}",
      "equatorial_guinea": "\u{1F1EC}\u{1F1F6}",
      "greece": "\u{1F1EC}\u{1F1F7}",
      "south_georgia_south_sandwich_islands": "\u{1F1EC}\u{1F1F8}",
      "guatemala": "\u{1F1EC}\u{1F1F9}",
      "guam": "\u{1F1EC}\u{1F1FA}",
      "guinea_bissau": "\u{1F1EC}\u{1F1FC}",
      "guyana": "\u{1F1EC}\u{1F1FE}",
      "hong_kong": "\u{1F1ED}\u{1F1F0}",
      "heard_mcdonald_islands": "\u{1F1ED}\u{1F1F2}",
      "honduras": "\u{1F1ED}\u{1F1F3}",
      "croatia": "\u{1F1ED}\u{1F1F7}",
      "haiti": "\u{1F1ED}\u{1F1F9}",
      "hungary": "\u{1F1ED}\u{1F1FA}",
      "canary_islands": "\u{1F1EE}\u{1F1E8}",
      "indonesia": "\u{1F1EE}\u{1F1E9}",
      "ireland": "\u{1F1EE}\u{1F1EA}",
      "israel": "\u{1F1EE}\u{1F1F1}",
      "isle_of_man": "\u{1F1EE}\u{1F1F2}",
      "india": "\u{1F1EE}\u{1F1F3}",
      "british_indian_ocean_territory": "\u{1F1EE}\u{1F1F4}",
      "iraq": "\u{1F1EE}\u{1F1F6}",
      "iran": "\u{1F1EE}\u{1F1F7}",
      "iceland": "\u{1F1EE}\u{1F1F8}",
      "it": "\u{1F1EE}\u{1F1F9}",
      "jersey": "\u{1F1EF}\u{1F1EA}",
      "jamaica": "\u{1F1EF}\u{1F1F2}",
      "jordan": "\u{1F1EF}\u{1F1F4}",
      "jp": "\u{1F1EF}\u{1F1F5}",
      "kenya": "\u{1F1F0}\u{1F1EA}",
      "kyrgyzstan": "\u{1F1F0}\u{1F1EC}",
      "cambodia": "\u{1F1F0}\u{1F1ED}",
      "kiribati": "\u{1F1F0}\u{1F1EE}",
      "comoros": "\u{1F1F0}\u{1F1F2}",
      "st_kitts_nevis": "\u{1F1F0}\u{1F1F3}",
      "north_korea": "\u{1F1F0}\u{1F1F5}",
      "kr": "\u{1F1F0}\u{1F1F7}",
      "kuwait": "\u{1F1F0}\u{1F1FC}",
      "cayman_islands": "\u{1F1F0}\u{1F1FE}",
      "kazakhstan": "\u{1F1F0}\u{1F1FF}",
      "laos": "\u{1F1F1}\u{1F1E6}",
      "lebanon": "\u{1F1F1}\u{1F1E7}",
      "st_lucia": "\u{1F1F1}\u{1F1E8}",
      "liechtenstein": "\u{1F1F1}\u{1F1EE}",
      "sri_lanka": "\u{1F1F1}\u{1F1F0}",
      "liberia": "\u{1F1F1}\u{1F1F7}",
      "lesotho": "\u{1F1F1}\u{1F1F8}",
      "lithuania": "\u{1F1F1}\u{1F1F9}",
      "luxembourg": "\u{1F1F1}\u{1F1FA}",
      "latvia": "\u{1F1F1}\u{1F1FB}",
      "libya": "\u{1F1F1}\u{1F1FE}",
      "morocco": "\u{1F1F2}\u{1F1E6}",
      "monaco": "\u{1F1F2}\u{1F1E8}",
      "moldova": "\u{1F1F2}\u{1F1E9}",
      "montenegro": "\u{1F1F2}\u{1F1EA}",
      "st_martin": "\u{1F1F2}\u{1F1EB}",
      "madagascar": "\u{1F1F2}\u{1F1EC}",
      "marshall_islands": "\u{1F1F2}\u{1F1ED}",
      "macedonia": "\u{1F1F2}\u{1F1F0}",
      "mali": "\u{1F1F2}\u{1F1F1}",
      "myanmar": "\u{1F1F2}\u{1F1F2}",
      "mongolia": "\u{1F1F2}\u{1F1F3}",
      "macau": "\u{1F1F2}\u{1F1F4}",
      "northern_mariana_islands": "\u{1F1F2}\u{1F1F5}",
      "martinique": "\u{1F1F2}\u{1F1F6}",
      "mauritania": "\u{1F1F2}\u{1F1F7}",
      "montserrat": "\u{1F1F2}\u{1F1F8}",
      "malta": "\u{1F1F2}\u{1F1F9}",
      "mauritius": "\u{1F1F2}\u{1F1FA}",
      "maldives": "\u{1F1F2}\u{1F1FB}",
      "malawi": "\u{1F1F2}\u{1F1FC}",
      "mexico": "\u{1F1F2}\u{1F1FD}",
      "malaysia": "\u{1F1F2}\u{1F1FE}",
      "mozambique": "\u{1F1F2}\u{1F1FF}",
      "namibia": "\u{1F1F3}\u{1F1E6}",
      "new_caledonia": "\u{1F1F3}\u{1F1E8}",
      "niger": "\u{1F1F3}\u{1F1EA}",
      "norfolk_island": "\u{1F1F3}\u{1F1EB}",
      "nigeria": "\u{1F1F3}\u{1F1EC}",
      "nicaragua": "\u{1F1F3}\u{1F1EE}",
      "netherlands": "\u{1F1F3}\u{1F1F1}",
      "norway": "\u{1F1F3}\u{1F1F4}",
      "nepal": "\u{1F1F3}\u{1F1F5}",
      "nauru": "\u{1F1F3}\u{1F1F7}",
      "niue": "\u{1F1F3}\u{1F1FA}",
      "new_zealand": "\u{1F1F3}\u{1F1FF}",
      "oman": "\u{1F1F4}\u{1F1F2}",
      "panama": "\u{1F1F5}\u{1F1E6}",
      "peru": "\u{1F1F5}\u{1F1EA}",
      "french_polynesia": "\u{1F1F5}\u{1F1EB}",
      "papua_new_guinea": "\u{1F1F5}\u{1F1EC}",
      "philippines": "\u{1F1F5}\u{1F1ED}",
      "pakistan": "\u{1F1F5}\u{1F1F0}",
      "poland": "\u{1F1F5}\u{1F1F1}",
      "st_pierre_miquelon": "\u{1F1F5}\u{1F1F2}",
      "pitcairn_islands": "\u{1F1F5}\u{1F1F3}",
      "puerto_rico": "\u{1F1F5}\u{1F1F7}",
      "palestinian_territories": "\u{1F1F5}\u{1F1F8}",
      "portugal": "\u{1F1F5}\u{1F1F9}",
      "palau": "\u{1F1F5}\u{1F1FC}",
      "paraguay": "\u{1F1F5}\u{1F1FE}",
      "qatar": "\u{1F1F6}\u{1F1E6}",
      "reunion": "\u{1F1F7}\u{1F1EA}",
      "romania": "\u{1F1F7}\u{1F1F4}",
      "serbia": "\u{1F1F7}\u{1F1F8}",
      "ru": "\u{1F1F7}\u{1F1FA}",
      "rwanda": "\u{1F1F7}\u{1F1FC}",
      "saudi_arabia": "\u{1F1F8}\u{1F1E6}",
      "solomon_islands": "\u{1F1F8}\u{1F1E7}",
      "seychelles": "\u{1F1F8}\u{1F1E8}",
      "sudan": "\u{1F1F8}\u{1F1E9}",
      "sweden": "\u{1F1F8}\u{1F1EA}",
      "singapore": "\u{1F1F8}\u{1F1EC}",
      "st_helena": "\u{1F1F8}\u{1F1ED}",
      "slovenia": "\u{1F1F8}\u{1F1EE}",
      "svalbard_jan_mayen": "\u{1F1F8}\u{1F1EF}",
      "slovakia": "\u{1F1F8}\u{1F1F0}",
      "sierra_leone": "\u{1F1F8}\u{1F1F1}",
      "san_marino": "\u{1F1F8}\u{1F1F2}",
      "senegal": "\u{1F1F8}\u{1F1F3}",
      "somalia": "\u{1F1F8}\u{1F1F4}",
      "suriname": "\u{1F1F8}\u{1F1F7}",
      "south_sudan": "\u{1F1F8}\u{1F1F8}",
      "sao_tome_principe": "\u{1F1F8}\u{1F1F9}",
      "el_salvador": "\u{1F1F8}\u{1F1FB}",
      "sint_maarten": "\u{1F1F8}\u{1F1FD}",
      "syria": "\u{1F1F8}\u{1F1FE}",
      "swaziland": "\u{1F1F8}\u{1F1FF}",
      "tristan_da_cunha": "\u{1F1F9}\u{1F1E6}",
      "turks_caicos_islands": "\u{1F1F9}\u{1F1E8}",
      "chad": "\u{1F1F9}\u{1F1E9}",
      "french_southern_territories": "\u{1F1F9}\u{1F1EB}",
      "togo": "\u{1F1F9}\u{1F1EC}",
      "thailand": "\u{1F1F9}\u{1F1ED}",
      "tajikistan": "\u{1F1F9}\u{1F1EF}",
      "tokelau": "\u{1F1F9}\u{1F1F0}",
      "timor_leste": "\u{1F1F9}\u{1F1F1}",
      "turkmenistan": "\u{1F1F9}\u{1F1F2}",
      "tunisia": "\u{1F1F9}\u{1F1F3}",
      "tonga": "\u{1F1F9}\u{1F1F4}",
      "tr": "\u{1F1F9}\u{1F1F7}",
      "trinidad_tobago": "\u{1F1F9}\u{1F1F9}",
      "tuvalu": "\u{1F1F9}\u{1F1FB}",
      "taiwan": "\u{1F1F9}\u{1F1FC}",
      "tanzania": "\u{1F1F9}\u{1F1FF}",
      "ukraine": "\u{1F1FA}\u{1F1E6}",
      "uganda": "\u{1F1FA}\u{1F1EC}",
      "us_outlying_islands": "\u{1F1FA}\u{1F1F2}",
      "united_nations": "\u{1F1FA}\u{1F1F3}",
      "us": "\u{1F1FA}\u{1F1F8}",
      "uruguay": "\u{1F1FA}\u{1F1FE}",
      "uzbekistan": "\u{1F1FA}\u{1F1FF}",
      "vatican_city": "\u{1F1FB}\u{1F1E6}",
      "st_vincent_grenadines": "\u{1F1FB}\u{1F1E8}",
      "venezuela": "\u{1F1FB}\u{1F1EA}",
      "british_virgin_islands": "\u{1F1FB}\u{1F1EC}",
      "us_virgin_islands": "\u{1F1FB}\u{1F1EE}",
      "vietnam": "\u{1F1FB}\u{1F1F3}",
      "vanuatu": "\u{1F1FB}\u{1F1FA}",
      "wallis_futuna": "\u{1F1FC}\u{1F1EB}",
      "samoa": "\u{1F1FC}\u{1F1F8}",
      "kosovo": "\u{1F1FD}\u{1F1F0}",
      "yemen": "\u{1F1FE}\u{1F1EA}",
      "mayotte": "\u{1F1FE}\u{1F1F9}",
      "south_africa": "\u{1F1FF}\u{1F1E6}",
      "zambia": "\u{1F1FF}\u{1F1F2}",
      "zimbabwe": "\u{1F1FF}\u{1F1FC}",
      "england": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
      "scotland": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
      "wales": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}"
    };
    function emoji_plugin(md, options) {
      const defaults = {
        defs: emojies_defs,
        shortcuts: emojies_shortcuts,
        enabled: []
      };
      const opts = md.utils.assign({}, defaults, options || {});
      emoji_plugin$2(md, opts);
    }
    exports.bare = emoji_plugin$2;
    exports.full = emoji_plugin;
    exports.light = emoji_plugin$1;
  }
});

// ../../node_modules/.pnpm/katex@0.16.27/node_modules/katex/dist/katex.js
var require_katex = __commonJS({
  "../../node_modules/.pnpm/katex@0.16.27/node_modules/katex/dist/katex.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["katex"] = factory();
      else
        root["katex"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function() {
        "use strict";
        var __webpack_require__ = {};
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        var __webpack_exports__ = {};
        __webpack_require__.d(__webpack_exports__, {
          "default": function() {
            return katex_webpack;
          }
        });
        ;
        class ParseError {
          constructor(message, token) {
            this.name = void 0;
            this.position = void 0;
            this.length = void 0;
            this.rawMessage = void 0;
            let error = "KaTeX parse error: " + message;
            let start;
            let end;
            const loc = token && token.loc;
            if (loc && loc.start <= loc.end) {
              const input = loc.lexer.input;
              start = loc.start;
              end = loc.end;
              if (start === input.length) {
                error += " at end of input: ";
              } else {
                error += " at position " + (start + 1) + ": ";
              }
              const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
              let left;
              if (start > 15) {
                left = "\u2026" + input.slice(start - 15, start);
              } else {
                left = input.slice(0, start);
              }
              let right;
              if (end + 15 < input.length) {
                right = input.slice(end, end + 15) + "\u2026";
              } else {
                right = input.slice(end);
              }
              error += left + underlined + right;
            }
            const self2 = new Error(error);
            self2.name = "ParseError";
            self2.__proto__ = ParseError.prototype;
            self2.position = start;
            if (start != null && end != null) {
              self2.length = end - start;
            }
            self2.rawMessage = message;
            return self2;
          }
        }
        ParseError.prototype.__proto__ = Error.prototype;
        var src_ParseError = ParseError;
        ;
        const deflt = function(setting, defaultIfUndefined) {
          return setting === void 0 ? defaultIfUndefined : setting;
        };
        const uppercase = /([A-Z])/g;
        const hyphenate = function(str) {
          return str.replace(uppercase, "-$1").toLowerCase();
        };
        const ESCAPE_LOOKUP = {
          "&": "&amp;",
          ">": "&gt;",
          "<": "&lt;",
          '"': "&quot;",
          "'": "&#x27;"
        };
        const ESCAPE_REGEX = /[&><"']/g;
        function utils_escape(text) {
          return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
        }
        const getBaseElem = function(group) {
          if (group.type === "ordgroup") {
            if (group.body.length === 1) {
              return getBaseElem(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "color") {
            if (group.body.length === 1) {
              return getBaseElem(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "font") {
            return getBaseElem(group.body);
          } else {
            return group;
          }
        };
        const isCharacterBox = function(group) {
          const baseElem = getBaseElem(group);
          return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
        };
        const assert = function(value) {
          if (!value) {
            throw new Error("Expected non-null, but got " + String(value));
          }
          return value;
        };
        const protocolFromUrl = function(url) {
          const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
          if (!protocol) {
            return "_relative";
          }
          if (protocol[2] !== ":") {
            return null;
          }
          if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
            return null;
          }
          return protocol[1].toLowerCase();
        };
        var utils = {
          deflt,
          escape: utils_escape,
          hyphenate,
          getBaseElem,
          isCharacterBox,
          protocolFromUrl
        };
        ;
        const SETTINGS_SCHEMA = {
          displayMode: {
            type: "boolean",
            description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
            cli: "-d, --display-mode"
          },
          output: {
            type: {
              enum: ["htmlAndMathml", "html", "mathml"]
            },
            description: "Determines the markup language of the output.",
            cli: "-F, --format <type>"
          },
          leqno: {
            type: "boolean",
            description: "Render display math in leqno style (left-justified tags)."
          },
          fleqn: {
            type: "boolean",
            description: "Render display math flush left."
          },
          throwOnError: {
            type: "boolean",
            default: true,
            cli: "-t, --no-throw-on-error",
            cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
          },
          errorColor: {
            type: "string",
            default: "#cc0000",
            cli: "-c, --error-color <color>",
            cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
            cliProcessor: (color) => "#" + color
          },
          macros: {
            type: "object",
            cli: "-m, --macro <def>",
            cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
            cliDefault: [],
            cliProcessor: (def, defs) => {
              defs.push(def);
              return defs;
            }
          },
          minRuleThickness: {
            type: "number",
            description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
            processor: (t2) => Math.max(0, t2),
            cli: "--min-rule-thickness <size>",
            cliProcessor: parseFloat
          },
          colorIsTextColor: {
            type: "boolean",
            description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
            cli: "-b, --color-is-text-color"
          },
          strict: {
            type: [{
              enum: ["warn", "ignore", "error"]
            }, "boolean", "function"],
            description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
            cli: "-S, --strict",
            cliDefault: false
          },
          trust: {
            type: ["boolean", "function"],
            description: "Trust the input, enabling all HTML features such as \\url.",
            cli: "-T, --trust"
          },
          maxSize: {
            type: "number",
            default: Infinity,
            description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
            processor: (s) => Math.max(0, s),
            cli: "-s, --max-size <n>",
            cliProcessor: parseInt
          },
          maxExpand: {
            type: "number",
            default: 1e3,
            description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
            processor: (n) => Math.max(0, n),
            cli: "-e, --max-expand <n>",
            cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
          },
          globalGroup: {
            type: "boolean",
            cli: false
          }
        };
        function getDefaultValue(schema) {
          if (schema.default) {
            return schema.default;
          }
          const type = schema.type;
          const defaultType = Array.isArray(type) ? type[0] : type;
          if (typeof defaultType !== "string") {
            return defaultType.enum[0];
          }
          switch (defaultType) {
            case "boolean":
              return false;
            case "string":
              return "";
            case "number":
              return 0;
            case "object":
              return {};
          }
        }
        class Settings {
          constructor(options) {
            this.displayMode = void 0;
            this.output = void 0;
            this.leqno = void 0;
            this.fleqn = void 0;
            this.throwOnError = void 0;
            this.errorColor = void 0;
            this.macros = void 0;
            this.minRuleThickness = void 0;
            this.colorIsTextColor = void 0;
            this.strict = void 0;
            this.trust = void 0;
            this.maxSize = void 0;
            this.maxExpand = void 0;
            this.globalGroup = void 0;
            options = options || {};
            for (const prop in SETTINGS_SCHEMA) {
              if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
                const schema = SETTINGS_SCHEMA[prop];
                this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
              }
            }
          }
          reportNonstrict(errorCode, errorMsg, token) {
            let strict = this.strict;
            if (typeof strict === "function") {
              strict = strict(errorCode, errorMsg, token);
            }
            if (!strict || strict === "ignore") {
              return;
            } else if (strict === true || strict === "error") {
              throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            }
          }
          useStrictBehavior(errorCode, errorMsg, token) {
            let strict = this.strict;
            if (typeof strict === "function") {
              try {
                strict = strict(errorCode, errorMsg, token);
              } catch (error) {
                strict = "error";
              }
            }
            if (!strict || strict === "ignore") {
              return false;
            } else if (strict === true || strict === "error") {
              return true;
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              return false;
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              return false;
            }
          }
          isTrusted(context) {
            if (context.url && !context.protocol) {
              const protocol = utils.protocolFromUrl(context.url);
              if (protocol == null) {
                return false;
              }
              context.protocol = protocol;
            }
            const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
            return Boolean(trust);
          }
        }
        ;
        class Style {
          constructor(id, size, cramped) {
            this.id = void 0;
            this.size = void 0;
            this.cramped = void 0;
            this.id = id;
            this.size = size;
            this.cramped = cramped;
          }
          sup() {
            return styles[sup[this.id]];
          }
          sub() {
            return styles[sub[this.id]];
          }
          fracNum() {
            return styles[fracNum[this.id]];
          }
          fracDen() {
            return styles[fracDen[this.id]];
          }
          cramp() {
            return styles[cramp[this.id]];
          }
          text() {
            return styles[Style_text[this.id]];
          }
          isTight() {
            return this.size >= 2;
          }
        }
        const D = 0;
        const Dc = 1;
        const T = 2;
        const Tc = 3;
        const S = 4;
        const Sc = 5;
        const SS = 6;
        const SSc = 7;
        const styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
        const sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
        const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
        const fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
        const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
        const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
        const Style_text = [D, Dc, T, Tc, T, Tc, T, Tc];
        var src_Style = {
          DISPLAY: styles[D],
          TEXT: styles[T],
          SCRIPT: styles[S],
          SCRIPTSCRIPT: styles[SS]
        };
        ;
        const scriptData = [{
          name: "latin",
          blocks: [
            [256, 591],
            [768, 879]
          ]
        }, {
          name: "cyrillic",
          blocks: [[1024, 1279]]
        }, {
          name: "armenian",
          blocks: [[1328, 1423]]
        }, {
          name: "brahmic",
          blocks: [[2304, 4255]]
        }, {
          name: "georgian",
          blocks: [[4256, 4351]]
        }, {
          name: "cjk",
          blocks: [
            [12288, 12543],
            [19968, 40879],
            [65280, 65376]
          ]
        }, {
          name: "hangul",
          blocks: [[44032, 55215]]
        }];
        function scriptFromCodepoint(codepoint) {
          for (let i = 0; i < scriptData.length; i++) {
            const script = scriptData[i];
            for (let i2 = 0; i2 < script.blocks.length; i2++) {
              const block = script.blocks[i2];
              if (codepoint >= block[0] && codepoint <= block[1]) {
                return script.name;
              }
            }
          }
          return null;
        }
        const allBlocks = [];
        scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
        function supportedCodepoint(codepoint) {
          for (let i = 0; i < allBlocks.length; i += 2) {
            if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
              return true;
            }
          }
          return false;
        }
        ;
        const hLinePad = 80;
        const sqrtMain = function(extraVinculum, hLinePad2) {
          return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize1 = function(extraVinculum, hLinePad2) {
          return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize2 = function(extraVinculum, hLinePad2) {
          return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize3 = function(extraVinculum, hLinePad2) {
          return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize4 = function(extraVinculum, hLinePad2) {
          return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
        };
        const phasePath = function(y) {
          const x = y / 2;
          return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
        };
        const sqrtTall = function(extraVinculum, hLinePad2, viewBoxHeight) {
          const vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
          return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
        };
        const sqrtPath = function(size, extraVinculum, viewBoxHeight) {
          extraVinculum = 1e3 * extraVinculum;
          let path2 = "";
          switch (size) {
            case "sqrtMain":
              path2 = sqrtMain(extraVinculum, hLinePad);
              break;
            case "sqrtSize1":
              path2 = sqrtSize1(extraVinculum, hLinePad);
              break;
            case "sqrtSize2":
              path2 = sqrtSize2(extraVinculum, hLinePad);
              break;
            case "sqrtSize3":
              path2 = sqrtSize3(extraVinculum, hLinePad);
              break;
            case "sqrtSize4":
              path2 = sqrtSize4(extraVinculum, hLinePad);
              break;
            case "sqrtTall":
              path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
          }
          return path2;
        };
        const innerPath = function(name, height) {
          switch (name) {
            case "\u239C":
              return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
            case "\u2223":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
            case "\u2225":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
            case "\u239F":
              return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
            case "\u23A2":
              return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
            case "\u23A5":
              return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
            case "\u23AA":
              return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
            case "\u23D0":
              return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
            case "\u2016":
              return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
            default:
              return "";
          }
        };
        const path = {
          doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
          doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
          leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
          leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
          leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
          leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
          leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
          leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
          leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
          leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
          leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
          lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
          leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
          leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
          leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
          longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
          midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
          midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
          oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
          oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
          oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
          oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
          rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
          rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
          rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
          rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
          rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
          rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
          rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
          rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
          rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
          righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
          rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
          rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
          twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
          twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
          tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
          tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
          tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
          tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
          vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
          widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
          widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
          widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
          rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
          baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
          rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
          shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
          shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
        };
        const tallDelim = function(label, midHeight) {
          switch (label) {
            case "lbrack":
              return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
            case "rbrack":
              return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
            case "vert":
              return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
            case "doublevert":
              return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
            case "lfloor":
              return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
            case "rfloor":
              return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
            case "lceil":
              return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
            case "rceil":
              return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
            case "lparen":
              return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
            case "rparen":
              return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
            default:
              throw new Error("Unknown stretchy delimiter.");
          }
        };
        ;
        var fontMetricsData = {
          "AMS-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68889, 0, 0, 0.72222],
            "66": [0, 0.68889, 0, 0, 0.66667],
            "67": [0, 0.68889, 0, 0, 0.72222],
            "68": [0, 0.68889, 0, 0, 0.72222],
            "69": [0, 0.68889, 0, 0, 0.66667],
            "70": [0, 0.68889, 0, 0, 0.61111],
            "71": [0, 0.68889, 0, 0, 0.77778],
            "72": [0, 0.68889, 0, 0, 0.77778],
            "73": [0, 0.68889, 0, 0, 0.38889],
            "74": [0.16667, 0.68889, 0, 0, 0.5],
            "75": [0, 0.68889, 0, 0, 0.77778],
            "76": [0, 0.68889, 0, 0, 0.66667],
            "77": [0, 0.68889, 0, 0, 0.94445],
            "78": [0, 0.68889, 0, 0, 0.72222],
            "79": [0.16667, 0.68889, 0, 0, 0.77778],
            "80": [0, 0.68889, 0, 0, 0.61111],
            "81": [0.16667, 0.68889, 0, 0, 0.77778],
            "82": [0, 0.68889, 0, 0, 0.72222],
            "83": [0, 0.68889, 0, 0, 0.55556],
            "84": [0, 0.68889, 0, 0, 0.66667],
            "85": [0, 0.68889, 0, 0, 0.72222],
            "86": [0, 0.68889, 0, 0, 0.72222],
            "87": [0, 0.68889, 0, 0, 1],
            "88": [0, 0.68889, 0, 0, 0.72222],
            "89": [0, 0.68889, 0, 0, 0.72222],
            "90": [0, 0.68889, 0, 0, 0.66667],
            "107": [0, 0.68889, 0, 0, 0.55556],
            "160": [0, 0, 0, 0, 0.25],
            "165": [0, 0.675, 0.025, 0, 0.75],
            "174": [0.15559, 0.69224, 0, 0, 0.94666],
            "240": [0, 0.68889, 0, 0, 0.55556],
            "295": [0, 0.68889, 0, 0, 0.54028],
            "710": [0, 0.825, 0, 0, 2.33334],
            "732": [0, 0.9, 0, 0, 2.33334],
            "770": [0, 0.825, 0, 0, 2.33334],
            "771": [0, 0.9, 0, 0, 2.33334],
            "989": [0.08167, 0.58167, 0, 0, 0.77778],
            "1008": [0, 0.43056, 0.04028, 0, 0.66667],
            "8245": [0, 0.54986, 0, 0, 0.275],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8487": [0, 0.68889, 0, 0, 0.72222],
            "8498": [0, 0.68889, 0, 0, 0.55556],
            "8502": [0, 0.68889, 0, 0, 0.66667],
            "8503": [0, 0.68889, 0, 0, 0.44445],
            "8504": [0, 0.68889, 0, 0, 0.66667],
            "8513": [0, 0.68889, 0, 0, 0.63889],
            "8592": [-0.03598, 0.46402, 0, 0, 0.5],
            "8594": [-0.03598, 0.46402, 0, 0, 0.5],
            "8602": [-0.13313, 0.36687, 0, 0, 1],
            "8603": [-0.13313, 0.36687, 0, 0, 1],
            "8606": [0.01354, 0.52239, 0, 0, 1],
            "8608": [0.01354, 0.52239, 0, 0, 1],
            "8610": [0.01354, 0.52239, 0, 0, 1.11111],
            "8611": [0.01354, 0.52239, 0, 0, 1.11111],
            "8619": [0, 0.54986, 0, 0, 1],
            "8620": [0, 0.54986, 0, 0, 1],
            "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
            "8622": [-0.13313, 0.36687, 0, 0, 1],
            "8624": [0, 0.69224, 0, 0, 0.5],
            "8625": [0, 0.69224, 0, 0, 0.5],
            "8630": [0, 0.43056, 0, 0, 1],
            "8631": [0, 0.43056, 0, 0, 1],
            "8634": [0.08198, 0.58198, 0, 0, 0.77778],
            "8635": [0.08198, 0.58198, 0, 0, 0.77778],
            "8638": [0.19444, 0.69224, 0, 0, 0.41667],
            "8639": [0.19444, 0.69224, 0, 0, 0.41667],
            "8642": [0.19444, 0.69224, 0, 0, 0.41667],
            "8643": [0.19444, 0.69224, 0, 0, 0.41667],
            "8644": [0.1808, 0.675, 0, 0, 1],
            "8646": [0.1808, 0.675, 0, 0, 1],
            "8647": [0.1808, 0.675, 0, 0, 1],
            "8648": [0.19444, 0.69224, 0, 0, 0.83334],
            "8649": [0.1808, 0.675, 0, 0, 1],
            "8650": [0.19444, 0.69224, 0, 0, 0.83334],
            "8651": [0.01354, 0.52239, 0, 0, 1],
            "8652": [0.01354, 0.52239, 0, 0, 1],
            "8653": [-0.13313, 0.36687, 0, 0, 1],
            "8654": [-0.13313, 0.36687, 0, 0, 1],
            "8655": [-0.13313, 0.36687, 0, 0, 1],
            "8666": [0.13667, 0.63667, 0, 0, 1],
            "8667": [0.13667, 0.63667, 0, 0, 1],
            "8669": [-0.13313, 0.37788, 0, 0, 1],
            "8672": [-0.064, 0.437, 0, 0, 1.334],
            "8674": [-0.064, 0.437, 0, 0, 1.334],
            "8705": [0, 0.825, 0, 0, 0.5],
            "8708": [0, 0.68889, 0, 0, 0.55556],
            "8709": [0.08167, 0.58167, 0, 0, 0.77778],
            "8717": [0, 0.43056, 0, 0, 0.42917],
            "8722": [-0.03598, 0.46402, 0, 0, 0.5],
            "8724": [0.08198, 0.69224, 0, 0, 0.77778],
            "8726": [0.08167, 0.58167, 0, 0, 0.77778],
            "8733": [0, 0.69224, 0, 0, 0.77778],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8737": [0, 0.69224, 0, 0, 0.72222],
            "8738": [0.03517, 0.52239, 0, 0, 0.72222],
            "8739": [0.08167, 0.58167, 0, 0, 0.22222],
            "8740": [0.25142, 0.74111, 0, 0, 0.27778],
            "8741": [0.08167, 0.58167, 0, 0, 0.38889],
            "8742": [0.25142, 0.74111, 0, 0, 0.5],
            "8756": [0, 0.69224, 0, 0, 0.66667],
            "8757": [0, 0.69224, 0, 0, 0.66667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
            "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8774": [0.30274, 0.79383, 0, 0, 0.77778],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8778": [0.08167, 0.58167, 0, 0, 0.77778],
            "8782": [0.06062, 0.54986, 0, 0, 0.77778],
            "8783": [0.06062, 0.54986, 0, 0, 0.77778],
            "8785": [0.08198, 0.58198, 0, 0, 0.77778],
            "8786": [0.08198, 0.58198, 0, 0, 0.77778],
            "8787": [0.08198, 0.58198, 0, 0, 0.77778],
            "8790": [0, 0.69224, 0, 0, 0.77778],
            "8791": [0.22958, 0.72958, 0, 0, 0.77778],
            "8796": [0.08198, 0.91667, 0, 0, 0.77778],
            "8806": [0.25583, 0.75583, 0, 0, 0.77778],
            "8807": [0.25583, 0.75583, 0, 0, 0.77778],
            "8808": [0.25142, 0.75726, 0, 0, 0.77778],
            "8809": [0.25142, 0.75726, 0, 0, 0.77778],
            "8812": [0.25583, 0.75583, 0, 0, 0.5],
            "8814": [0.20576, 0.70576, 0, 0, 0.77778],
            "8815": [0.20576, 0.70576, 0, 0, 0.77778],
            "8816": [0.30274, 0.79383, 0, 0, 0.77778],
            "8817": [0.30274, 0.79383, 0, 0, 0.77778],
            "8818": [0.22958, 0.72958, 0, 0, 0.77778],
            "8819": [0.22958, 0.72958, 0, 0, 0.77778],
            "8822": [0.1808, 0.675, 0, 0, 0.77778],
            "8823": [0.1808, 0.675, 0, 0, 0.77778],
            "8828": [0.13667, 0.63667, 0, 0, 0.77778],
            "8829": [0.13667, 0.63667, 0, 0, 0.77778],
            "8830": [0.22958, 0.72958, 0, 0, 0.77778],
            "8831": [0.22958, 0.72958, 0, 0, 0.77778],
            "8832": [0.20576, 0.70576, 0, 0, 0.77778],
            "8833": [0.20576, 0.70576, 0, 0, 0.77778],
            "8840": [0.30274, 0.79383, 0, 0, 0.77778],
            "8841": [0.30274, 0.79383, 0, 0, 0.77778],
            "8842": [0.13597, 0.63597, 0, 0, 0.77778],
            "8843": [0.13597, 0.63597, 0, 0, 0.77778],
            "8847": [0.03517, 0.54986, 0, 0, 0.77778],
            "8848": [0.03517, 0.54986, 0, 0, 0.77778],
            "8858": [0.08198, 0.58198, 0, 0, 0.77778],
            "8859": [0.08198, 0.58198, 0, 0, 0.77778],
            "8861": [0.08198, 0.58198, 0, 0, 0.77778],
            "8862": [0, 0.675, 0, 0, 0.77778],
            "8863": [0, 0.675, 0, 0, 0.77778],
            "8864": [0, 0.675, 0, 0, 0.77778],
            "8865": [0, 0.675, 0, 0, 0.77778],
            "8872": [0, 0.69224, 0, 0, 0.61111],
            "8873": [0, 0.69224, 0, 0, 0.72222],
            "8874": [0, 0.69224, 0, 0, 0.88889],
            "8876": [0, 0.68889, 0, 0, 0.61111],
            "8877": [0, 0.68889, 0, 0, 0.61111],
            "8878": [0, 0.68889, 0, 0, 0.72222],
            "8879": [0, 0.68889, 0, 0, 0.72222],
            "8882": [0.03517, 0.54986, 0, 0, 0.77778],
            "8883": [0.03517, 0.54986, 0, 0, 0.77778],
            "8884": [0.13667, 0.63667, 0, 0, 0.77778],
            "8885": [0.13667, 0.63667, 0, 0, 0.77778],
            "8888": [0, 0.54986, 0, 0, 1.11111],
            "8890": [0.19444, 0.43056, 0, 0, 0.55556],
            "8891": [0.19444, 0.69224, 0, 0, 0.61111],
            "8892": [0.19444, 0.69224, 0, 0, 0.61111],
            "8901": [0, 0.54986, 0, 0, 0.27778],
            "8903": [0.08167, 0.58167, 0, 0, 0.77778],
            "8905": [0.08167, 0.58167, 0, 0, 0.77778],
            "8906": [0.08167, 0.58167, 0, 0, 0.77778],
            "8907": [0, 0.69224, 0, 0, 0.77778],
            "8908": [0, 0.69224, 0, 0, 0.77778],
            "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
            "8910": [0, 0.54986, 0, 0, 0.76042],
            "8911": [0, 0.54986, 0, 0, 0.76042],
            "8912": [0.03517, 0.54986, 0, 0, 0.77778],
            "8913": [0.03517, 0.54986, 0, 0, 0.77778],
            "8914": [0, 0.54986, 0, 0, 0.66667],
            "8915": [0, 0.54986, 0, 0, 0.66667],
            "8916": [0, 0.69224, 0, 0, 0.66667],
            "8918": [0.0391, 0.5391, 0, 0, 0.77778],
            "8919": [0.0391, 0.5391, 0, 0, 0.77778],
            "8920": [0.03517, 0.54986, 0, 0, 1.33334],
            "8921": [0.03517, 0.54986, 0, 0, 1.33334],
            "8922": [0.38569, 0.88569, 0, 0, 0.77778],
            "8923": [0.38569, 0.88569, 0, 0, 0.77778],
            "8926": [0.13667, 0.63667, 0, 0, 0.77778],
            "8927": [0.13667, 0.63667, 0, 0, 0.77778],
            "8928": [0.30274, 0.79383, 0, 0, 0.77778],
            "8929": [0.30274, 0.79383, 0, 0, 0.77778],
            "8934": [0.23222, 0.74111, 0, 0, 0.77778],
            "8935": [0.23222, 0.74111, 0, 0, 0.77778],
            "8936": [0.23222, 0.74111, 0, 0, 0.77778],
            "8937": [0.23222, 0.74111, 0, 0, 0.77778],
            "8938": [0.20576, 0.70576, 0, 0, 0.77778],
            "8939": [0.20576, 0.70576, 0, 0, 0.77778],
            "8940": [0.30274, 0.79383, 0, 0, 0.77778],
            "8941": [0.30274, 0.79383, 0, 0, 0.77778],
            "8994": [0.19444, 0.69224, 0, 0, 0.77778],
            "8995": [0.19444, 0.69224, 0, 0, 0.77778],
            "9416": [0.15559, 0.69224, 0, 0, 0.90222],
            "9484": [0, 0.69224, 0, 0, 0.5],
            "9488": [0, 0.69224, 0, 0, 0.5],
            "9492": [0, 0.37788, 0, 0, 0.5],
            "9496": [0, 0.37788, 0, 0, 0.5],
            "9585": [0.19444, 0.68889, 0, 0, 0.88889],
            "9586": [0.19444, 0.74111, 0, 0, 0.88889],
            "9632": [0, 0.675, 0, 0, 0.77778],
            "9633": [0, 0.675, 0, 0, 0.77778],
            "9650": [0, 0.54986, 0, 0, 0.72222],
            "9651": [0, 0.54986, 0, 0, 0.72222],
            "9654": [0.03517, 0.54986, 0, 0, 0.77778],
            "9660": [0, 0.54986, 0, 0, 0.72222],
            "9661": [0, 0.54986, 0, 0, 0.72222],
            "9664": [0.03517, 0.54986, 0, 0, 0.77778],
            "9674": [0.11111, 0.69224, 0, 0, 0.66667],
            "9733": [0.19444, 0.69224, 0, 0, 0.94445],
            "10003": [0, 0.69224, 0, 0, 0.83334],
            "10016": [0, 0.69224, 0, 0, 0.83334],
            "10731": [0.11111, 0.69224, 0, 0, 0.66667],
            "10846": [0.19444, 0.75583, 0, 0, 0.61111],
            "10877": [0.13667, 0.63667, 0, 0, 0.77778],
            "10878": [0.13667, 0.63667, 0, 0, 0.77778],
            "10885": [0.25583, 0.75583, 0, 0, 0.77778],
            "10886": [0.25583, 0.75583, 0, 0, 0.77778],
            "10887": [0.13597, 0.63597, 0, 0, 0.77778],
            "10888": [0.13597, 0.63597, 0, 0, 0.77778],
            "10889": [0.26167, 0.75726, 0, 0, 0.77778],
            "10890": [0.26167, 0.75726, 0, 0, 0.77778],
            "10891": [0.48256, 0.98256, 0, 0, 0.77778],
            "10892": [0.48256, 0.98256, 0, 0, 0.77778],
            "10901": [0.13667, 0.63667, 0, 0, 0.77778],
            "10902": [0.13667, 0.63667, 0, 0, 0.77778],
            "10933": [0.25142, 0.75726, 0, 0, 0.77778],
            "10934": [0.25142, 0.75726, 0, 0, 0.77778],
            "10935": [0.26167, 0.75726, 0, 0, 0.77778],
            "10936": [0.26167, 0.75726, 0, 0, 0.77778],
            "10937": [0.26167, 0.75726, 0, 0, 0.77778],
            "10938": [0.26167, 0.75726, 0, 0, 0.77778],
            "10949": [0.25583, 0.75583, 0, 0, 0.77778],
            "10950": [0.25583, 0.75583, 0, 0, 0.77778],
            "10955": [0.28481, 0.79383, 0, 0, 0.77778],
            "10956": [0.28481, 0.79383, 0, 0, 0.77778],
            "57350": [0.08167, 0.58167, 0, 0, 0.22222],
            "57351": [0.08167, 0.58167, 0, 0, 0.38889],
            "57352": [0.08167, 0.58167, 0, 0, 0.77778],
            "57353": [0, 0.43056, 0.04028, 0, 0.66667],
            "57356": [0.25142, 0.75726, 0, 0, 0.77778],
            "57357": [0.25142, 0.75726, 0, 0, 0.77778],
            "57358": [0.41951, 0.91951, 0, 0, 0.77778],
            "57359": [0.30274, 0.79383, 0, 0, 0.77778],
            "57360": [0.30274, 0.79383, 0, 0, 0.77778],
            "57361": [0.41951, 0.91951, 0, 0, 0.77778],
            "57366": [0.25142, 0.75726, 0, 0, 0.77778],
            "57367": [0.25142, 0.75726, 0, 0, 0.77778],
            "57368": [0.25142, 0.75726, 0, 0, 0.77778],
            "57369": [0.25142, 0.75726, 0, 0, 0.77778],
            "57370": [0.13597, 0.63597, 0, 0, 0.77778],
            "57371": [0.13597, 0.63597, 0, 0, 0.77778]
          },
          "Caligraphic-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68333, 0, 0.19445, 0.79847],
            "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
            "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
            "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
            "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
            "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
            "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
            "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
            "73": [0, 0.68333, 0.07382, 0, 0.54452],
            "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
            "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
            "76": [0, 0.68333, 0, 0.13889, 0.68972],
            "77": [0, 0.68333, 0, 0.13889, 1.2009],
            "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
            "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
            "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
            "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
            "82": [0, 0.68333, 0, 0.08334, 0.8475],
            "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
            "84": [0, 0.68333, 0.25417, 0, 0.54464],
            "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
            "86": [0, 0.68333, 0.08222, 0, 0.61278],
            "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
            "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
            "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
            "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Fraktur-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69141, 0, 0, 0.29574],
            "34": [0, 0.69141, 0, 0, 0.21471],
            "38": [0, 0.69141, 0, 0, 0.73786],
            "39": [0, 0.69141, 0, 0, 0.21201],
            "40": [0.24982, 0.74947, 0, 0, 0.38865],
            "41": [0.24982, 0.74947, 0, 0, 0.38865],
            "42": [0, 0.62119, 0, 0, 0.27764],
            "43": [0.08319, 0.58283, 0, 0, 0.75623],
            "44": [0, 0.10803, 0, 0, 0.27764],
            "45": [0.08319, 0.58283, 0, 0, 0.75623],
            "46": [0, 0.10803, 0, 0, 0.27764],
            "47": [0.24982, 0.74947, 0, 0, 0.50181],
            "48": [0, 0.47534, 0, 0, 0.50181],
            "49": [0, 0.47534, 0, 0, 0.50181],
            "50": [0, 0.47534, 0, 0, 0.50181],
            "51": [0.18906, 0.47534, 0, 0, 0.50181],
            "52": [0.18906, 0.47534, 0, 0, 0.50181],
            "53": [0.18906, 0.47534, 0, 0, 0.50181],
            "54": [0, 0.69141, 0, 0, 0.50181],
            "55": [0.18906, 0.47534, 0, 0, 0.50181],
            "56": [0, 0.69141, 0, 0, 0.50181],
            "57": [0.18906, 0.47534, 0, 0, 0.50181],
            "58": [0, 0.47534, 0, 0, 0.21606],
            "59": [0.12604, 0.47534, 0, 0, 0.21606],
            "61": [-0.13099, 0.36866, 0, 0, 0.75623],
            "63": [0, 0.69141, 0, 0, 0.36245],
            "65": [0, 0.69141, 0, 0, 0.7176],
            "66": [0, 0.69141, 0, 0, 0.88397],
            "67": [0, 0.69141, 0, 0, 0.61254],
            "68": [0, 0.69141, 0, 0, 0.83158],
            "69": [0, 0.69141, 0, 0, 0.66278],
            "70": [0.12604, 0.69141, 0, 0, 0.61119],
            "71": [0, 0.69141, 0, 0, 0.78539],
            "72": [0.06302, 0.69141, 0, 0, 0.7203],
            "73": [0, 0.69141, 0, 0, 0.55448],
            "74": [0.12604, 0.69141, 0, 0, 0.55231],
            "75": [0, 0.69141, 0, 0, 0.66845],
            "76": [0, 0.69141, 0, 0, 0.66602],
            "77": [0, 0.69141, 0, 0, 1.04953],
            "78": [0, 0.69141, 0, 0, 0.83212],
            "79": [0, 0.69141, 0, 0, 0.82699],
            "80": [0.18906, 0.69141, 0, 0, 0.82753],
            "81": [0.03781, 0.69141, 0, 0, 0.82699],
            "82": [0, 0.69141, 0, 0, 0.82807],
            "83": [0, 0.69141, 0, 0, 0.82861],
            "84": [0, 0.69141, 0, 0, 0.66899],
            "85": [0, 0.69141, 0, 0, 0.64576],
            "86": [0, 0.69141, 0, 0, 0.83131],
            "87": [0, 0.69141, 0, 0, 1.04602],
            "88": [0, 0.69141, 0, 0, 0.71922],
            "89": [0.18906, 0.69141, 0, 0, 0.83293],
            "90": [0.12604, 0.69141, 0, 0, 0.60201],
            "91": [0.24982, 0.74947, 0, 0, 0.27764],
            "93": [0.24982, 0.74947, 0, 0, 0.27764],
            "94": [0, 0.69141, 0, 0, 0.49965],
            "97": [0, 0.47534, 0, 0, 0.50046],
            "98": [0, 0.69141, 0, 0, 0.51315],
            "99": [0, 0.47534, 0, 0, 0.38946],
            "100": [0, 0.62119, 0, 0, 0.49857],
            "101": [0, 0.47534, 0, 0, 0.40053],
            "102": [0.18906, 0.69141, 0, 0, 0.32626],
            "103": [0.18906, 0.47534, 0, 0, 0.5037],
            "104": [0.18906, 0.69141, 0, 0, 0.52126],
            "105": [0, 0.69141, 0, 0, 0.27899],
            "106": [0, 0.69141, 0, 0, 0.28088],
            "107": [0, 0.69141, 0, 0, 0.38946],
            "108": [0, 0.69141, 0, 0, 0.27953],
            "109": [0, 0.47534, 0, 0, 0.76676],
            "110": [0, 0.47534, 0, 0, 0.52666],
            "111": [0, 0.47534, 0, 0, 0.48885],
            "112": [0.18906, 0.52396, 0, 0, 0.50046],
            "113": [0.18906, 0.47534, 0, 0, 0.48912],
            "114": [0, 0.47534, 0, 0, 0.38919],
            "115": [0, 0.47534, 0, 0, 0.44266],
            "116": [0, 0.62119, 0, 0, 0.33301],
            "117": [0, 0.47534, 0, 0, 0.5172],
            "118": [0, 0.52396, 0, 0, 0.5118],
            "119": [0, 0.52396, 0, 0, 0.77351],
            "120": [0.18906, 0.47534, 0, 0, 0.38865],
            "121": [0.18906, 0.47534, 0, 0, 0.49884],
            "122": [0.18906, 0.47534, 0, 0, 0.39054],
            "160": [0, 0, 0, 0, 0.25],
            "8216": [0, 0.69141, 0, 0, 0.21471],
            "8217": [0, 0.69141, 0, 0, 0.21471],
            "58112": [0, 0.62119, 0, 0, 0.49749],
            "58113": [0, 0.62119, 0, 0, 0.4983],
            "58114": [0.18906, 0.69141, 0, 0, 0.33328],
            "58115": [0.18906, 0.69141, 0, 0, 0.32923],
            "58116": [0.18906, 0.47534, 0, 0, 0.50343],
            "58117": [0, 0.69141, 0, 0, 0.33301],
            "58118": [0, 0.62119, 0, 0, 0.33409],
            "58119": [0, 0.47534, 0, 0, 0.50073]
          },
          "Main-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.35],
            "34": [0, 0.69444, 0, 0, 0.60278],
            "35": [0.19444, 0.69444, 0, 0, 0.95833],
            "36": [0.05556, 0.75, 0, 0, 0.575],
            "37": [0.05556, 0.75, 0, 0, 0.95833],
            "38": [0, 0.69444, 0, 0, 0.89444],
            "39": [0, 0.69444, 0, 0, 0.31944],
            "40": [0.25, 0.75, 0, 0, 0.44722],
            "41": [0.25, 0.75, 0, 0, 0.44722],
            "42": [0, 0.75, 0, 0, 0.575],
            "43": [0.13333, 0.63333, 0, 0, 0.89444],
            "44": [0.19444, 0.15556, 0, 0, 0.31944],
            "45": [0, 0.44444, 0, 0, 0.38333],
            "46": [0, 0.15556, 0, 0, 0.31944],
            "47": [0.25, 0.75, 0, 0, 0.575],
            "48": [0, 0.64444, 0, 0, 0.575],
            "49": [0, 0.64444, 0, 0, 0.575],
            "50": [0, 0.64444, 0, 0, 0.575],
            "51": [0, 0.64444, 0, 0, 0.575],
            "52": [0, 0.64444, 0, 0, 0.575],
            "53": [0, 0.64444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0, 0.64444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0, 0.64444, 0, 0, 0.575],
            "58": [0, 0.44444, 0, 0, 0.31944],
            "59": [0.19444, 0.44444, 0, 0, 0.31944],
            "60": [0.08556, 0.58556, 0, 0, 0.89444],
            "61": [-0.10889, 0.39111, 0, 0, 0.89444],
            "62": [0.08556, 0.58556, 0, 0, 0.89444],
            "63": [0, 0.69444, 0, 0, 0.54305],
            "64": [0, 0.69444, 0, 0, 0.89444],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0, 0, 0.81805],
            "67": [0, 0.68611, 0, 0, 0.83055],
            "68": [0, 0.68611, 0, 0, 0.88194],
            "69": [0, 0.68611, 0, 0, 0.75555],
            "70": [0, 0.68611, 0, 0, 0.72361],
            "71": [0, 0.68611, 0, 0, 0.90416],
            "72": [0, 0.68611, 0, 0, 0.9],
            "73": [0, 0.68611, 0, 0, 0.43611],
            "74": [0, 0.68611, 0, 0, 0.59444],
            "75": [0, 0.68611, 0, 0, 0.90138],
            "76": [0, 0.68611, 0, 0, 0.69166],
            "77": [0, 0.68611, 0, 0, 1.09166],
            "78": [0, 0.68611, 0, 0, 0.9],
            "79": [0, 0.68611, 0, 0, 0.86388],
            "80": [0, 0.68611, 0, 0, 0.78611],
            "81": [0.19444, 0.68611, 0, 0, 0.86388],
            "82": [0, 0.68611, 0, 0, 0.8625],
            "83": [0, 0.68611, 0, 0, 0.63889],
            "84": [0, 0.68611, 0, 0, 0.8],
            "85": [0, 0.68611, 0, 0, 0.88472],
            "86": [0, 0.68611, 0.01597, 0, 0.86944],
            "87": [0, 0.68611, 0.01597, 0, 1.18888],
            "88": [0, 0.68611, 0, 0, 0.86944],
            "89": [0, 0.68611, 0.02875, 0, 0.86944],
            "90": [0, 0.68611, 0, 0, 0.70277],
            "91": [0.25, 0.75, 0, 0, 0.31944],
            "92": [0.25, 0.75, 0, 0, 0.575],
            "93": [0.25, 0.75, 0, 0, 0.31944],
            "94": [0, 0.69444, 0, 0, 0.575],
            "95": [0.31, 0.13444, 0.03194, 0, 0.575],
            "97": [0, 0.44444, 0, 0, 0.55902],
            "98": [0, 0.69444, 0, 0, 0.63889],
            "99": [0, 0.44444, 0, 0, 0.51111],
            "100": [0, 0.69444, 0, 0, 0.63889],
            "101": [0, 0.44444, 0, 0, 0.52708],
            "102": [0, 0.69444, 0.10903, 0, 0.35139],
            "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
            "104": [0, 0.69444, 0, 0, 0.63889],
            "105": [0, 0.69444, 0, 0, 0.31944],
            "106": [0.19444, 0.69444, 0, 0, 0.35139],
            "107": [0, 0.69444, 0, 0, 0.60694],
            "108": [0, 0.69444, 0, 0, 0.31944],
            "109": [0, 0.44444, 0, 0, 0.95833],
            "110": [0, 0.44444, 0, 0, 0.63889],
            "111": [0, 0.44444, 0, 0, 0.575],
            "112": [0.19444, 0.44444, 0, 0, 0.63889],
            "113": [0.19444, 0.44444, 0, 0, 0.60694],
            "114": [0, 0.44444, 0, 0, 0.47361],
            "115": [0, 0.44444, 0, 0, 0.45361],
            "116": [0, 0.63492, 0, 0, 0.44722],
            "117": [0, 0.44444, 0, 0, 0.63889],
            "118": [0, 0.44444, 0.01597, 0, 0.60694],
            "119": [0, 0.44444, 0.01597, 0, 0.83055],
            "120": [0, 0.44444, 0, 0, 0.60694],
            "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
            "122": [0, 0.44444, 0, 0, 0.51111],
            "123": [0.25, 0.75, 0, 0, 0.575],
            "124": [0.25, 0.75, 0, 0, 0.31944],
            "125": [0.25, 0.75, 0, 0, 0.575],
            "126": [0.35, 0.34444, 0, 0, 0.575],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.86853],
            "168": [0, 0.69444, 0, 0, 0.575],
            "172": [0, 0.44444, 0, 0, 0.76666],
            "176": [0, 0.69444, 0, 0, 0.86944],
            "177": [0.13333, 0.63333, 0, 0, 0.89444],
            "184": [0.17014, 0, 0, 0, 0.51111],
            "198": [0, 0.68611, 0, 0, 1.04166],
            "215": [0.13333, 0.63333, 0, 0, 0.89444],
            "216": [0.04861, 0.73472, 0, 0, 0.89444],
            "223": [0, 0.69444, 0, 0, 0.59722],
            "230": [0, 0.44444, 0, 0, 0.83055],
            "247": [0.13333, 0.63333, 0, 0, 0.89444],
            "248": [0.09722, 0.54167, 0, 0, 0.575],
            "305": [0, 0.44444, 0, 0, 0.31944],
            "338": [0, 0.68611, 0, 0, 1.16944],
            "339": [0, 0.44444, 0, 0, 0.89444],
            "567": [0.19444, 0.44444, 0, 0, 0.35139],
            "710": [0, 0.69444, 0, 0, 0.575],
            "711": [0, 0.63194, 0, 0, 0.575],
            "713": [0, 0.59611, 0, 0, 0.575],
            "714": [0, 0.69444, 0, 0, 0.575],
            "715": [0, 0.69444, 0, 0, 0.575],
            "728": [0, 0.69444, 0, 0, 0.575],
            "729": [0, 0.69444, 0, 0, 0.31944],
            "730": [0, 0.69444, 0, 0, 0.86944],
            "732": [0, 0.69444, 0, 0, 0.575],
            "733": [0, 0.69444, 0, 0, 0.575],
            "915": [0, 0.68611, 0, 0, 0.69166],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0, 0, 0.89444],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0, 0, 0.76666],
            "928": [0, 0.68611, 0, 0, 0.9],
            "931": [0, 0.68611, 0, 0, 0.83055],
            "933": [0, 0.68611, 0, 0, 0.89444],
            "934": [0, 0.68611, 0, 0, 0.83055],
            "936": [0, 0.68611, 0, 0, 0.89444],
            "937": [0, 0.68611, 0, 0, 0.83055],
            "8211": [0, 0.44444, 0.03194, 0, 0.575],
            "8212": [0, 0.44444, 0.03194, 0, 1.14999],
            "8216": [0, 0.69444, 0, 0, 0.31944],
            "8217": [0, 0.69444, 0, 0, 0.31944],
            "8220": [0, 0.69444, 0, 0, 0.60278],
            "8221": [0, 0.69444, 0, 0, 0.60278],
            "8224": [0.19444, 0.69444, 0, 0, 0.51111],
            "8225": [0.19444, 0.69444, 0, 0, 0.51111],
            "8242": [0, 0.55556, 0, 0, 0.34444],
            "8407": [0, 0.72444, 0.15486, 0, 0.575],
            "8463": [0, 0.69444, 0, 0, 0.66759],
            "8465": [0, 0.69444, 0, 0, 0.83055],
            "8467": [0, 0.69444, 0, 0, 0.47361],
            "8472": [0.19444, 0.44444, 0, 0, 0.74027],
            "8476": [0, 0.69444, 0, 0, 0.83055],
            "8501": [0, 0.69444, 0, 0, 0.70277],
            "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8593": [0.19444, 0.69444, 0, 0, 0.575],
            "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8595": [0.19444, 0.69444, 0, 0, 0.575],
            "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8597": [0.25, 0.75, 0, 0, 0.575],
            "8598": [0.19444, 0.69444, 0, 0, 1.14999],
            "8599": [0.19444, 0.69444, 0, 0, 1.14999],
            "8600": [0.19444, 0.69444, 0, 0, 1.14999],
            "8601": [0.19444, 0.69444, 0, 0, 1.14999],
            "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8657": [0.19444, 0.69444, 0, 0, 0.70277],
            "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8659": [0.19444, 0.69444, 0, 0, 0.70277],
            "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8661": [0.25, 0.75, 0, 0, 0.70277],
            "8704": [0, 0.69444, 0, 0, 0.63889],
            "8706": [0, 0.69444, 0.06389, 0, 0.62847],
            "8707": [0, 0.69444, 0, 0, 0.63889],
            "8709": [0.05556, 0.75, 0, 0, 0.575],
            "8711": [0, 0.68611, 0, 0, 0.95833],
            "8712": [0.08556, 0.58556, 0, 0, 0.76666],
            "8715": [0.08556, 0.58556, 0, 0, 0.76666],
            "8722": [0.13333, 0.63333, 0, 0, 0.89444],
            "8723": [0.13333, 0.63333, 0, 0, 0.89444],
            "8725": [0.25, 0.75, 0, 0, 0.575],
            "8726": [0.25, 0.75, 0, 0, 0.575],
            "8727": [-0.02778, 0.47222, 0, 0, 0.575],
            "8728": [-0.02639, 0.47361, 0, 0, 0.575],
            "8729": [-0.02639, 0.47361, 0, 0, 0.575],
            "8730": [0.18, 0.82, 0, 0, 0.95833],
            "8733": [0, 0.44444, 0, 0, 0.89444],
            "8734": [0, 0.44444, 0, 0, 1.14999],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.31944],
            "8741": [0.25, 0.75, 0, 0, 0.575],
            "8743": [0, 0.55556, 0, 0, 0.76666],
            "8744": [0, 0.55556, 0, 0, 0.76666],
            "8745": [0, 0.55556, 0, 0, 0.76666],
            "8746": [0, 0.55556, 0, 0, 0.76666],
            "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
            "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
            "8768": [0.19444, 0.69444, 0, 0, 0.31944],
            "8771": [222e-5, 0.50222, 0, 0, 0.89444],
            "8773": [0.027, 0.638, 0, 0, 0.894],
            "8776": [0.02444, 0.52444, 0, 0, 0.89444],
            "8781": [222e-5, 0.50222, 0, 0, 0.89444],
            "8801": [222e-5, 0.50222, 0, 0, 0.89444],
            "8804": [0.19667, 0.69667, 0, 0, 0.89444],
            "8805": [0.19667, 0.69667, 0, 0, 0.89444],
            "8810": [0.08556, 0.58556, 0, 0, 1.14999],
            "8811": [0.08556, 0.58556, 0, 0, 1.14999],
            "8826": [0.08556, 0.58556, 0, 0, 0.89444],
            "8827": [0.08556, 0.58556, 0, 0, 0.89444],
            "8834": [0.08556, 0.58556, 0, 0, 0.89444],
            "8835": [0.08556, 0.58556, 0, 0, 0.89444],
            "8838": [0.19667, 0.69667, 0, 0, 0.89444],
            "8839": [0.19667, 0.69667, 0, 0, 0.89444],
            "8846": [0, 0.55556, 0, 0, 0.76666],
            "8849": [0.19667, 0.69667, 0, 0, 0.89444],
            "8850": [0.19667, 0.69667, 0, 0, 0.89444],
            "8851": [0, 0.55556, 0, 0, 0.76666],
            "8852": [0, 0.55556, 0, 0, 0.76666],
            "8853": [0.13333, 0.63333, 0, 0, 0.89444],
            "8854": [0.13333, 0.63333, 0, 0, 0.89444],
            "8855": [0.13333, 0.63333, 0, 0, 0.89444],
            "8856": [0.13333, 0.63333, 0, 0, 0.89444],
            "8857": [0.13333, 0.63333, 0, 0, 0.89444],
            "8866": [0, 0.69444, 0, 0, 0.70277],
            "8867": [0, 0.69444, 0, 0, 0.70277],
            "8868": [0, 0.69444, 0, 0, 0.89444],
            "8869": [0, 0.69444, 0, 0, 0.89444],
            "8900": [-0.02639, 0.47361, 0, 0, 0.575],
            "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
            "8902": [-0.02778, 0.47222, 0, 0, 0.575],
            "8968": [0.25, 0.75, 0, 0, 0.51111],
            "8969": [0.25, 0.75, 0, 0, 0.51111],
            "8970": [0.25, 0.75, 0, 0, 0.51111],
            "8971": [0.25, 0.75, 0, 0, 0.51111],
            "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
            "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
            "9651": [0.19444, 0.69444, 0, 0, 1.02222],
            "9657": [-0.02778, 0.47222, 0, 0, 0.575],
            "9661": [0.19444, 0.69444, 0, 0, 1.02222],
            "9667": [-0.02778, 0.47222, 0, 0, 0.575],
            "9711": [0.19444, 0.69444, 0, 0, 1.14999],
            "9824": [0.12963, 0.69444, 0, 0, 0.89444],
            "9825": [0.12963, 0.69444, 0, 0, 0.89444],
            "9826": [0.12963, 0.69444, 0, 0, 0.89444],
            "9827": [0.12963, 0.69444, 0, 0, 0.89444],
            "9837": [0, 0.75, 0, 0, 0.44722],
            "9838": [0.19444, 0.69444, 0, 0, 0.44722],
            "9839": [0.19444, 0.69444, 0, 0, 0.44722],
            "10216": [0.25, 0.75, 0, 0, 0.44722],
            "10217": [0.25, 0.75, 0, 0, 0.44722],
            "10815": [0, 0.68611, 0, 0, 0.9],
            "10927": [0.19667, 0.69667, 0, 0, 0.89444],
            "10928": [0.19667, 0.69667, 0, 0, 0.89444],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Main-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.11417, 0, 0.38611],
            "34": [0, 0.69444, 0.07939, 0, 0.62055],
            "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
            "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
            "38": [0, 0.69444, 0.08528, 0, 0.88555],
            "39": [0, 0.69444, 0.12945, 0, 0.35555],
            "40": [0.25, 0.75, 0.15806, 0, 0.47333],
            "41": [0.25, 0.75, 0.03306, 0, 0.47333],
            "42": [0, 0.75, 0.14333, 0, 0.59111],
            "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
            "44": [0.19444, 0.14722, 0, 0, 0.35555],
            "45": [0, 0.44444, 0.02611, 0, 0.41444],
            "46": [0, 0.14722, 0, 0, 0.35555],
            "47": [0.25, 0.75, 0.15806, 0, 0.59111],
            "48": [0, 0.64444, 0.13167, 0, 0.59111],
            "49": [0, 0.64444, 0.13167, 0, 0.59111],
            "50": [0, 0.64444, 0.13167, 0, 0.59111],
            "51": [0, 0.64444, 0.13167, 0, 0.59111],
            "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "53": [0, 0.64444, 0.13167, 0, 0.59111],
            "54": [0, 0.64444, 0.13167, 0, 0.59111],
            "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "56": [0, 0.64444, 0.13167, 0, 0.59111],
            "57": [0, 0.64444, 0.13167, 0, 0.59111],
            "58": [0, 0.44444, 0.06695, 0, 0.35555],
            "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
            "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
            "63": [0, 0.69444, 0.11472, 0, 0.59111],
            "64": [0, 0.69444, 0.09208, 0, 0.88555],
            "65": [0, 0.68611, 0, 0, 0.86555],
            "66": [0, 0.68611, 0.0992, 0, 0.81666],
            "67": [0, 0.68611, 0.14208, 0, 0.82666],
            "68": [0, 0.68611, 0.09062, 0, 0.87555],
            "69": [0, 0.68611, 0.11431, 0, 0.75666],
            "70": [0, 0.68611, 0.12903, 0, 0.72722],
            "71": [0, 0.68611, 0.07347, 0, 0.89527],
            "72": [0, 0.68611, 0.17208, 0, 0.8961],
            "73": [0, 0.68611, 0.15681, 0, 0.47166],
            "74": [0, 0.68611, 0.145, 0, 0.61055],
            "75": [0, 0.68611, 0.14208, 0, 0.89499],
            "76": [0, 0.68611, 0, 0, 0.69777],
            "77": [0, 0.68611, 0.17208, 0, 1.07277],
            "78": [0, 0.68611, 0.17208, 0, 0.8961],
            "79": [0, 0.68611, 0.09062, 0, 0.85499],
            "80": [0, 0.68611, 0.0992, 0, 0.78721],
            "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
            "82": [0, 0.68611, 0.02559, 0, 0.85944],
            "83": [0, 0.68611, 0.11264, 0, 0.64999],
            "84": [0, 0.68611, 0.12903, 0, 0.7961],
            "85": [0, 0.68611, 0.17208, 0, 0.88083],
            "86": [0, 0.68611, 0.18625, 0, 0.86555],
            "87": [0, 0.68611, 0.18625, 0, 1.15999],
            "88": [0, 0.68611, 0.15681, 0, 0.86555],
            "89": [0, 0.68611, 0.19803, 0, 0.86555],
            "90": [0, 0.68611, 0.14208, 0, 0.70888],
            "91": [0.25, 0.75, 0.1875, 0, 0.35611],
            "93": [0.25, 0.75, 0.09972, 0, 0.35611],
            "94": [0, 0.69444, 0.06709, 0, 0.59111],
            "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
            "97": [0, 0.44444, 0.09426, 0, 0.59111],
            "98": [0, 0.69444, 0.07861, 0, 0.53222],
            "99": [0, 0.44444, 0.05222, 0, 0.53222],
            "100": [0, 0.69444, 0.10861, 0, 0.59111],
            "101": [0, 0.44444, 0.085, 0, 0.53222],
            "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
            "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "104": [0, 0.69444, 0.09426, 0, 0.59111],
            "105": [0, 0.69326, 0.11387, 0, 0.35555],
            "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
            "107": [0, 0.69444, 0.11111, 0, 0.53222],
            "108": [0, 0.69444, 0.10861, 0, 0.29666],
            "109": [0, 0.44444, 0.09426, 0, 0.94444],
            "110": [0, 0.44444, 0.09426, 0, 0.64999],
            "111": [0, 0.44444, 0.07861, 0, 0.59111],
            "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
            "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "114": [0, 0.44444, 0.11111, 0, 0.50167],
            "115": [0, 0.44444, 0.08167, 0, 0.48694],
            "116": [0, 0.63492, 0.09639, 0, 0.385],
            "117": [0, 0.44444, 0.09426, 0, 0.62055],
            "118": [0, 0.44444, 0.11111, 0, 0.53222],
            "119": [0, 0.44444, 0.11111, 0, 0.76777],
            "120": [0, 0.44444, 0.12583, 0, 0.56055],
            "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
            "122": [0, 0.44444, 0.13889, 0, 0.49055],
            "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0.11473, 0, 0.59111],
            "176": [0, 0.69444, 0, 0, 0.94888],
            "184": [0.17014, 0, 0, 0, 0.53222],
            "198": [0, 0.68611, 0.11431, 0, 1.02277],
            "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
            "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
            "230": [0, 0.44444, 0.085, 0, 0.82666],
            "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
            "305": [0, 0.44444, 0.09426, 0, 0.35555],
            "338": [0, 0.68611, 0.11431, 0, 1.14054],
            "339": [0, 0.44444, 0.085, 0, 0.82666],
            "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
            "710": [0, 0.69444, 0.06709, 0, 0.59111],
            "711": [0, 0.63194, 0.08271, 0, 0.59111],
            "713": [0, 0.59444, 0.10444, 0, 0.59111],
            "714": [0, 0.69444, 0.08528, 0, 0.59111],
            "715": [0, 0.69444, 0, 0, 0.59111],
            "728": [0, 0.69444, 0.10333, 0, 0.59111],
            "729": [0, 0.69444, 0.12945, 0, 0.35555],
            "730": [0, 0.69444, 0, 0, 0.94888],
            "732": [0, 0.69444, 0.11472, 0, 0.59111],
            "733": [0, 0.69444, 0.11472, 0, 0.59111],
            "915": [0, 0.68611, 0.12903, 0, 0.69777],
            "916": [0, 0.68611, 0, 0, 0.94444],
            "920": [0, 0.68611, 0.09062, 0, 0.88555],
            "923": [0, 0.68611, 0, 0, 0.80666],
            "926": [0, 0.68611, 0.15092, 0, 0.76777],
            "928": [0, 0.68611, 0.17208, 0, 0.8961],
            "931": [0, 0.68611, 0.11431, 0, 0.82666],
            "933": [0, 0.68611, 0.10778, 0, 0.88555],
            "934": [0, 0.68611, 0.05632, 0, 0.82666],
            "936": [0, 0.68611, 0.10778, 0, 0.88555],
            "937": [0, 0.68611, 0.0992, 0, 0.82666],
            "8211": [0, 0.44444, 0.09811, 0, 0.59111],
            "8212": [0, 0.44444, 0.09811, 0, 1.18221],
            "8216": [0, 0.69444, 0.12945, 0, 0.35555],
            "8217": [0, 0.69444, 0.12945, 0, 0.35555],
            "8220": [0, 0.69444, 0.16772, 0, 0.62055],
            "8221": [0, 0.69444, 0.07939, 0, 0.62055]
          },
          "Main-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.12417, 0, 0.30667],
            "34": [0, 0.69444, 0.06961, 0, 0.51444],
            "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
            "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
            "38": [0, 0.69444, 0.09694, 0, 0.76666],
            "39": [0, 0.69444, 0.12417, 0, 0.30667],
            "40": [0.25, 0.75, 0.16194, 0, 0.40889],
            "41": [0.25, 0.75, 0.03694, 0, 0.40889],
            "42": [0, 0.75, 0.14917, 0, 0.51111],
            "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
            "44": [0.19444, 0.10556, 0, 0, 0.30667],
            "45": [0, 0.43056, 0.02826, 0, 0.35778],
            "46": [0, 0.10556, 0, 0, 0.30667],
            "47": [0.25, 0.75, 0.16194, 0, 0.51111],
            "48": [0, 0.64444, 0.13556, 0, 0.51111],
            "49": [0, 0.64444, 0.13556, 0, 0.51111],
            "50": [0, 0.64444, 0.13556, 0, 0.51111],
            "51": [0, 0.64444, 0.13556, 0, 0.51111],
            "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "53": [0, 0.64444, 0.13556, 0, 0.51111],
            "54": [0, 0.64444, 0.13556, 0, 0.51111],
            "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "56": [0, 0.64444, 0.13556, 0, 0.51111],
            "57": [0, 0.64444, 0.13556, 0, 0.51111],
            "58": [0, 0.43056, 0.0582, 0, 0.30667],
            "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
            "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
            "63": [0, 0.69444, 0.1225, 0, 0.51111],
            "64": [0, 0.69444, 0.09597, 0, 0.76666],
            "65": [0, 0.68333, 0, 0, 0.74333],
            "66": [0, 0.68333, 0.10257, 0, 0.70389],
            "67": [0, 0.68333, 0.14528, 0, 0.71555],
            "68": [0, 0.68333, 0.09403, 0, 0.755],
            "69": [0, 0.68333, 0.12028, 0, 0.67833],
            "70": [0, 0.68333, 0.13305, 0, 0.65277],
            "71": [0, 0.68333, 0.08722, 0, 0.77361],
            "72": [0, 0.68333, 0.16389, 0, 0.74333],
            "73": [0, 0.68333, 0.15806, 0, 0.38555],
            "74": [0, 0.68333, 0.14028, 0, 0.525],
            "75": [0, 0.68333, 0.14528, 0, 0.76888],
            "76": [0, 0.68333, 0, 0, 0.62722],
            "77": [0, 0.68333, 0.16389, 0, 0.89666],
            "78": [0, 0.68333, 0.16389, 0, 0.74333],
            "79": [0, 0.68333, 0.09403, 0, 0.76666],
            "80": [0, 0.68333, 0.10257, 0, 0.67833],
            "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
            "82": [0, 0.68333, 0.03868, 0, 0.72944],
            "83": [0, 0.68333, 0.11972, 0, 0.56222],
            "84": [0, 0.68333, 0.13305, 0, 0.71555],
            "85": [0, 0.68333, 0.16389, 0, 0.74333],
            "86": [0, 0.68333, 0.18361, 0, 0.74333],
            "87": [0, 0.68333, 0.18361, 0, 0.99888],
            "88": [0, 0.68333, 0.15806, 0, 0.74333],
            "89": [0, 0.68333, 0.19383, 0, 0.74333],
            "90": [0, 0.68333, 0.14528, 0, 0.61333],
            "91": [0.25, 0.75, 0.1875, 0, 0.30667],
            "93": [0.25, 0.75, 0.10528, 0, 0.30667],
            "94": [0, 0.69444, 0.06646, 0, 0.51111],
            "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
            "97": [0, 0.43056, 0.07671, 0, 0.51111],
            "98": [0, 0.69444, 0.06312, 0, 0.46],
            "99": [0, 0.43056, 0.05653, 0, 0.46],
            "100": [0, 0.69444, 0.10333, 0, 0.51111],
            "101": [0, 0.43056, 0.07514, 0, 0.46],
            "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
            "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "104": [0, 0.69444, 0.07671, 0, 0.51111],
            "105": [0, 0.65536, 0.1019, 0, 0.30667],
            "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
            "107": [0, 0.69444, 0.10764, 0, 0.46],
            "108": [0, 0.69444, 0.10333, 0, 0.25555],
            "109": [0, 0.43056, 0.07671, 0, 0.81777],
            "110": [0, 0.43056, 0.07671, 0, 0.56222],
            "111": [0, 0.43056, 0.06312, 0, 0.51111],
            "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
            "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "114": [0, 0.43056, 0.10764, 0, 0.42166],
            "115": [0, 0.43056, 0.08208, 0, 0.40889],
            "116": [0, 0.61508, 0.09486, 0, 0.33222],
            "117": [0, 0.43056, 0.07671, 0, 0.53666],
            "118": [0, 0.43056, 0.10764, 0, 0.46],
            "119": [0, 0.43056, 0.10764, 0, 0.66444],
            "120": [0, 0.43056, 0.12042, 0, 0.46389],
            "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
            "122": [0, 0.43056, 0.12292, 0, 0.40889],
            "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.66786, 0.10474, 0, 0.51111],
            "176": [0, 0.69444, 0, 0, 0.83129],
            "184": [0.17014, 0, 0, 0, 0.46],
            "198": [0, 0.68333, 0.12028, 0, 0.88277],
            "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
            "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
            "230": [0, 0.43056, 0.07514, 0, 0.71555],
            "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
            "338": [0, 0.68333, 0.12028, 0, 0.98499],
            "339": [0, 0.43056, 0.07514, 0, 0.71555],
            "710": [0, 0.69444, 0.06646, 0, 0.51111],
            "711": [0, 0.62847, 0.08295, 0, 0.51111],
            "713": [0, 0.56167, 0.10333, 0, 0.51111],
            "714": [0, 0.69444, 0.09694, 0, 0.51111],
            "715": [0, 0.69444, 0, 0, 0.51111],
            "728": [0, 0.69444, 0.10806, 0, 0.51111],
            "729": [0, 0.66786, 0.11752, 0, 0.30667],
            "730": [0, 0.69444, 0, 0, 0.83129],
            "732": [0, 0.66786, 0.11585, 0, 0.51111],
            "733": [0, 0.69444, 0.1225, 0, 0.51111],
            "915": [0, 0.68333, 0.13305, 0, 0.62722],
            "916": [0, 0.68333, 0, 0, 0.81777],
            "920": [0, 0.68333, 0.09403, 0, 0.76666],
            "923": [0, 0.68333, 0, 0, 0.69222],
            "926": [0, 0.68333, 0.15294, 0, 0.66444],
            "928": [0, 0.68333, 0.16389, 0, 0.74333],
            "931": [0, 0.68333, 0.12028, 0, 0.71555],
            "933": [0, 0.68333, 0.11111, 0, 0.76666],
            "934": [0, 0.68333, 0.05986, 0, 0.71555],
            "936": [0, 0.68333, 0.11111, 0, 0.76666],
            "937": [0, 0.68333, 0.10257, 0, 0.71555],
            "8211": [0, 0.43056, 0.09208, 0, 0.51111],
            "8212": [0, 0.43056, 0.09208, 0, 1.02222],
            "8216": [0, 0.69444, 0.12417, 0, 0.30667],
            "8217": [0, 0.69444, 0.12417, 0, 0.30667],
            "8220": [0, 0.69444, 0.1685, 0, 0.51444],
            "8221": [0, 0.69444, 0.06961, 0, 0.51444],
            "8463": [0, 0.68889, 0, 0, 0.54028]
          },
          "Main-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.27778],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.77778],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.19444, 0.10556, 0, 0, 0.27778],
            "45": [0, 0.43056, 0, 0, 0.33333],
            "46": [0, 0.10556, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.64444, 0, 0, 0.5],
            "49": [0, 0.64444, 0, 0, 0.5],
            "50": [0, 0.64444, 0, 0, 0.5],
            "51": [0, 0.64444, 0, 0, 0.5],
            "52": [0, 0.64444, 0, 0, 0.5],
            "53": [0, 0.64444, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0, 0.64444, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0, 0.64444, 0, 0, 0.5],
            "58": [0, 0.43056, 0, 0, 0.27778],
            "59": [0.19444, 0.43056, 0, 0, 0.27778],
            "60": [0.0391, 0.5391, 0, 0, 0.77778],
            "61": [-0.13313, 0.36687, 0, 0, 0.77778],
            "62": [0.0391, 0.5391, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.77778],
            "65": [0, 0.68333, 0, 0, 0.75],
            "66": [0, 0.68333, 0, 0, 0.70834],
            "67": [0, 0.68333, 0, 0, 0.72222],
            "68": [0, 0.68333, 0, 0, 0.76389],
            "69": [0, 0.68333, 0, 0, 0.68056],
            "70": [0, 0.68333, 0, 0, 0.65278],
            "71": [0, 0.68333, 0, 0, 0.78472],
            "72": [0, 0.68333, 0, 0, 0.75],
            "73": [0, 0.68333, 0, 0, 0.36111],
            "74": [0, 0.68333, 0, 0, 0.51389],
            "75": [0, 0.68333, 0, 0, 0.77778],
            "76": [0, 0.68333, 0, 0, 0.625],
            "77": [0, 0.68333, 0, 0, 0.91667],
            "78": [0, 0.68333, 0, 0, 0.75],
            "79": [0, 0.68333, 0, 0, 0.77778],
            "80": [0, 0.68333, 0, 0, 0.68056],
            "81": [0.19444, 0.68333, 0, 0, 0.77778],
            "82": [0, 0.68333, 0, 0, 0.73611],
            "83": [0, 0.68333, 0, 0, 0.55556],
            "84": [0, 0.68333, 0, 0, 0.72222],
            "85": [0, 0.68333, 0, 0, 0.75],
            "86": [0, 0.68333, 0.01389, 0, 0.75],
            "87": [0, 0.68333, 0.01389, 0, 1.02778],
            "88": [0, 0.68333, 0, 0, 0.75],
            "89": [0, 0.68333, 0.025, 0, 0.75],
            "90": [0, 0.68333, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.27778],
            "92": [0.25, 0.75, 0, 0, 0.5],
            "93": [0.25, 0.75, 0, 0, 0.27778],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.31, 0.12056, 0.02778, 0, 0.5],
            "97": [0, 0.43056, 0, 0, 0.5],
            "98": [0, 0.69444, 0, 0, 0.55556],
            "99": [0, 0.43056, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.55556],
            "101": [0, 0.43056, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.07778, 0, 0.30556],
            "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.55556],
            "105": [0, 0.66786, 0, 0, 0.27778],
            "106": [0.19444, 0.66786, 0, 0, 0.30556],
            "107": [0, 0.69444, 0, 0, 0.52778],
            "108": [0, 0.69444, 0, 0, 0.27778],
            "109": [0, 0.43056, 0, 0, 0.83334],
            "110": [0, 0.43056, 0, 0, 0.55556],
            "111": [0, 0.43056, 0, 0, 0.5],
            "112": [0.19444, 0.43056, 0, 0, 0.55556],
            "113": [0.19444, 0.43056, 0, 0, 0.52778],
            "114": [0, 0.43056, 0, 0, 0.39167],
            "115": [0, 0.43056, 0, 0, 0.39445],
            "116": [0, 0.61508, 0, 0, 0.38889],
            "117": [0, 0.43056, 0, 0, 0.55556],
            "118": [0, 0.43056, 0.01389, 0, 0.52778],
            "119": [0, 0.43056, 0.01389, 0, 0.72222],
            "120": [0, 0.43056, 0, 0, 0.52778],
            "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
            "122": [0, 0.43056, 0, 0, 0.44445],
            "123": [0.25, 0.75, 0, 0, 0.5],
            "124": [0.25, 0.75, 0, 0, 0.27778],
            "125": [0.25, 0.75, 0, 0, 0.5],
            "126": [0.35, 0.31786, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.76909],
            "167": [0.19444, 0.69444, 0, 0, 0.44445],
            "168": [0, 0.66786, 0, 0, 0.5],
            "172": [0, 0.43056, 0, 0, 0.66667],
            "176": [0, 0.69444, 0, 0, 0.75],
            "177": [0.08333, 0.58333, 0, 0, 0.77778],
            "182": [0.19444, 0.69444, 0, 0, 0.61111],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "198": [0, 0.68333, 0, 0, 0.90278],
            "215": [0.08333, 0.58333, 0, 0, 0.77778],
            "216": [0.04861, 0.73194, 0, 0, 0.77778],
            "223": [0, 0.69444, 0, 0, 0.5],
            "230": [0, 0.43056, 0, 0, 0.72222],
            "247": [0.08333, 0.58333, 0, 0, 0.77778],
            "248": [0.09722, 0.52778, 0, 0, 0.5],
            "305": [0, 0.43056, 0, 0, 0.27778],
            "338": [0, 0.68333, 0, 0, 1.01389],
            "339": [0, 0.43056, 0, 0, 0.77778],
            "567": [0.19444, 0.43056, 0, 0, 0.30556],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.62847, 0, 0, 0.5],
            "713": [0, 0.56778, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.66786, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.75],
            "732": [0, 0.66786, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.68333, 0, 0, 0.625],
            "916": [0, 0.68333, 0, 0, 0.83334],
            "920": [0, 0.68333, 0, 0, 0.77778],
            "923": [0, 0.68333, 0, 0, 0.69445],
            "926": [0, 0.68333, 0, 0, 0.66667],
            "928": [0, 0.68333, 0, 0, 0.75],
            "931": [0, 0.68333, 0, 0, 0.72222],
            "933": [0, 0.68333, 0, 0, 0.77778],
            "934": [0, 0.68333, 0, 0, 0.72222],
            "936": [0, 0.68333, 0, 0, 0.77778],
            "937": [0, 0.68333, 0, 0, 0.72222],
            "8211": [0, 0.43056, 0.02778, 0, 0.5],
            "8212": [0, 0.43056, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5],
            "8224": [0.19444, 0.69444, 0, 0, 0.44445],
            "8225": [0.19444, 0.69444, 0, 0, 0.44445],
            "8230": [0, 0.123, 0, 0, 1.172],
            "8242": [0, 0.55556, 0, 0, 0.275],
            "8407": [0, 0.71444, 0.15382, 0, 0.5],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8465": [0, 0.69444, 0, 0, 0.72222],
            "8467": [0, 0.69444, 0, 0.11111, 0.41667],
            "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
            "8476": [0, 0.69444, 0, 0, 0.72222],
            "8501": [0, 0.69444, 0, 0, 0.61111],
            "8592": [-0.13313, 0.36687, 0, 0, 1],
            "8593": [0.19444, 0.69444, 0, 0, 0.5],
            "8594": [-0.13313, 0.36687, 0, 0, 1],
            "8595": [0.19444, 0.69444, 0, 0, 0.5],
            "8596": [-0.13313, 0.36687, 0, 0, 1],
            "8597": [0.25, 0.75, 0, 0, 0.5],
            "8598": [0.19444, 0.69444, 0, 0, 1],
            "8599": [0.19444, 0.69444, 0, 0, 1],
            "8600": [0.19444, 0.69444, 0, 0, 1],
            "8601": [0.19444, 0.69444, 0, 0, 1],
            "8614": [0.011, 0.511, 0, 0, 1],
            "8617": [0.011, 0.511, 0, 0, 1.126],
            "8618": [0.011, 0.511, 0, 0, 1.126],
            "8636": [-0.13313, 0.36687, 0, 0, 1],
            "8637": [-0.13313, 0.36687, 0, 0, 1],
            "8640": [-0.13313, 0.36687, 0, 0, 1],
            "8641": [-0.13313, 0.36687, 0, 0, 1],
            "8652": [0.011, 0.671, 0, 0, 1],
            "8656": [-0.13313, 0.36687, 0, 0, 1],
            "8657": [0.19444, 0.69444, 0, 0, 0.61111],
            "8658": [-0.13313, 0.36687, 0, 0, 1],
            "8659": [0.19444, 0.69444, 0, 0, 0.61111],
            "8660": [-0.13313, 0.36687, 0, 0, 1],
            "8661": [0.25, 0.75, 0, 0, 0.61111],
            "8704": [0, 0.69444, 0, 0, 0.55556],
            "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
            "8707": [0, 0.69444, 0, 0, 0.55556],
            "8709": [0.05556, 0.75, 0, 0, 0.5],
            "8711": [0, 0.68333, 0, 0, 0.83334],
            "8712": [0.0391, 0.5391, 0, 0, 0.66667],
            "8715": [0.0391, 0.5391, 0, 0, 0.66667],
            "8722": [0.08333, 0.58333, 0, 0, 0.77778],
            "8723": [0.08333, 0.58333, 0, 0, 0.77778],
            "8725": [0.25, 0.75, 0, 0, 0.5],
            "8726": [0.25, 0.75, 0, 0, 0.5],
            "8727": [-0.03472, 0.46528, 0, 0, 0.5],
            "8728": [-0.05555, 0.44445, 0, 0, 0.5],
            "8729": [-0.05555, 0.44445, 0, 0, 0.5],
            "8730": [0.2, 0.8, 0, 0, 0.83334],
            "8733": [0, 0.43056, 0, 0, 0.77778],
            "8734": [0, 0.43056, 0, 0, 1],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.27778],
            "8741": [0.25, 0.75, 0, 0, 0.5],
            "8743": [0, 0.55556, 0, 0, 0.66667],
            "8744": [0, 0.55556, 0, 0, 0.66667],
            "8745": [0, 0.55556, 0, 0, 0.66667],
            "8746": [0, 0.55556, 0, 0, 0.66667],
            "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8768": [0.19444, 0.69444, 0, 0, 0.27778],
            "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8773": [-0.022, 0.589, 0, 0, 0.778],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8784": [-0.133, 0.673, 0, 0, 0.778],
            "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8804": [0.13597, 0.63597, 0, 0, 0.77778],
            "8805": [0.13597, 0.63597, 0, 0, 0.77778],
            "8810": [0.0391, 0.5391, 0, 0, 1],
            "8811": [0.0391, 0.5391, 0, 0, 1],
            "8826": [0.0391, 0.5391, 0, 0, 0.77778],
            "8827": [0.0391, 0.5391, 0, 0, 0.77778],
            "8834": [0.0391, 0.5391, 0, 0, 0.77778],
            "8835": [0.0391, 0.5391, 0, 0, 0.77778],
            "8838": [0.13597, 0.63597, 0, 0, 0.77778],
            "8839": [0.13597, 0.63597, 0, 0, 0.77778],
            "8846": [0, 0.55556, 0, 0, 0.66667],
            "8849": [0.13597, 0.63597, 0, 0, 0.77778],
            "8850": [0.13597, 0.63597, 0, 0, 0.77778],
            "8851": [0, 0.55556, 0, 0, 0.66667],
            "8852": [0, 0.55556, 0, 0, 0.66667],
            "8853": [0.08333, 0.58333, 0, 0, 0.77778],
            "8854": [0.08333, 0.58333, 0, 0, 0.77778],
            "8855": [0.08333, 0.58333, 0, 0, 0.77778],
            "8856": [0.08333, 0.58333, 0, 0, 0.77778],
            "8857": [0.08333, 0.58333, 0, 0, 0.77778],
            "8866": [0, 0.69444, 0, 0, 0.61111],
            "8867": [0, 0.69444, 0, 0, 0.61111],
            "8868": [0, 0.69444, 0, 0, 0.77778],
            "8869": [0, 0.69444, 0, 0, 0.77778],
            "8872": [0.249, 0.75, 0, 0, 0.867],
            "8900": [-0.05555, 0.44445, 0, 0, 0.5],
            "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
            "8902": [-0.03472, 0.46528, 0, 0, 0.5],
            "8904": [5e-3, 0.505, 0, 0, 0.9],
            "8942": [0.03, 0.903, 0, 0, 0.278],
            "8943": [-0.19, 0.313, 0, 0, 1.172],
            "8945": [-0.1, 0.823, 0, 0, 1.282],
            "8968": [0.25, 0.75, 0, 0, 0.44445],
            "8969": [0.25, 0.75, 0, 0, 0.44445],
            "8970": [0.25, 0.75, 0, 0, 0.44445],
            "8971": [0.25, 0.75, 0, 0, 0.44445],
            "8994": [-0.14236, 0.35764, 0, 0, 1],
            "8995": [-0.14236, 0.35764, 0, 0, 1],
            "9136": [0.244, 0.744, 0, 0, 0.412],
            "9137": [0.244, 0.745, 0, 0, 0.412],
            "9651": [0.19444, 0.69444, 0, 0, 0.88889],
            "9657": [-0.03472, 0.46528, 0, 0, 0.5],
            "9661": [0.19444, 0.69444, 0, 0, 0.88889],
            "9667": [-0.03472, 0.46528, 0, 0, 0.5],
            "9711": [0.19444, 0.69444, 0, 0, 1],
            "9824": [0.12963, 0.69444, 0, 0, 0.77778],
            "9825": [0.12963, 0.69444, 0, 0, 0.77778],
            "9826": [0.12963, 0.69444, 0, 0, 0.77778],
            "9827": [0.12963, 0.69444, 0, 0, 0.77778],
            "9837": [0, 0.75, 0, 0, 0.38889],
            "9838": [0.19444, 0.69444, 0, 0, 0.38889],
            "9839": [0.19444, 0.69444, 0, 0, 0.38889],
            "10216": [0.25, 0.75, 0, 0, 0.38889],
            "10217": [0.25, 0.75, 0, 0, 0.38889],
            "10222": [0.244, 0.744, 0, 0, 0.412],
            "10223": [0.244, 0.745, 0, 0, 0.412],
            "10229": [0.011, 0.511, 0, 0, 1.609],
            "10230": [0.011, 0.511, 0, 0, 1.638],
            "10231": [0.011, 0.511, 0, 0, 1.859],
            "10232": [0.024, 0.525, 0, 0, 1.609],
            "10233": [0.024, 0.525, 0, 0, 1.638],
            "10234": [0.024, 0.525, 0, 0, 1.858],
            "10236": [0.011, 0.511, 0, 0, 1.638],
            "10815": [0, 0.68333, 0, 0, 0.75],
            "10927": [0.13597, 0.63597, 0, 0, 0.77778],
            "10928": [0.13597, 0.63597, 0, 0, 0.77778],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Math-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.44444, 0, 0, 0.575],
            "49": [0, 0.44444, 0, 0, 0.575],
            "50": [0, 0.44444, 0, 0, 0.575],
            "51": [0.19444, 0.44444, 0, 0, 0.575],
            "52": [0.19444, 0.44444, 0, 0, 0.575],
            "53": [0.19444, 0.44444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0.19444, 0.44444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0.19444, 0.44444, 0, 0, 0.575],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0.04835, 0, 0.8664],
            "67": [0, 0.68611, 0.06979, 0, 0.81694],
            "68": [0, 0.68611, 0.03194, 0, 0.93812],
            "69": [0, 0.68611, 0.05451, 0, 0.81007],
            "70": [0, 0.68611, 0.15972, 0, 0.68889],
            "71": [0, 0.68611, 0, 0, 0.88673],
            "72": [0, 0.68611, 0.08229, 0, 0.98229],
            "73": [0, 0.68611, 0.07778, 0, 0.51111],
            "74": [0, 0.68611, 0.10069, 0, 0.63125],
            "75": [0, 0.68611, 0.06979, 0, 0.97118],
            "76": [0, 0.68611, 0, 0, 0.75555],
            "77": [0, 0.68611, 0.11424, 0, 1.14201],
            "78": [0, 0.68611, 0.11424, 0, 0.95034],
            "79": [0, 0.68611, 0.03194, 0, 0.83666],
            "80": [0, 0.68611, 0.15972, 0, 0.72309],
            "81": [0.19444, 0.68611, 0, 0, 0.86861],
            "82": [0, 0.68611, 421e-5, 0, 0.87235],
            "83": [0, 0.68611, 0.05382, 0, 0.69271],
            "84": [0, 0.68611, 0.15972, 0, 0.63663],
            "85": [0, 0.68611, 0.11424, 0, 0.80027],
            "86": [0, 0.68611, 0.25555, 0, 0.67778],
            "87": [0, 0.68611, 0.15972, 0, 1.09305],
            "88": [0, 0.68611, 0.07778, 0, 0.94722],
            "89": [0, 0.68611, 0.25555, 0, 0.67458],
            "90": [0, 0.68611, 0.06979, 0, 0.77257],
            "97": [0, 0.44444, 0, 0, 0.63287],
            "98": [0, 0.69444, 0, 0, 0.52083],
            "99": [0, 0.44444, 0, 0, 0.51342],
            "100": [0, 0.69444, 0, 0, 0.60972],
            "101": [0, 0.44444, 0, 0, 0.55361],
            "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
            "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
            "104": [0, 0.69444, 0, 0, 0.66759],
            "105": [0, 0.69326, 0, 0, 0.4048],
            "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
            "107": [0, 0.69444, 0.01852, 0, 0.6037],
            "108": [0, 0.69444, 88e-4, 0, 0.34815],
            "109": [0, 0.44444, 0, 0, 1.0324],
            "110": [0, 0.44444, 0, 0, 0.71296],
            "111": [0, 0.44444, 0, 0, 0.58472],
            "112": [0.19444, 0.44444, 0, 0, 0.60092],
            "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
            "114": [0, 0.44444, 0.03194, 0, 0.5287],
            "115": [0, 0.44444, 0, 0, 0.53125],
            "116": [0, 0.63492, 0, 0, 0.41528],
            "117": [0, 0.44444, 0, 0, 0.68102],
            "118": [0, 0.44444, 0.03704, 0, 0.56666],
            "119": [0, 0.44444, 0.02778, 0, 0.83148],
            "120": [0, 0.44444, 0, 0, 0.65903],
            "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
            "122": [0, 0.44444, 0.04213, 0, 0.55509],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68611, 0.15972, 0, 0.65694],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0.03194, 0, 0.86722],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0.07458, 0, 0.84125],
            "928": [0, 0.68611, 0.08229, 0, 0.98229],
            "931": [0, 0.68611, 0.05451, 0, 0.88507],
            "933": [0, 0.68611, 0.15972, 0, 0.67083],
            "934": [0, 0.68611, 0, 0, 0.76666],
            "936": [0, 0.68611, 0.11653, 0, 0.71402],
            "937": [0, 0.68611, 0.04835, 0, 0.8789],
            "945": [0, 0.44444, 0, 0, 0.76064],
            "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
            "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
            "948": [0, 0.69444, 0.03819, 0, 0.52222],
            "949": [0, 0.44444, 0, 0, 0.52882],
            "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
            "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
            "952": [0, 0.69444, 0.03194, 0, 0.5618],
            "953": [0, 0.44444, 0, 0, 0.41204],
            "954": [0, 0.44444, 0, 0, 0.66759],
            "955": [0, 0.69444, 0, 0, 0.67083],
            "956": [0.19444, 0.44444, 0, 0, 0.70787],
            "957": [0, 0.44444, 0.06898, 0, 0.57685],
            "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
            "959": [0, 0.44444, 0, 0, 0.58472],
            "960": [0, 0.44444, 0.03704, 0, 0.68241],
            "961": [0.19444, 0.44444, 0, 0, 0.6118],
            "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
            "963": [0, 0.44444, 0.03704, 0, 0.68588],
            "964": [0, 0.44444, 0.13472, 0, 0.52083],
            "965": [0, 0.44444, 0.03704, 0, 0.63055],
            "966": [0.19444, 0.44444, 0, 0, 0.74722],
            "967": [0.19444, 0.44444, 0, 0, 0.71805],
            "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
            "969": [0, 0.44444, 0.03704, 0, 0.71782],
            "977": [0, 0.69444, 0, 0, 0.69155],
            "981": [0.19444, 0.69444, 0, 0, 0.7125],
            "982": [0, 0.44444, 0.03194, 0, 0.975],
            "1009": [0.19444, 0.44444, 0, 0, 0.6118],
            "1013": [0, 0.44444, 0, 0, 0.48333],
            "57649": [0, 0.44444, 0, 0, 0.39352],
            "57911": [0.19444, 0.44444, 0, 0, 0.43889]
          },
          "Math-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.43056, 0, 0, 0.5],
            "49": [0, 0.43056, 0, 0, 0.5],
            "50": [0, 0.43056, 0, 0, 0.5],
            "51": [0.19444, 0.43056, 0, 0, 0.5],
            "52": [0.19444, 0.43056, 0, 0, 0.5],
            "53": [0.19444, 0.43056, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0.19444, 0.43056, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0.19444, 0.43056, 0, 0, 0.5],
            "65": [0, 0.68333, 0, 0.13889, 0.75],
            "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
            "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
            "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
            "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
            "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
            "71": [0, 0.68333, 0, 0.08334, 0.78625],
            "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
            "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
            "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
            "76": [0, 0.68333, 0, 0.02778, 0.68056],
            "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
            "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
            "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
            "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
            "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
            "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
            "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
            "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
            "86": [0, 0.68333, 0.22222, 0, 0.58333],
            "87": [0, 0.68333, 0.13889, 0, 0.94445],
            "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
            "89": [0, 0.68333, 0.22222, 0, 0.58056],
            "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
            "97": [0, 0.43056, 0, 0, 0.52859],
            "98": [0, 0.69444, 0, 0, 0.42917],
            "99": [0, 0.43056, 0, 0.05556, 0.43276],
            "100": [0, 0.69444, 0, 0.16667, 0.52049],
            "101": [0, 0.43056, 0, 0.05556, 0.46563],
            "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
            "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
            "104": [0, 0.69444, 0, 0, 0.57616],
            "105": [0, 0.65952, 0, 0, 0.34451],
            "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
            "107": [0, 0.69444, 0.03148, 0, 0.5206],
            "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
            "109": [0, 0.43056, 0, 0, 0.87801],
            "110": [0, 0.43056, 0, 0, 0.60023],
            "111": [0, 0.43056, 0, 0.05556, 0.48472],
            "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
            "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
            "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
            "115": [0, 0.43056, 0, 0.05556, 0.46875],
            "116": [0, 0.61508, 0, 0.08334, 0.36111],
            "117": [0, 0.43056, 0, 0.02778, 0.57246],
            "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
            "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
            "120": [0, 0.43056, 0, 0.02778, 0.57153],
            "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
            "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
            "916": [0, 0.68333, 0, 0.16667, 0.83334],
            "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "923": [0, 0.68333, 0, 0.16667, 0.69445],
            "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
            "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
            "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
            "934": [0, 0.68333, 0, 0.08334, 0.66667],
            "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
            "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
            "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
            "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
            "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
            "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
            "949": [0, 0.43056, 0, 0.08334, 0.46632],
            "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
            "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
            "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
            "953": [0, 0.43056, 0, 0.05556, 0.35394],
            "954": [0, 0.43056, 0, 0, 0.57616],
            "955": [0, 0.69444, 0, 0, 0.58334],
            "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
            "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
            "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
            "959": [0, 0.43056, 0, 0.05556, 0.48472],
            "960": [0, 0.43056, 0.03588, 0, 0.57003],
            "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
            "963": [0, 0.43056, 0.03588, 0, 0.57141],
            "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
            "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
            "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
            "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
            "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
            "969": [0, 0.43056, 0.03588, 0, 0.62245],
            "977": [0, 0.69444, 0, 0.08334, 0.59144],
            "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
            "982": [0, 0.43056, 0.02778, 0, 0.82813],
            "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "1013": [0, 0.43056, 0, 0.05556, 0.4059],
            "57649": [0, 0.43056, 0, 0.02778, 0.32246],
            "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
          },
          "SansSerif-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.36667],
            "34": [0, 0.69444, 0, 0, 0.55834],
            "35": [0.19444, 0.69444, 0, 0, 0.91667],
            "36": [0.05556, 0.75, 0, 0, 0.55],
            "37": [0.05556, 0.75, 0, 0, 1.02912],
            "38": [0, 0.69444, 0, 0, 0.83056],
            "39": [0, 0.69444, 0, 0, 0.30556],
            "40": [0.25, 0.75, 0, 0, 0.42778],
            "41": [0.25, 0.75, 0, 0, 0.42778],
            "42": [0, 0.75, 0, 0, 0.55],
            "43": [0.11667, 0.61667, 0, 0, 0.85556],
            "44": [0.10556, 0.13056, 0, 0, 0.30556],
            "45": [0, 0.45833, 0, 0, 0.36667],
            "46": [0, 0.13056, 0, 0, 0.30556],
            "47": [0.25, 0.75, 0, 0, 0.55],
            "48": [0, 0.69444, 0, 0, 0.55],
            "49": [0, 0.69444, 0, 0, 0.55],
            "50": [0, 0.69444, 0, 0, 0.55],
            "51": [0, 0.69444, 0, 0, 0.55],
            "52": [0, 0.69444, 0, 0, 0.55],
            "53": [0, 0.69444, 0, 0, 0.55],
            "54": [0, 0.69444, 0, 0, 0.55],
            "55": [0, 0.69444, 0, 0, 0.55],
            "56": [0, 0.69444, 0, 0, 0.55],
            "57": [0, 0.69444, 0, 0, 0.55],
            "58": [0, 0.45833, 0, 0, 0.30556],
            "59": [0.10556, 0.45833, 0, 0, 0.30556],
            "61": [-0.09375, 0.40625, 0, 0, 0.85556],
            "63": [0, 0.69444, 0, 0, 0.51945],
            "64": [0, 0.69444, 0, 0, 0.73334],
            "65": [0, 0.69444, 0, 0, 0.73334],
            "66": [0, 0.69444, 0, 0, 0.73334],
            "67": [0, 0.69444, 0, 0, 0.70278],
            "68": [0, 0.69444, 0, 0, 0.79445],
            "69": [0, 0.69444, 0, 0, 0.64167],
            "70": [0, 0.69444, 0, 0, 0.61111],
            "71": [0, 0.69444, 0, 0, 0.73334],
            "72": [0, 0.69444, 0, 0, 0.79445],
            "73": [0, 0.69444, 0, 0, 0.33056],
            "74": [0, 0.69444, 0, 0, 0.51945],
            "75": [0, 0.69444, 0, 0, 0.76389],
            "76": [0, 0.69444, 0, 0, 0.58056],
            "77": [0, 0.69444, 0, 0, 0.97778],
            "78": [0, 0.69444, 0, 0, 0.79445],
            "79": [0, 0.69444, 0, 0, 0.79445],
            "80": [0, 0.69444, 0, 0, 0.70278],
            "81": [0.10556, 0.69444, 0, 0, 0.79445],
            "82": [0, 0.69444, 0, 0, 0.70278],
            "83": [0, 0.69444, 0, 0, 0.61111],
            "84": [0, 0.69444, 0, 0, 0.73334],
            "85": [0, 0.69444, 0, 0, 0.76389],
            "86": [0, 0.69444, 0.01528, 0, 0.73334],
            "87": [0, 0.69444, 0.01528, 0, 1.03889],
            "88": [0, 0.69444, 0, 0, 0.73334],
            "89": [0, 0.69444, 0.0275, 0, 0.73334],
            "90": [0, 0.69444, 0, 0, 0.67223],
            "91": [0.25, 0.75, 0, 0, 0.34306],
            "93": [0.25, 0.75, 0, 0, 0.34306],
            "94": [0, 0.69444, 0, 0, 0.55],
            "95": [0.35, 0.10833, 0.03056, 0, 0.55],
            "97": [0, 0.45833, 0, 0, 0.525],
            "98": [0, 0.69444, 0, 0, 0.56111],
            "99": [0, 0.45833, 0, 0, 0.48889],
            "100": [0, 0.69444, 0, 0, 0.56111],
            "101": [0, 0.45833, 0, 0, 0.51111],
            "102": [0, 0.69444, 0.07639, 0, 0.33611],
            "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
            "104": [0, 0.69444, 0, 0, 0.56111],
            "105": [0, 0.69444, 0, 0, 0.25556],
            "106": [0.19444, 0.69444, 0, 0, 0.28611],
            "107": [0, 0.69444, 0, 0, 0.53056],
            "108": [0, 0.69444, 0, 0, 0.25556],
            "109": [0, 0.45833, 0, 0, 0.86667],
            "110": [0, 0.45833, 0, 0, 0.56111],
            "111": [0, 0.45833, 0, 0, 0.55],
            "112": [0.19444, 0.45833, 0, 0, 0.56111],
            "113": [0.19444, 0.45833, 0, 0, 0.56111],
            "114": [0, 0.45833, 0.01528, 0, 0.37222],
            "115": [0, 0.45833, 0, 0, 0.42167],
            "116": [0, 0.58929, 0, 0, 0.40417],
            "117": [0, 0.45833, 0, 0, 0.56111],
            "118": [0, 0.45833, 0.01528, 0, 0.5],
            "119": [0, 0.45833, 0.01528, 0, 0.74445],
            "120": [0, 0.45833, 0, 0, 0.5],
            "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
            "122": [0, 0.45833, 0, 0, 0.47639],
            "126": [0.35, 0.34444, 0, 0, 0.55],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0, 0, 0.55],
            "176": [0, 0.69444, 0, 0, 0.73334],
            "180": [0, 0.69444, 0, 0, 0.55],
            "184": [0.17014, 0, 0, 0, 0.48889],
            "305": [0, 0.45833, 0, 0, 0.25556],
            "567": [0.19444, 0.45833, 0, 0, 0.28611],
            "710": [0, 0.69444, 0, 0, 0.55],
            "711": [0, 0.63542, 0, 0, 0.55],
            "713": [0, 0.63778, 0, 0, 0.55],
            "728": [0, 0.69444, 0, 0, 0.55],
            "729": [0, 0.69444, 0, 0, 0.30556],
            "730": [0, 0.69444, 0, 0, 0.73334],
            "732": [0, 0.69444, 0, 0, 0.55],
            "733": [0, 0.69444, 0, 0, 0.55],
            "915": [0, 0.69444, 0, 0, 0.58056],
            "916": [0, 0.69444, 0, 0, 0.91667],
            "920": [0, 0.69444, 0, 0, 0.85556],
            "923": [0, 0.69444, 0, 0, 0.67223],
            "926": [0, 0.69444, 0, 0, 0.73334],
            "928": [0, 0.69444, 0, 0, 0.79445],
            "931": [0, 0.69444, 0, 0, 0.79445],
            "933": [0, 0.69444, 0, 0, 0.85556],
            "934": [0, 0.69444, 0, 0, 0.79445],
            "936": [0, 0.69444, 0, 0, 0.85556],
            "937": [0, 0.69444, 0, 0, 0.79445],
            "8211": [0, 0.45833, 0.03056, 0, 0.55],
            "8212": [0, 0.45833, 0.03056, 0, 1.10001],
            "8216": [0, 0.69444, 0, 0, 0.30556],
            "8217": [0, 0.69444, 0, 0, 0.30556],
            "8220": [0, 0.69444, 0, 0, 0.55834],
            "8221": [0, 0.69444, 0, 0, 0.55834]
          },
          "SansSerif-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.05733, 0, 0.31945],
            "34": [0, 0.69444, 316e-5, 0, 0.5],
            "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
            "36": [0.05556, 0.75, 0.11156, 0, 0.5],
            "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
            "38": [0, 0.69444, 0.03058, 0, 0.75834],
            "39": [0, 0.69444, 0.07816, 0, 0.27778],
            "40": [0.25, 0.75, 0.13164, 0, 0.38889],
            "41": [0.25, 0.75, 0.02536, 0, 0.38889],
            "42": [0, 0.75, 0.11775, 0, 0.5],
            "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0.01946, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0.13164, 0, 0.5],
            "48": [0, 0.65556, 0.11156, 0, 0.5],
            "49": [0, 0.65556, 0.11156, 0, 0.5],
            "50": [0, 0.65556, 0.11156, 0, 0.5],
            "51": [0, 0.65556, 0.11156, 0, 0.5],
            "52": [0, 0.65556, 0.11156, 0, 0.5],
            "53": [0, 0.65556, 0.11156, 0, 0.5],
            "54": [0, 0.65556, 0.11156, 0, 0.5],
            "55": [0, 0.65556, 0.11156, 0, 0.5],
            "56": [0, 0.65556, 0.11156, 0, 0.5],
            "57": [0, 0.65556, 0.11156, 0, 0.5],
            "58": [0, 0.44444, 0.02502, 0, 0.27778],
            "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
            "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
            "63": [0, 0.69444, 0.11809, 0, 0.47222],
            "64": [0, 0.69444, 0.07555, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0.08293, 0, 0.66667],
            "67": [0, 0.69444, 0.11983, 0, 0.63889],
            "68": [0, 0.69444, 0.07555, 0, 0.72223],
            "69": [0, 0.69444, 0.11983, 0, 0.59722],
            "70": [0, 0.69444, 0.13372, 0, 0.56945],
            "71": [0, 0.69444, 0.11983, 0, 0.66667],
            "72": [0, 0.69444, 0.08094, 0, 0.70834],
            "73": [0, 0.69444, 0.13372, 0, 0.27778],
            "74": [0, 0.69444, 0.08094, 0, 0.47222],
            "75": [0, 0.69444, 0.11983, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0.08094, 0, 0.875],
            "78": [0, 0.69444, 0.08094, 0, 0.70834],
            "79": [0, 0.69444, 0.07555, 0, 0.73611],
            "80": [0, 0.69444, 0.08293, 0, 0.63889],
            "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
            "82": [0, 0.69444, 0.08293, 0, 0.64584],
            "83": [0, 0.69444, 0.09205, 0, 0.55556],
            "84": [0, 0.69444, 0.13372, 0, 0.68056],
            "85": [0, 0.69444, 0.08094, 0, 0.6875],
            "86": [0, 0.69444, 0.1615, 0, 0.66667],
            "87": [0, 0.69444, 0.1615, 0, 0.94445],
            "88": [0, 0.69444, 0.13372, 0, 0.66667],
            "89": [0, 0.69444, 0.17261, 0, 0.66667],
            "90": [0, 0.69444, 0.11983, 0, 0.61111],
            "91": [0.25, 0.75, 0.15942, 0, 0.28889],
            "93": [0.25, 0.75, 0.08719, 0, 0.28889],
            "94": [0, 0.69444, 0.0799, 0, 0.5],
            "95": [0.35, 0.09444, 0.08616, 0, 0.5],
            "97": [0, 0.44444, 981e-5, 0, 0.48056],
            "98": [0, 0.69444, 0.03057, 0, 0.51667],
            "99": [0, 0.44444, 0.08336, 0, 0.44445],
            "100": [0, 0.69444, 0.09483, 0, 0.51667],
            "101": [0, 0.44444, 0.06778, 0, 0.44445],
            "102": [0, 0.69444, 0.21705, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
            "104": [0, 0.69444, 0.01778, 0, 0.51667],
            "105": [0, 0.67937, 0.09718, 0, 0.23889],
            "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
            "107": [0, 0.69444, 0.08336, 0, 0.48889],
            "108": [0, 0.69444, 0.09483, 0, 0.23889],
            "109": [0, 0.44444, 0.01778, 0, 0.79445],
            "110": [0, 0.44444, 0.01778, 0, 0.51667],
            "111": [0, 0.44444, 0.06613, 0, 0.5],
            "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
            "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
            "114": [0, 0.44444, 0.10836, 0, 0.34167],
            "115": [0, 0.44444, 0.0778, 0, 0.38333],
            "116": [0, 0.57143, 0.07225, 0, 0.36111],
            "117": [0, 0.44444, 0.04169, 0, 0.51667],
            "118": [0, 0.44444, 0.10836, 0, 0.46111],
            "119": [0, 0.44444, 0.10836, 0, 0.68334],
            "120": [0, 0.44444, 0.09169, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
            "122": [0, 0.44444, 0.08752, 0, 0.43472],
            "126": [0.35, 0.32659, 0.08826, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0.06385, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.73752],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0.04169, 0, 0.23889],
            "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
            "710": [0, 0.69444, 0.0799, 0, 0.5],
            "711": [0, 0.63194, 0.08432, 0, 0.5],
            "713": [0, 0.60889, 0.08776, 0, 0.5],
            "714": [0, 0.69444, 0.09205, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0.09483, 0, 0.5],
            "729": [0, 0.67937, 0.07774, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.73752],
            "732": [0, 0.67659, 0.08826, 0, 0.5],
            "733": [0, 0.69444, 0.09205, 0, 0.5],
            "915": [0, 0.69444, 0.13372, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0.07555, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0.12816, 0, 0.66667],
            "928": [0, 0.69444, 0.08094, 0, 0.70834],
            "931": [0, 0.69444, 0.11983, 0, 0.72222],
            "933": [0, 0.69444, 0.09031, 0, 0.77778],
            "934": [0, 0.69444, 0.04603, 0, 0.72222],
            "936": [0, 0.69444, 0.09031, 0, 0.77778],
            "937": [0, 0.69444, 0.08293, 0, 0.72222],
            "8211": [0, 0.44444, 0.08616, 0, 0.5],
            "8212": [0, 0.44444, 0.08616, 0, 1],
            "8216": [0, 0.69444, 0.07816, 0, 0.27778],
            "8217": [0, 0.69444, 0.07816, 0, 0.27778],
            "8220": [0, 0.69444, 0.14205, 0, 0.5],
            "8221": [0, 0.69444, 316e-5, 0, 0.5]
          },
          "SansSerif-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.31945],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.75834],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.65556, 0, 0, 0.5],
            "49": [0, 0.65556, 0, 0, 0.5],
            "50": [0, 0.65556, 0, 0, 0.5],
            "51": [0, 0.65556, 0, 0, 0.5],
            "52": [0, 0.65556, 0, 0, 0.5],
            "53": [0, 0.65556, 0, 0, 0.5],
            "54": [0, 0.65556, 0, 0, 0.5],
            "55": [0, 0.65556, 0, 0, 0.5],
            "56": [0, 0.65556, 0, 0, 0.5],
            "57": [0, 0.65556, 0, 0, 0.5],
            "58": [0, 0.44444, 0, 0, 0.27778],
            "59": [0.125, 0.44444, 0, 0, 0.27778],
            "61": [-0.13, 0.37, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0, 0, 0.66667],
            "67": [0, 0.69444, 0, 0, 0.63889],
            "68": [0, 0.69444, 0, 0, 0.72223],
            "69": [0, 0.69444, 0, 0, 0.59722],
            "70": [0, 0.69444, 0, 0, 0.56945],
            "71": [0, 0.69444, 0, 0, 0.66667],
            "72": [0, 0.69444, 0, 0, 0.70834],
            "73": [0, 0.69444, 0, 0, 0.27778],
            "74": [0, 0.69444, 0, 0, 0.47222],
            "75": [0, 0.69444, 0, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0, 0, 0.875],
            "78": [0, 0.69444, 0, 0, 0.70834],
            "79": [0, 0.69444, 0, 0, 0.73611],
            "80": [0, 0.69444, 0, 0, 0.63889],
            "81": [0.125, 0.69444, 0, 0, 0.73611],
            "82": [0, 0.69444, 0, 0, 0.64584],
            "83": [0, 0.69444, 0, 0, 0.55556],
            "84": [0, 0.69444, 0, 0, 0.68056],
            "85": [0, 0.69444, 0, 0, 0.6875],
            "86": [0, 0.69444, 0.01389, 0, 0.66667],
            "87": [0, 0.69444, 0.01389, 0, 0.94445],
            "88": [0, 0.69444, 0, 0, 0.66667],
            "89": [0, 0.69444, 0.025, 0, 0.66667],
            "90": [0, 0.69444, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.28889],
            "93": [0.25, 0.75, 0, 0, 0.28889],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.35, 0.09444, 0.02778, 0, 0.5],
            "97": [0, 0.44444, 0, 0, 0.48056],
            "98": [0, 0.69444, 0, 0, 0.51667],
            "99": [0, 0.44444, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.51667],
            "101": [0, 0.44444, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.06944, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.51667],
            "105": [0, 0.67937, 0, 0, 0.23889],
            "106": [0.19444, 0.67937, 0, 0, 0.26667],
            "107": [0, 0.69444, 0, 0, 0.48889],
            "108": [0, 0.69444, 0, 0, 0.23889],
            "109": [0, 0.44444, 0, 0, 0.79445],
            "110": [0, 0.44444, 0, 0, 0.51667],
            "111": [0, 0.44444, 0, 0, 0.5],
            "112": [0.19444, 0.44444, 0, 0, 0.51667],
            "113": [0.19444, 0.44444, 0, 0, 0.51667],
            "114": [0, 0.44444, 0.01389, 0, 0.34167],
            "115": [0, 0.44444, 0, 0, 0.38333],
            "116": [0, 0.57143, 0, 0, 0.36111],
            "117": [0, 0.44444, 0, 0, 0.51667],
            "118": [0, 0.44444, 0.01389, 0, 0.46111],
            "119": [0, 0.44444, 0.01389, 0, 0.68334],
            "120": [0, 0.44444, 0, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
            "122": [0, 0.44444, 0, 0, 0.43472],
            "126": [0.35, 0.32659, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.66667],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0, 0, 0.23889],
            "567": [0.19444, 0.44444, 0, 0, 0.26667],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.63194, 0, 0, 0.5],
            "713": [0, 0.60889, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.67937, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.66667],
            "732": [0, 0.67659, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.69444, 0, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0, 0, 0.66667],
            "928": [0, 0.69444, 0, 0, 0.70834],
            "931": [0, 0.69444, 0, 0, 0.72222],
            "933": [0, 0.69444, 0, 0, 0.77778],
            "934": [0, 0.69444, 0, 0, 0.72222],
            "936": [0, 0.69444, 0, 0, 0.77778],
            "937": [0, 0.69444, 0, 0, 0.72222],
            "8211": [0, 0.44444, 0.02778, 0, 0.5],
            "8212": [0, 0.44444, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5]
          },
          "Script-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.7, 0.22925, 0, 0.80253],
            "66": [0, 0.7, 0.04087, 0, 0.90757],
            "67": [0, 0.7, 0.1689, 0, 0.66619],
            "68": [0, 0.7, 0.09371, 0, 0.77443],
            "69": [0, 0.7, 0.18583, 0, 0.56162],
            "70": [0, 0.7, 0.13634, 0, 0.89544],
            "71": [0, 0.7, 0.17322, 0, 0.60961],
            "72": [0, 0.7, 0.29694, 0, 0.96919],
            "73": [0, 0.7, 0.19189, 0, 0.80907],
            "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
            "75": [0, 0.7, 0.31259, 0, 0.91364],
            "76": [0, 0.7, 0.19189, 0, 0.87373],
            "77": [0, 0.7, 0.15981, 0, 1.08031],
            "78": [0, 0.7, 0.3525, 0, 0.9015],
            "79": [0, 0.7, 0.08078, 0, 0.73787],
            "80": [0, 0.7, 0.08078, 0, 1.01262],
            "81": [0, 0.7, 0.03305, 0, 0.88282],
            "82": [0, 0.7, 0.06259, 0, 0.85],
            "83": [0, 0.7, 0.19189, 0, 0.86767],
            "84": [0, 0.7, 0.29087, 0, 0.74697],
            "85": [0, 0.7, 0.25815, 0, 0.79996],
            "86": [0, 0.7, 0.27523, 0, 0.62204],
            "87": [0, 0.7, 0.27523, 0, 0.80532],
            "88": [0, 0.7, 0.26006, 0, 0.94445],
            "89": [0, 0.7, 0.2939, 0, 0.70961],
            "90": [0, 0.7, 0.24037, 0, 0.8212],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Size1-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.35001, 0.85, 0, 0, 0.45834],
            "41": [0.35001, 0.85, 0, 0, 0.45834],
            "47": [0.35001, 0.85, 0, 0, 0.57778],
            "91": [0.35001, 0.85, 0, 0, 0.41667],
            "92": [0.35001, 0.85, 0, 0, 0.57778],
            "93": [0.35001, 0.85, 0, 0, 0.41667],
            "123": [0.35001, 0.85, 0, 0, 0.58334],
            "125": [0.35001, 0.85, 0, 0, 0.58334],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.72222, 0, 0, 0.55556],
            "732": [0, 0.72222, 0, 0, 0.55556],
            "770": [0, 0.72222, 0, 0, 0.55556],
            "771": [0, 0.72222, 0, 0, 0.55556],
            "8214": [-99e-5, 0.601, 0, 0, 0.77778],
            "8593": [1e-5, 0.6, 0, 0, 0.66667],
            "8595": [1e-5, 0.6, 0, 0, 0.66667],
            "8657": [1e-5, 0.6, 0, 0, 0.77778],
            "8659": [1e-5, 0.6, 0, 0, 0.77778],
            "8719": [0.25001, 0.75, 0, 0, 0.94445],
            "8720": [0.25001, 0.75, 0, 0, 0.94445],
            "8721": [0.25001, 0.75, 0, 0, 1.05556],
            "8730": [0.35001, 0.85, 0, 0, 1],
            "8739": [-599e-5, 0.606, 0, 0, 0.33333],
            "8741": [-599e-5, 0.606, 0, 0, 0.55556],
            "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8896": [0.25001, 0.75, 0, 0, 0.83334],
            "8897": [0.25001, 0.75, 0, 0, 0.83334],
            "8898": [0.25001, 0.75, 0, 0, 0.83334],
            "8899": [0.25001, 0.75, 0, 0, 0.83334],
            "8968": [0.35001, 0.85, 0, 0, 0.47222],
            "8969": [0.35001, 0.85, 0, 0, 0.47222],
            "8970": [0.35001, 0.85, 0, 0, 0.47222],
            "8971": [0.35001, 0.85, 0, 0, 0.47222],
            "9168": [-99e-5, 0.601, 0, 0, 0.66667],
            "10216": [0.35001, 0.85, 0, 0, 0.47222],
            "10217": [0.35001, 0.85, 0, 0, 0.47222],
            "10752": [0.25001, 0.75, 0, 0, 1.11111],
            "10753": [0.25001, 0.75, 0, 0, 1.11111],
            "10754": [0.25001, 0.75, 0, 0, 1.11111],
            "10756": [0.25001, 0.75, 0, 0, 0.83334],
            "10758": [0.25001, 0.75, 0, 0, 0.83334]
          },
          "Size2-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.65002, 1.15, 0, 0, 0.59722],
            "41": [0.65002, 1.15, 0, 0, 0.59722],
            "47": [0.65002, 1.15, 0, 0, 0.81111],
            "91": [0.65002, 1.15, 0, 0, 0.47222],
            "92": [0.65002, 1.15, 0, 0, 0.81111],
            "93": [0.65002, 1.15, 0, 0, 0.47222],
            "123": [0.65002, 1.15, 0, 0, 0.66667],
            "125": [0.65002, 1.15, 0, 0, 0.66667],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1],
            "732": [0, 0.75, 0, 0, 1],
            "770": [0, 0.75, 0, 0, 1],
            "771": [0, 0.75, 0, 0, 1],
            "8719": [0.55001, 1.05, 0, 0, 1.27778],
            "8720": [0.55001, 1.05, 0, 0, 1.27778],
            "8721": [0.55001, 1.05, 0, 0, 1.44445],
            "8730": [0.65002, 1.15, 0, 0, 1],
            "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8896": [0.55001, 1.05, 0, 0, 1.11111],
            "8897": [0.55001, 1.05, 0, 0, 1.11111],
            "8898": [0.55001, 1.05, 0, 0, 1.11111],
            "8899": [0.55001, 1.05, 0, 0, 1.11111],
            "8968": [0.65002, 1.15, 0, 0, 0.52778],
            "8969": [0.65002, 1.15, 0, 0, 0.52778],
            "8970": [0.65002, 1.15, 0, 0, 0.52778],
            "8971": [0.65002, 1.15, 0, 0, 0.52778],
            "10216": [0.65002, 1.15, 0, 0, 0.61111],
            "10217": [0.65002, 1.15, 0, 0, 0.61111],
            "10752": [0.55001, 1.05, 0, 0, 1.51112],
            "10753": [0.55001, 1.05, 0, 0, 1.51112],
            "10754": [0.55001, 1.05, 0, 0, 1.51112],
            "10756": [0.55001, 1.05, 0, 0, 1.11111],
            "10758": [0.55001, 1.05, 0, 0, 1.11111]
          },
          "Size3-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.95003, 1.45, 0, 0, 0.73611],
            "41": [0.95003, 1.45, 0, 0, 0.73611],
            "47": [0.95003, 1.45, 0, 0, 1.04445],
            "91": [0.95003, 1.45, 0, 0, 0.52778],
            "92": [0.95003, 1.45, 0, 0, 1.04445],
            "93": [0.95003, 1.45, 0, 0, 0.52778],
            "123": [0.95003, 1.45, 0, 0, 0.75],
            "125": [0.95003, 1.45, 0, 0, 0.75],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1.44445],
            "732": [0, 0.75, 0, 0, 1.44445],
            "770": [0, 0.75, 0, 0, 1.44445],
            "771": [0, 0.75, 0, 0, 1.44445],
            "8730": [0.95003, 1.45, 0, 0, 1],
            "8968": [0.95003, 1.45, 0, 0, 0.58334],
            "8969": [0.95003, 1.45, 0, 0, 0.58334],
            "8970": [0.95003, 1.45, 0, 0, 0.58334],
            "8971": [0.95003, 1.45, 0, 0, 0.58334],
            "10216": [0.95003, 1.45, 0, 0, 0.75],
            "10217": [0.95003, 1.45, 0, 0, 0.75]
          },
          "Size4-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [1.25003, 1.75, 0, 0, 0.79167],
            "41": [1.25003, 1.75, 0, 0, 0.79167],
            "47": [1.25003, 1.75, 0, 0, 1.27778],
            "91": [1.25003, 1.75, 0, 0, 0.58334],
            "92": [1.25003, 1.75, 0, 0, 1.27778],
            "93": [1.25003, 1.75, 0, 0, 0.58334],
            "123": [1.25003, 1.75, 0, 0, 0.80556],
            "125": [1.25003, 1.75, 0, 0, 0.80556],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.825, 0, 0, 1.8889],
            "732": [0, 0.825, 0, 0, 1.8889],
            "770": [0, 0.825, 0, 0, 1.8889],
            "771": [0, 0.825, 0, 0, 1.8889],
            "8730": [1.25003, 1.75, 0, 0, 1],
            "8968": [1.25003, 1.75, 0, 0, 0.63889],
            "8969": [1.25003, 1.75, 0, 0, 0.63889],
            "8970": [1.25003, 1.75, 0, 0, 0.63889],
            "8971": [1.25003, 1.75, 0, 0, 0.63889],
            "9115": [0.64502, 1.155, 0, 0, 0.875],
            "9116": [1e-5, 0.6, 0, 0, 0.875],
            "9117": [0.64502, 1.155, 0, 0, 0.875],
            "9118": [0.64502, 1.155, 0, 0, 0.875],
            "9119": [1e-5, 0.6, 0, 0, 0.875],
            "9120": [0.64502, 1.155, 0, 0, 0.875],
            "9121": [0.64502, 1.155, 0, 0, 0.66667],
            "9122": [-99e-5, 0.601, 0, 0, 0.66667],
            "9123": [0.64502, 1.155, 0, 0, 0.66667],
            "9124": [0.64502, 1.155, 0, 0, 0.66667],
            "9125": [-99e-5, 0.601, 0, 0, 0.66667],
            "9126": [0.64502, 1.155, 0, 0, 0.66667],
            "9127": [1e-5, 0.9, 0, 0, 0.88889],
            "9128": [0.65002, 1.15, 0, 0, 0.88889],
            "9129": [0.90001, 0, 0, 0, 0.88889],
            "9130": [0, 0.3, 0, 0, 0.88889],
            "9131": [1e-5, 0.9, 0, 0, 0.88889],
            "9132": [0.65002, 1.15, 0, 0, 0.88889],
            "9133": [0.90001, 0, 0, 0, 0.88889],
            "9143": [0.88502, 0.915, 0, 0, 1.05556],
            "10216": [1.25003, 1.75, 0, 0, 0.80556],
            "10217": [1.25003, 1.75, 0, 0, 0.80556],
            "57344": [-499e-5, 0.605, 0, 0, 1.05556],
            "57345": [-499e-5, 0.605, 0, 0, 1.05556],
            "57680": [0, 0.12, 0, 0, 0.45],
            "57681": [0, 0.12, 0, 0, 0.45],
            "57682": [0, 0.12, 0, 0, 0.45],
            "57683": [0, 0.12, 0, 0, 0.45]
          },
          "Typewriter-Regular": {
            "32": [0, 0, 0, 0, 0.525],
            "33": [0, 0.61111, 0, 0, 0.525],
            "34": [0, 0.61111, 0, 0, 0.525],
            "35": [0, 0.61111, 0, 0, 0.525],
            "36": [0.08333, 0.69444, 0, 0, 0.525],
            "37": [0.08333, 0.69444, 0, 0, 0.525],
            "38": [0, 0.61111, 0, 0, 0.525],
            "39": [0, 0.61111, 0, 0, 0.525],
            "40": [0.08333, 0.69444, 0, 0, 0.525],
            "41": [0.08333, 0.69444, 0, 0, 0.525],
            "42": [0, 0.52083, 0, 0, 0.525],
            "43": [-0.08056, 0.53055, 0, 0, 0.525],
            "44": [0.13889, 0.125, 0, 0, 0.525],
            "45": [-0.08056, 0.53055, 0, 0, 0.525],
            "46": [0, 0.125, 0, 0, 0.525],
            "47": [0.08333, 0.69444, 0, 0, 0.525],
            "48": [0, 0.61111, 0, 0, 0.525],
            "49": [0, 0.61111, 0, 0, 0.525],
            "50": [0, 0.61111, 0, 0, 0.525],
            "51": [0, 0.61111, 0, 0, 0.525],
            "52": [0, 0.61111, 0, 0, 0.525],
            "53": [0, 0.61111, 0, 0, 0.525],
            "54": [0, 0.61111, 0, 0, 0.525],
            "55": [0, 0.61111, 0, 0, 0.525],
            "56": [0, 0.61111, 0, 0, 0.525],
            "57": [0, 0.61111, 0, 0, 0.525],
            "58": [0, 0.43056, 0, 0, 0.525],
            "59": [0.13889, 0.43056, 0, 0, 0.525],
            "60": [-0.05556, 0.55556, 0, 0, 0.525],
            "61": [-0.19549, 0.41562, 0, 0, 0.525],
            "62": [-0.05556, 0.55556, 0, 0, 0.525],
            "63": [0, 0.61111, 0, 0, 0.525],
            "64": [0, 0.61111, 0, 0, 0.525],
            "65": [0, 0.61111, 0, 0, 0.525],
            "66": [0, 0.61111, 0, 0, 0.525],
            "67": [0, 0.61111, 0, 0, 0.525],
            "68": [0, 0.61111, 0, 0, 0.525],
            "69": [0, 0.61111, 0, 0, 0.525],
            "70": [0, 0.61111, 0, 0, 0.525],
            "71": [0, 0.61111, 0, 0, 0.525],
            "72": [0, 0.61111, 0, 0, 0.525],
            "73": [0, 0.61111, 0, 0, 0.525],
            "74": [0, 0.61111, 0, 0, 0.525],
            "75": [0, 0.61111, 0, 0, 0.525],
            "76": [0, 0.61111, 0, 0, 0.525],
            "77": [0, 0.61111, 0, 0, 0.525],
            "78": [0, 0.61111, 0, 0, 0.525],
            "79": [0, 0.61111, 0, 0, 0.525],
            "80": [0, 0.61111, 0, 0, 0.525],
            "81": [0.13889, 0.61111, 0, 0, 0.525],
            "82": [0, 0.61111, 0, 0, 0.525],
            "83": [0, 0.61111, 0, 0, 0.525],
            "84": [0, 0.61111, 0, 0, 0.525],
            "85": [0, 0.61111, 0, 0, 0.525],
            "86": [0, 0.61111, 0, 0, 0.525],
            "87": [0, 0.61111, 0, 0, 0.525],
            "88": [0, 0.61111, 0, 0, 0.525],
            "89": [0, 0.61111, 0, 0, 0.525],
            "90": [0, 0.61111, 0, 0, 0.525],
            "91": [0.08333, 0.69444, 0, 0, 0.525],
            "92": [0.08333, 0.69444, 0, 0, 0.525],
            "93": [0.08333, 0.69444, 0, 0, 0.525],
            "94": [0, 0.61111, 0, 0, 0.525],
            "95": [0.09514, 0, 0, 0, 0.525],
            "96": [0, 0.61111, 0, 0, 0.525],
            "97": [0, 0.43056, 0, 0, 0.525],
            "98": [0, 0.61111, 0, 0, 0.525],
            "99": [0, 0.43056, 0, 0, 0.525],
            "100": [0, 0.61111, 0, 0, 0.525],
            "101": [0, 0.43056, 0, 0, 0.525],
            "102": [0, 0.61111, 0, 0, 0.525],
            "103": [0.22222, 0.43056, 0, 0, 0.525],
            "104": [0, 0.61111, 0, 0, 0.525],
            "105": [0, 0.61111, 0, 0, 0.525],
            "106": [0.22222, 0.61111, 0, 0, 0.525],
            "107": [0, 0.61111, 0, 0, 0.525],
            "108": [0, 0.61111, 0, 0, 0.525],
            "109": [0, 0.43056, 0, 0, 0.525],
            "110": [0, 0.43056, 0, 0, 0.525],
            "111": [0, 0.43056, 0, 0, 0.525],
            "112": [0.22222, 0.43056, 0, 0, 0.525],
            "113": [0.22222, 0.43056, 0, 0, 0.525],
            "114": [0, 0.43056, 0, 0, 0.525],
            "115": [0, 0.43056, 0, 0, 0.525],
            "116": [0, 0.55358, 0, 0, 0.525],
            "117": [0, 0.43056, 0, 0, 0.525],
            "118": [0, 0.43056, 0, 0, 0.525],
            "119": [0, 0.43056, 0, 0, 0.525],
            "120": [0, 0.43056, 0, 0, 0.525],
            "121": [0.22222, 0.43056, 0, 0, 0.525],
            "122": [0, 0.43056, 0, 0, 0.525],
            "123": [0.08333, 0.69444, 0, 0, 0.525],
            "124": [0.08333, 0.69444, 0, 0, 0.525],
            "125": [0.08333, 0.69444, 0, 0, 0.525],
            "126": [0, 0.61111, 0, 0, 0.525],
            "127": [0, 0.61111, 0, 0, 0.525],
            "160": [0, 0, 0, 0, 0.525],
            "176": [0, 0.61111, 0, 0, 0.525],
            "184": [0.19445, 0, 0, 0, 0.525],
            "305": [0, 0.43056, 0, 0, 0.525],
            "567": [0.22222, 0.43056, 0, 0, 0.525],
            "711": [0, 0.56597, 0, 0, 0.525],
            "713": [0, 0.56555, 0, 0, 0.525],
            "714": [0, 0.61111, 0, 0, 0.525],
            "715": [0, 0.61111, 0, 0, 0.525],
            "728": [0, 0.61111, 0, 0, 0.525],
            "730": [0, 0.61111, 0, 0, 0.525],
            "770": [0, 0.61111, 0, 0, 0.525],
            "771": [0, 0.61111, 0, 0, 0.525],
            "776": [0, 0.61111, 0, 0, 0.525],
            "915": [0, 0.61111, 0, 0, 0.525],
            "916": [0, 0.61111, 0, 0, 0.525],
            "920": [0, 0.61111, 0, 0, 0.525],
            "923": [0, 0.61111, 0, 0, 0.525],
            "926": [0, 0.61111, 0, 0, 0.525],
            "928": [0, 0.61111, 0, 0, 0.525],
            "931": [0, 0.61111, 0, 0, 0.525],
            "933": [0, 0.61111, 0, 0, 0.525],
            "934": [0, 0.61111, 0, 0, 0.525],
            "936": [0, 0.61111, 0, 0, 0.525],
            "937": [0, 0.61111, 0, 0, 0.525],
            "8216": [0, 0.61111, 0, 0, 0.525],
            "8217": [0, 0.61111, 0, 0, 0.525],
            "8242": [0, 0.61111, 0, 0, 0.525],
            "9251": [0.11111, 0.21944, 0, 0, 0.525]
          }
        };
        ;
        const sigmasAndXis = {
          slant: [0.25, 0.25, 0.25],
          space: [0, 0, 0],
          stretch: [0, 0, 0],
          shrink: [0, 0, 0],
          xHeight: [0.431, 0.431, 0.431],
          quad: [1, 1.171, 1.472],
          extraSpace: [0, 0, 0],
          num1: [0.677, 0.732, 0.925],
          num2: [0.394, 0.384, 0.387],
          num3: [0.444, 0.471, 0.504],
          denom1: [0.686, 0.752, 1.025],
          denom2: [0.345, 0.344, 0.532],
          sup1: [0.413, 0.503, 0.504],
          sup2: [0.363, 0.431, 0.404],
          sup3: [0.289, 0.286, 0.294],
          sub1: [0.15, 0.143, 0.2],
          sub2: [0.247, 0.286, 0.4],
          supDrop: [0.386, 0.353, 0.494],
          subDrop: [0.05, 0.071, 0.1],
          delim1: [2.39, 1.7, 1.98],
          delim2: [1.01, 1.157, 1.42],
          axisHeight: [0.25, 0.25, 0.25],
          defaultRuleThickness: [0.04, 0.049, 0.049],
          bigOpSpacing1: [0.111, 0.111, 0.111],
          bigOpSpacing2: [0.166, 0.166, 0.166],
          bigOpSpacing3: [0.2, 0.2, 0.2],
          bigOpSpacing4: [0.6, 0.611, 0.611],
          bigOpSpacing5: [0.1, 0.143, 0.143],
          sqrtRuleThickness: [0.04, 0.04, 0.04],
          ptPerEm: [10, 10, 10],
          doubleRuleSep: [0.2, 0.2, 0.2],
          arrayRuleWidth: [0.04, 0.04, 0.04],
          fboxsep: [0.3, 0.3, 0.3],
          fboxrule: [0.04, 0.04, 0.04]
        };
        const extraCharacterMap = {
          "\xC5": "A",
          "\xD0": "D",
          "\xDE": "o",
          "\xE5": "a",
          "\xF0": "d",
          "\xFE": "o",
          "\u0410": "A",
          "\u0411": "B",
          "\u0412": "B",
          "\u0413": "F",
          "\u0414": "A",
          "\u0415": "E",
          "\u0416": "K",
          "\u0417": "3",
          "\u0418": "N",
          "\u0419": "N",
          "\u041A": "K",
          "\u041B": "N",
          "\u041C": "M",
          "\u041D": "H",
          "\u041E": "O",
          "\u041F": "N",
          "\u0420": "P",
          "\u0421": "C",
          "\u0422": "T",
          "\u0423": "y",
          "\u0424": "O",
          "\u0425": "X",
          "\u0426": "U",
          "\u0427": "h",
          "\u0428": "W",
          "\u0429": "W",
          "\u042A": "B",
          "\u042B": "X",
          "\u042C": "B",
          "\u042D": "3",
          "\u042E": "X",
          "\u042F": "R",
          "\u0430": "a",
          "\u0431": "b",
          "\u0432": "a",
          "\u0433": "r",
          "\u0434": "y",
          "\u0435": "e",
          "\u0436": "m",
          "\u0437": "e",
          "\u0438": "n",
          "\u0439": "n",
          "\u043A": "n",
          "\u043B": "n",
          "\u043C": "m",
          "\u043D": "n",
          "\u043E": "o",
          "\u043F": "n",
          "\u0440": "p",
          "\u0441": "c",
          "\u0442": "o",
          "\u0443": "y",
          "\u0444": "b",
          "\u0445": "x",
          "\u0446": "n",
          "\u0447": "n",
          "\u0448": "w",
          "\u0449": "w",
          "\u044A": "a",
          "\u044B": "m",
          "\u044C": "a",
          "\u044D": "e",
          "\u044E": "m",
          "\u044F": "r"
        };
        function setFontMetrics(fontName, metrics) {
          fontMetricsData[fontName] = metrics;
        }
        function getCharacterMetrics(character, font, mode) {
          if (!fontMetricsData[font]) {
            throw new Error("Font metrics not found for font: " + font + ".");
          }
          let ch = character.charCodeAt(0);
          let metrics = fontMetricsData[font][ch];
          if (!metrics && character[0] in extraCharacterMap) {
            ch = extraCharacterMap[character[0]].charCodeAt(0);
            metrics = fontMetricsData[font][ch];
          }
          if (!metrics && mode === "text") {
            if (supportedCodepoint(ch)) {
              metrics = fontMetricsData[font][77];
            }
          }
          if (metrics) {
            return {
              depth: metrics[0],
              height: metrics[1],
              italic: metrics[2],
              skew: metrics[3],
              width: metrics[4]
            };
          }
        }
        const fontMetricsBySizeIndex = {};
        function getGlobalMetrics(size) {
          let sizeIndex;
          if (size >= 5) {
            sizeIndex = 0;
          } else if (size >= 3) {
            sizeIndex = 1;
          } else {
            sizeIndex = 2;
          }
          if (!fontMetricsBySizeIndex[sizeIndex]) {
            const metrics = fontMetricsBySizeIndex[sizeIndex] = {
              cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
            };
            for (const key in sigmasAndXis) {
              if (sigmasAndXis.hasOwnProperty(key)) {
                metrics[key] = sigmasAndXis[key][sizeIndex];
              }
            }
          }
          return fontMetricsBySizeIndex[sizeIndex];
        }
        ;
        const sizeStyleMap = [
          [1, 1, 1],
          [2, 1, 1],
          [3, 1, 1],
          [4, 2, 1],
          [5, 2, 1],
          [6, 3, 1],
          [7, 4, 2],
          [8, 6, 3],
          [9, 7, 6],
          [10, 8, 7],
          [11, 10, 9]
        ];
        const sizeMultipliers = [
          0.5,
          0.6,
          0.7,
          0.8,
          0.9,
          1,
          1.2,
          1.44,
          1.728,
          2.074,
          2.488
        ];
        const sizeAtStyle = function(size, style) {
          return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
        };
        class Options {
          constructor(data) {
            this.style = void 0;
            this.color = void 0;
            this.size = void 0;
            this.textSize = void 0;
            this.phantom = void 0;
            this.font = void 0;
            this.fontFamily = void 0;
            this.fontWeight = void 0;
            this.fontShape = void 0;
            this.sizeMultiplier = void 0;
            this.maxSize = void 0;
            this.minRuleThickness = void 0;
            this._fontMetrics = void 0;
            this.style = data.style;
            this.color = data.color;
            this.size = data.size || Options.BASESIZE;
            this.textSize = data.textSize || this.size;
            this.phantom = !!data.phantom;
            this.font = data.font || "";
            this.fontFamily = data.fontFamily || "";
            this.fontWeight = data.fontWeight || "";
            this.fontShape = data.fontShape || "";
            this.sizeMultiplier = sizeMultipliers[this.size - 1];
            this.maxSize = data.maxSize;
            this.minRuleThickness = data.minRuleThickness;
            this._fontMetrics = void 0;
          }
          extend(extension) {
            const data = {
              style: this.style,
              size: this.size,
              textSize: this.textSize,
              color: this.color,
              phantom: this.phantom,
              font: this.font,
              fontFamily: this.fontFamily,
              fontWeight: this.fontWeight,
              fontShape: this.fontShape,
              maxSize: this.maxSize,
              minRuleThickness: this.minRuleThickness
            };
            for (const key in extension) {
              if (extension.hasOwnProperty(key)) {
                data[key] = extension[key];
              }
            }
            return new Options(data);
          }
          havingStyle(style) {
            if (this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: sizeAtStyle(this.textSize, style)
              });
            }
          }
          havingCrampedStyle() {
            return this.havingStyle(this.style.cramp());
          }
          havingSize(size) {
            if (this.size === size && this.textSize === size) {
              return this;
            } else {
              return this.extend({
                style: this.style.text(),
                size,
                textSize: size,
                sizeMultiplier: sizeMultipliers[size - 1]
              });
            }
          }
          havingBaseStyle(style) {
            style = style || this.style.text();
            const wantSize = sizeAtStyle(Options.BASESIZE, style);
            if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: wantSize
              });
            }
          }
          havingBaseSizing() {
            let size;
            switch (this.style.id) {
              case 4:
              case 5:
                size = 3;
                break;
              case 6:
              case 7:
                size = 1;
                break;
              default:
                size = 6;
            }
            return this.extend({
              style: this.style.text(),
              size
            });
          }
          withColor(color) {
            return this.extend({
              color
            });
          }
          withPhantom() {
            return this.extend({
              phantom: true
            });
          }
          withFont(font) {
            return this.extend({
              font
            });
          }
          withTextFontFamily(fontFamily) {
            return this.extend({
              fontFamily,
              font: ""
            });
          }
          withTextFontWeight(fontWeight) {
            return this.extend({
              fontWeight,
              font: ""
            });
          }
          withTextFontShape(fontShape) {
            return this.extend({
              fontShape,
              font: ""
            });
          }
          sizingClasses(oldOptions) {
            if (oldOptions.size !== this.size) {
              return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
            } else {
              return [];
            }
          }
          baseSizingClasses() {
            if (this.size !== Options.BASESIZE) {
              return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
            } else {
              return [];
            }
          }
          fontMetrics() {
            if (!this._fontMetrics) {
              this._fontMetrics = getGlobalMetrics(this.size);
            }
            return this._fontMetrics;
          }
          getColor() {
            if (this.phantom) {
              return "transparent";
            } else {
              return this.color;
            }
          }
        }
        Options.BASESIZE = 6;
        var src_Options = Options;
        ;
        const ptPerUnit = {
          "pt": 1,
          "mm": 7227 / 2540,
          "cm": 7227 / 254,
          "in": 72.27,
          "bp": 803 / 800,
          "pc": 12,
          "dd": 1238 / 1157,
          "cc": 14856 / 1157,
          "nd": 685 / 642,
          "nc": 1370 / 107,
          "sp": 1 / 65536,
          "px": 803 / 800
        };
        const relativeUnit = {
          "ex": true,
          "em": true,
          "mu": true
        };
        const validUnit = function(unit) {
          if (typeof unit !== "string") {
            unit = unit.unit;
          }
          return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
        };
        const calculateSize = function(sizeValue, options) {
          let scale;
          if (sizeValue.unit in ptPerUnit) {
            scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
          } else if (sizeValue.unit === "mu") {
            scale = options.fontMetrics().cssEmPerMu;
          } else {
            let unitOptions;
            if (options.style.isTight()) {
              unitOptions = options.havingStyle(options.style.text());
            } else {
              unitOptions = options;
            }
            if (sizeValue.unit === "ex") {
              scale = unitOptions.fontMetrics().xHeight;
            } else if (sizeValue.unit === "em") {
              scale = unitOptions.fontMetrics().quad;
            } else {
              throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
            }
            if (unitOptions !== options) {
              scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          return Math.min(sizeValue.number * scale, options.maxSize);
        };
        const makeEm = function(n) {
          return +n.toFixed(4) + "em";
        };
        ;
        const createClass = function(classes) {
          return classes.filter((cls) => cls).join(" ");
        };
        const initNode = function(classes, options, style) {
          this.classes = classes || [];
          this.attributes = {};
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = style || {};
          if (options) {
            if (options.style.isTight()) {
              this.classes.push("mtight");
            }
            const color = options.getColor();
            if (color) {
              this.style.color = color;
            }
          }
        };
        const toNode = function(tagName) {
          const node = document.createElement(tagName);
          node.className = createClass(this.classes);
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          for (const attr in this.attributes) {
            if (this.attributes.hasOwnProperty(attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (let i = 0; i < this.children.length; i++) {
            node.appendChild(this.children[i].toNode());
          }
          return node;
        };
        const invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
        const toMarkup = function(tagName) {
          let markup = "<" + tagName;
          if (this.classes.length) {
            markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
          }
          let styles2 = "";
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          for (const attr in this.attributes) {
            if (this.attributes.hasOwnProperty(attr)) {
              if (invalidAttributeNameRegex.test(attr)) {
                throw new src_ParseError("Invalid attribute name '" + attr + "'");
              }
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (let i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</" + tagName + ">";
          return markup;
        };
        class Span {
          constructor(classes, children, options, style) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options, style);
            this.children = children || [];
          }
          setAttribute(attribute, value) {
            this.attributes[attribute] = value;
          }
          hasClass(className) {
            return this.classes.includes(className);
          }
          toNode() {
            return toNode.call(this, "span");
          }
          toMarkup() {
            return toMarkup.call(this, "span");
          }
        }
        class Anchor {
          constructor(href, classes, children, options) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options);
            this.children = children || [];
            this.setAttribute("href", href);
          }
          setAttribute(attribute, value) {
            this.attributes[attribute] = value;
          }
          hasClass(className) {
            return this.classes.includes(className);
          }
          toNode() {
            return toNode.call(this, "a");
          }
          toMarkup() {
            return toMarkup.call(this, "a");
          }
        }
        class Img {
          constructor(src, alt, style) {
            this.src = void 0;
            this.alt = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.alt = alt;
            this.src = src;
            this.classes = ["mord"];
            this.style = style;
          }
          hasClass(className) {
            return this.classes.includes(className);
          }
          toNode() {
            const node = document.createElement("img");
            node.src = this.src;
            node.alt = this.alt;
            node.className = "mord";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node.style[style] = this.style[style];
              }
            }
            return node;
          }
          toMarkup() {
            let markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
            let styles2 = "";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            markup += "'/>";
            return markup;
          }
        }
        const iCombinations = {
          "\xEE": "\u0131\u0302",
          "\xEF": "\u0131\u0308",
          "\xED": "\u0131\u0301",
          "\xEC": "\u0131\u0300"
        };
        class SymbolNode {
          constructor(text, height, depth, italic, skew, width, classes, style) {
            this.text = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.italic = void 0;
            this.skew = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.classes = void 0;
            this.style = void 0;
            this.text = text;
            this.height = height || 0;
            this.depth = depth || 0;
            this.italic = italic || 0;
            this.skew = skew || 0;
            this.width = width || 0;
            this.classes = classes || [];
            this.style = style || {};
            this.maxFontSize = 0;
            const script = scriptFromCodepoint(this.text.charCodeAt(0));
            if (script) {
              this.classes.push(script + "_fallback");
            }
            if (/[]/.test(this.text)) {
              this.text = iCombinations[this.text];
            }
          }
          hasClass(className) {
            return this.classes.includes(className);
          }
          toNode() {
            const node = document.createTextNode(this.text);
            let span = null;
            if (this.italic > 0) {
              span = document.createElement("span");
              span.style.marginRight = makeEm(this.italic);
            }
            if (this.classes.length > 0) {
              span = span || document.createElement("span");
              span.className = createClass(this.classes);
            }
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                span = span || document.createElement("span");
                span.style[style] = this.style[style];
              }
            }
            if (span) {
              span.appendChild(node);
              return span;
            } else {
              return node;
            }
          }
          toMarkup() {
            let needsSpan = false;
            let markup = "<span";
            if (this.classes.length) {
              needsSpan = true;
              markup += ' class="';
              markup += utils.escape(createClass(this.classes));
              markup += '"';
            }
            let styles2 = "";
            if (this.italic > 0) {
              styles2 += "margin-right:" + this.italic + "em;";
            }
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              needsSpan = true;
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            const escaped = utils.escape(this.text);
            if (needsSpan) {
              markup += ">";
              markup += escaped;
              markup += "</span>";
              return markup;
            } else {
              return escaped;
            }
          }
        }
        class SvgNode {
          constructor(children, attributes) {
            this.children = void 0;
            this.attributes = void 0;
            this.children = children || [];
            this.attributes = attributes || {};
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node = document.createElementNS(svgNS, "svg");
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            for (let i = 0; i < this.children.length; i++) {
              node.appendChild(this.children[i].toNode());
            }
            return node;
          }
          toMarkup() {
            let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
              }
            }
            markup += ">";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</svg>";
            return markup;
          }
        }
        class PathNode {
          constructor(pathName, alternate) {
            this.pathName = void 0;
            this.alternate = void 0;
            this.pathName = pathName;
            this.alternate = alternate;
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node = document.createElementNS(svgNS, "path");
            if (this.alternate) {
              node.setAttribute("d", this.alternate);
            } else {
              node.setAttribute("d", path[this.pathName]);
            }
            return node;
          }
          toMarkup() {
            if (this.alternate) {
              return '<path d="' + utils.escape(this.alternate) + '"/>';
            } else {
              return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
            }
          }
        }
        class LineNode {
          constructor(attributes) {
            this.attributes = void 0;
            this.attributes = attributes || {};
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node = document.createElementNS(svgNS, "line");
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            return node;
          }
          toMarkup() {
            let markup = "<line";
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
              }
            }
            markup += "/>";
            return markup;
          }
        }
        function assertSymbolDomNode(group) {
          if (group instanceof SymbolNode) {
            return group;
          } else {
            throw new Error("Expected symbolNode but got " + String(group) + ".");
          }
        }
        function assertSpan(group) {
          if (group instanceof Span) {
            return group;
          } else {
            throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
          }
        }
        ;
        const ATOMS = {
          "bin": 1,
          "close": 1,
          "inner": 1,
          "open": 1,
          "punct": 1,
          "rel": 1
        };
        const NON_ATOMS = {
          "accent-token": 1,
          "mathord": 1,
          "op-token": 1,
          "spacing": 1,
          "textord": 1
        };
        const symbols = {
          "math": {},
          "text": {}
        };
        var src_symbols = symbols;
        function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
          symbols[mode][name] = {
            font,
            group,
            replace
          };
          if (acceptUnicodeChar && replace) {
            symbols[mode][replace] = symbols[mode][name];
          }
        }
        const math = "math";
        const symbols_text = "text";
        const main = "main";
        const ams = "ams";
        const accent = "accent-token";
        const bin = "bin";
        const symbols_close = "close";
        const inner = "inner";
        const mathord = "mathord";
        const op = "op-token";
        const symbols_open = "open";
        const punct = "punct";
        const rel = "rel";
        const spacing = "spacing";
        const textord = "textord";
        defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
        defineSymbol(math, main, rel, "\u227A", "\\prec", true);
        defineSymbol(math, main, rel, "\u227B", "\\succ", true);
        defineSymbol(math, main, rel, "\u223C", "\\sim", true);
        defineSymbol(math, main, rel, "\u22A5", "\\perp");
        defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
        defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
        defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
        defineSymbol(math, main, rel, "\u2223", "\\mid", true);
        defineSymbol(math, main, rel, "\u226A", "\\ll", true);
        defineSymbol(math, main, rel, "\u226B", "\\gg", true);
        defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
        defineSymbol(math, main, rel, "\u2225", "\\parallel");
        defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
        defineSymbol(math, main, rel, "\u2323", "\\smile", true);
        defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
        defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
        defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
        defineSymbol(math, main, rel, "\u2322", "\\frown", true);
        defineSymbol(math, main, rel, "\u220B", "\\ni", true);
        defineSymbol(math, main, rel, "\u221D", "\\propto", true);
        defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
        defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
        defineSymbol(math, main, rel, "\u220B", "\\owns");
        defineSymbol(math, main, punct, ".", "\\ldotp");
        defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
        defineSymbol(math, main, textord, "#", "\\#");
        defineSymbol(symbols_text, main, textord, "#", "\\#");
        defineSymbol(math, main, textord, "&", "\\&");
        defineSymbol(symbols_text, main, textord, "&", "\\&");
        defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
        defineSymbol(math, main, textord, "\u2200", "\\forall", true);
        defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
        defineSymbol(math, main, textord, "\u2203", "\\exists", true);
        defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
        defineSymbol(math, main, textord, "\u266D", "\\flat", true);
        defineSymbol(math, main, textord, "\u2113", "\\ell", true);
        defineSymbol(math, main, textord, "\u266E", "\\natural", true);
        defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
        defineSymbol(math, main, textord, "\u2118", "\\wp", true);
        defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
        defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
        defineSymbol(math, main, textord, "\u211C", "\\Re", true);
        defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
        defineSymbol(math, main, textord, "\u2111", "\\Im", true);
        defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
        defineSymbol(math, main, textord, "\xA7", "\\S", true);
        defineSymbol(symbols_text, main, textord, "\xA7", "\\S");
        defineSymbol(math, main, textord, "\xB6", "\\P", true);
        defineSymbol(symbols_text, main, textord, "\xB6", "\\P");
        defineSymbol(math, main, textord, "\u2020", "\\dag");
        defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
        defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
        defineSymbol(math, main, textord, "\u2021", "\\ddag");
        defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
        defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl");
        defineSymbol(math, main, symbols_close, "\u23B1", "\\rmoustache", true);
        defineSymbol(math, main, symbols_open, "\u23B0", "\\lmoustache", true);
        defineSymbol(math, main, symbols_close, "\u27EF", "\\rgroup", true);
        defineSymbol(math, main, symbols_open, "\u27EE", "\\lgroup", true);
        defineSymbol(math, main, bin, "\u2213", "\\mp", true);
        defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
        defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
        defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
        defineSymbol(math, main, bin, "\u2217", "\\ast");
        defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
        defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
        defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
        defineSymbol(math, main, bin, "\u2021", "\\ddagger");
        defineSymbol(math, main, bin, "\u2240", "\\wr", true);
        defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
        defineSymbol(math, main, bin, "&", "\\And");
        defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
        defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
        defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
        defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
        defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
        defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
        defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
        defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
        defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
        defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
        defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
        defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
        defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
        defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
        defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
        defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
        defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
        defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
        defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
        defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
        defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
        defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
        defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
        defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
        defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
        defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
        defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
        defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
        defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
        defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
        defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
        defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
        defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
        defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
        defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
        defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
        defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
        defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
        defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
        defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
        defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
        defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
        defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
        defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
        defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
        defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
        defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
        defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
        defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
        defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
        defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
        defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
        defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
        defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
        defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
        defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
        defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
        defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
        defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
        defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
        defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
        defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
        defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
        defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
        defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
        defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
        defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
        defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
        defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
        defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
        defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
        defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
        defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
        defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
        defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
        defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
        defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
        defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
        defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
        defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
        defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
        defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
        defineSymbol(math, ams, textord, "\u210F", "\\hslash");
        defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
        defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
        defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
        defineSymbol(math, ams, textord, "\xAE", "\\circledR");
        defineSymbol(symbols_text, ams, textord, "\xAE", "\\circledR");
        defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
        defineSymbol(math, ams, textord, "\u2204", "\\nexists");
        defineSymbol(math, ams, textord, "\u2127", "\\mho");
        defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
        defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
        defineSymbol(math, ams, textord, "\u2035", "\\backprime");
        defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
        defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
        defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
        defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
        defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
        defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
        defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
        defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
        defineSymbol(symbols_text, main, textord, "\xF0", "\xF0");
        defineSymbol(math, ams, textord, "\u2571", "\\diagup");
        defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
        defineSymbol(math, ams, textord, "\u25A1", "\\square");
        defineSymbol(math, ams, textord, "\u25A1", "\\Box");
        defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
        defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
        defineSymbol(symbols_text, ams, textord, "\xA5", "\\yen", true);
        defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
        defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark");
        defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
        defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
        defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
        defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
        defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
        defineSymbol(math, ams, symbols_open, "\u250C", "\\@ulcorner", true);
        defineSymbol(math, ams, symbols_close, "\u2510", "\\@urcorner", true);
        defineSymbol(math, ams, symbols_open, "\u2514", "\\@llcorner", true);
        defineSymbol(math, ams, symbols_close, "\u2518", "\\@lrcorner", true);
        defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
        defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
        defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
        defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
        defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
        defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
        defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
        defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
        defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
        defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
        defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
        defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
        defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
        defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
        defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
        defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
        defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
        defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
        defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
        defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
        defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
        defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
        defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
        defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
        defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
        defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
        defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
        defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
        defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
        defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
        defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
        defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
        defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
        defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
        defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
        defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
        defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
        defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
        defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
        defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
        defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
        defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
        defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
        defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
        defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
        defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
        defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
        defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
        defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
        defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
        defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
        defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
        defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
        defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
        defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
        defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
        defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
        defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
        defineSymbol(math, ams, rel, "\u226C", "\\between", true);
        defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
        defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
        defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
        defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
        defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
        defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
        defineSymbol(math, ams, rel, "\u2235", "\\because", true);
        defineSymbol(math, ams, rel, "\u22D8", "\\llless");
        defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
        defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
        defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
        defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
        defineSymbol(math, main, rel, "\u22C8", "\\Join");
        defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
        defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
        defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
        defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
        defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
        defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
        defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
        defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
        defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
        defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
        defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
        defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
        defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
        defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
        defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
        defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
        defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
        defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
        defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
        defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
        defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
        defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
        defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
        defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
        defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
        defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
        defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
        defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
        defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
        defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
        defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
        defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
        defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
        defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
        defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
        defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
        defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
        defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
        defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
        defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
        defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
        defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
        defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
        defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
        defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
        defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
        defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
        defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
        defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
        defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
        defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
        defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
        defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
        defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
        defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
        defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
        defineSymbol(math, main, textord, "\u2018", "`");
        defineSymbol(math, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
        defineSymbol(math, main, textord, "%", "\\%");
        defineSymbol(symbols_text, main, textord, "%", "\\%");
        defineSymbol(math, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
        defineSymbol(math, main, textord, "\u2220", "\\angle", true);
        defineSymbol(math, main, textord, "\u221E", "\\infty", true);
        defineSymbol(math, main, textord, "\u2032", "\\prime");
        defineSymbol(math, main, textord, "\u25B3", "\\triangle");
        defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
        defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
        defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
        defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
        defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
        defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
        defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
        defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
        defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
        defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
        defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
        defineSymbol(math, main, textord, "A", "\u0391");
        defineSymbol(math, main, textord, "B", "\u0392");
        defineSymbol(math, main, textord, "E", "\u0395");
        defineSymbol(math, main, textord, "Z", "\u0396");
        defineSymbol(math, main, textord, "H", "\u0397");
        defineSymbol(math, main, textord, "I", "\u0399");
        defineSymbol(math, main, textord, "K", "\u039A");
        defineSymbol(math, main, textord, "M", "\u039C");
        defineSymbol(math, main, textord, "N", "\u039D");
        defineSymbol(math, main, textord, "O", "\u039F");
        defineSymbol(math, main, textord, "P", "\u03A1");
        defineSymbol(math, main, textord, "T", "\u03A4");
        defineSymbol(math, main, textord, "X", "\u03A7");
        defineSymbol(math, main, textord, "\xAC", "\\neg", true);
        defineSymbol(math, main, textord, "\xAC", "\\lnot");
        defineSymbol(math, main, textord, "\u22A4", "\\top");
        defineSymbol(math, main, textord, "\u22A5", "\\bot");
        defineSymbol(math, main, textord, "\u2205", "\\emptyset");
        defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
        defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
        defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
        defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
        defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
        defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
        defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
        defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
        defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
        defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
        defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
        defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
        defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
        defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
        defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
        defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
        defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
        defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
        defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
        defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
        defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
        defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
        defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
        defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
        defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
        defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
        defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
        defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
        defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
        defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
        defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
        defineSymbol(math, main, bin, "\u2217", "*", true);
        defineSymbol(math, main, bin, "+", "+");
        defineSymbol(math, main, bin, "\u2212", "-", true);
        defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
        defineSymbol(math, main, bin, "\u2218", "\\circ", true);
        defineSymbol(math, main, bin, "\xF7", "\\div", true);
        defineSymbol(math, main, bin, "\xB1", "\\pm", true);
        defineSymbol(math, main, bin, "\xD7", "\\times", true);
        defineSymbol(math, main, bin, "\u2229", "\\cap", true);
        defineSymbol(math, main, bin, "\u222A", "\\cup", true);
        defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
        defineSymbol(math, main, bin, "\u2227", "\\land");
        defineSymbol(math, main, bin, "\u2228", "\\lor");
        defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
        defineSymbol(math, main, bin, "\u2228", "\\vee", true);
        defineSymbol(math, main, textord, "\u221A", "\\surd");
        defineSymbol(math, main, symbols_open, "\u27E8", "\\langle", true);
        defineSymbol(math, main, symbols_open, "\u2223", "\\lvert");
        defineSymbol(math, main, symbols_open, "\u2225", "\\lVert");
        defineSymbol(math, main, symbols_close, "?", "?");
        defineSymbol(math, main, symbols_close, "!", "!");
        defineSymbol(math, main, symbols_close, "\u27E9", "\\rangle", true);
        defineSymbol(math, main, symbols_close, "\u2223", "\\rvert");
        defineSymbol(math, main, symbols_close, "\u2225", "\\rVert");
        defineSymbol(math, main, rel, "=", "=");
        defineSymbol(math, main, rel, ":", ":");
        defineSymbol(math, main, rel, "\u2248", "\\approx", true);
        defineSymbol(math, main, rel, "\u2245", "\\cong", true);
        defineSymbol(math, main, rel, "\u2265", "\\ge");
        defineSymbol(math, main, rel, "\u2265", "\\geq", true);
        defineSymbol(math, main, rel, "\u2190", "\\gets");
        defineSymbol(math, main, rel, ">", "\\gt", true);
        defineSymbol(math, main, rel, "\u2208", "\\in", true);
        defineSymbol(math, main, rel, "\uE020", "\\@not");
        defineSymbol(math, main, rel, "\u2282", "\\subset", true);
        defineSymbol(math, main, rel, "\u2283", "\\supset", true);
        defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
        defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
        defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
        defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
        defineSymbol(math, main, rel, "\u22A8", "\\models");
        defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
        defineSymbol(math, main, rel, "\u2264", "\\le");
        defineSymbol(math, main, rel, "\u2264", "\\leq", true);
        defineSymbol(math, main, rel, "<", "\\lt", true);
        defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
        defineSymbol(math, main, rel, "\u2192", "\\to");
        defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
        defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
        defineSymbol(math, main, spacing, "\xA0", "\\ ");
        defineSymbol(math, main, spacing, "\xA0", "\\space");
        defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\ ");
        defineSymbol(symbols_text, main, spacing, "\xA0", " ");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\space");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\nobreakspace");
        defineSymbol(math, main, spacing, null, "\\nobreak");
        defineSymbol(math, main, spacing, null, "\\allowbreak");
        defineSymbol(math, main, punct, ",", ",");
        defineSymbol(math, main, punct, ";", ";");
        defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
        defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
        defineSymbol(math, main, bin, "\u2299", "\\odot", true);
        defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
        defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
        defineSymbol(math, main, textord, "\u2202", "\\partial", true);
        defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
        defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
        defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
        defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
        defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
        defineSymbol(math, main, bin, "\u2020", "\\dagger");
        defineSymbol(math, main, bin, "\u22C4", "\\diamond");
        defineSymbol(math, main, bin, "\u22C6", "\\star");
        defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
        defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
        defineSymbol(math, main, symbols_open, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
        defineSymbol(math, main, symbols_close, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
        defineSymbol(math, main, symbols_open, "{", "\\lbrace");
        defineSymbol(math, main, symbols_close, "}", "\\rbrace");
        defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
        defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
        defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
        defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
        defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
        defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
        defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
        defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
        defineSymbol(math, main, symbols_open, "\u230A", "\\lfloor", true);
        defineSymbol(math, main, symbols_close, "\u230B", "\\rfloor", true);
        defineSymbol(math, main, symbols_open, "\u2308", "\\lceil", true);
        defineSymbol(math, main, symbols_close, "\u2309", "\\rceil", true);
        defineSymbol(math, main, textord, "\\", "\\backslash");
        defineSymbol(math, main, textord, "\u2223", "|");
        defineSymbol(math, main, textord, "\u2223", "\\vert");
        defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
        defineSymbol(math, main, textord, "\u2225", "\\|");
        defineSymbol(math, main, textord, "\u2225", "\\Vert");
        defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
        defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
        defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
        defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
        defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
        defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
        defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
        defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
        defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
        defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
        defineSymbol(math, main, op, "\u2210", "\\coprod");
        defineSymbol(math, main, op, "\u22C1", "\\bigvee");
        defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
        defineSymbol(math, main, op, "\u2A04", "\\biguplus");
        defineSymbol(math, main, op, "\u22C2", "\\bigcap");
        defineSymbol(math, main, op, "\u22C3", "\\bigcup");
        defineSymbol(math, main, op, "\u222B", "\\int");
        defineSymbol(math, main, op, "\u222B", "\\intop");
        defineSymbol(math, main, op, "\u222C", "\\iint");
        defineSymbol(math, main, op, "\u222D", "\\iiint");
        defineSymbol(math, main, op, "\u220F", "\\prod");
        defineSymbol(math, main, op, "\u2211", "\\sum");
        defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
        defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
        defineSymbol(math, main, op, "\u2A00", "\\bigodot");
        defineSymbol(math, main, op, "\u222E", "\\oint");
        defineSymbol(math, main, op, "\u222F", "\\oiint");
        defineSymbol(math, main, op, "\u2230", "\\oiiint");
        defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
        defineSymbol(math, main, op, "\u222B", "\\smallint");
        defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
        defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
        defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
        defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
        defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
        defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
        defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
        defineSymbol(symbols_text, main, textord, "\u22EE", "\\varvdots");
        defineSymbol(math, main, accent, "\u02CA", "\\acute");
        defineSymbol(math, main, accent, "\u02CB", "\\grave");
        defineSymbol(math, main, accent, "\xA8", "\\ddot");
        defineSymbol(math, main, accent, "~", "\\tilde");
        defineSymbol(math, main, accent, "\u02C9", "\\bar");
        defineSymbol(math, main, accent, "\u02D8", "\\breve");
        defineSymbol(math, main, accent, "\u02C7", "\\check");
        defineSymbol(math, main, accent, "^", "\\hat");
        defineSymbol(math, main, accent, "\u20D7", "\\vec");
        defineSymbol(math, main, accent, "\u02D9", "\\dot");
        defineSymbol(math, main, accent, "\u02DA", "\\mathring");
        defineSymbol(math, main, mathord, "\uE131", "\\@imath");
        defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
        defineSymbol(math, main, textord, "\u0131", "\u0131");
        defineSymbol(math, main, textord, "\u0237", "\u0237");
        defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
        defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
        defineSymbol(symbols_text, main, textord, "\xDF", "\\ss", true);
        defineSymbol(symbols_text, main, textord, "\xE6", "\\ae", true);
        defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
        defineSymbol(symbols_text, main, textord, "\xF8", "\\o", true);
        defineSymbol(symbols_text, main, textord, "\xC6", "\\AE", true);
        defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
        defineSymbol(symbols_text, main, textord, "\xD8", "\\O", true);
        defineSymbol(symbols_text, main, accent, "\u02CA", "\\'");
        defineSymbol(symbols_text, main, accent, "\u02CB", "\\`");
        defineSymbol(symbols_text, main, accent, "\u02C6", "\\^");
        defineSymbol(symbols_text, main, accent, "\u02DC", "\\~");
        defineSymbol(symbols_text, main, accent, "\u02C9", "\\=");
        defineSymbol(symbols_text, main, accent, "\u02D8", "\\u");
        defineSymbol(symbols_text, main, accent, "\u02D9", "\\.");
        defineSymbol(symbols_text, main, accent, "\xB8", "\\c");
        defineSymbol(symbols_text, main, accent, "\u02DA", "\\r");
        defineSymbol(symbols_text, main, accent, "\u02C7", "\\v");
        defineSymbol(symbols_text, main, accent, "\xA8", '\\"');
        defineSymbol(symbols_text, main, accent, "\u02DD", "\\H");
        defineSymbol(symbols_text, main, accent, "\u25EF", "\\textcircled");
        const ligatures = {
          "--": true,
          "---": true,
          "``": true,
          "''": true
        };
        defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
        defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
        defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
        defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
        defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
        defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
        defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
        defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
        defineSymbol(symbols_text, main, textord, "\u201C", "``", true);
        defineSymbol(symbols_text, main, textord, "\u201C", "\\textquotedblleft");
        defineSymbol(symbols_text, main, textord, "\u201D", "''", true);
        defineSymbol(symbols_text, main, textord, "\u201D", "\\textquotedblright");
        defineSymbol(math, main, textord, "\xB0", "\\degree", true);
        defineSymbol(symbols_text, main, textord, "\xB0", "\\degree");
        defineSymbol(symbols_text, main, textord, "\xB0", "\\textdegree", true);
        defineSymbol(math, main, textord, "\xA3", "\\pounds");
        defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
        defineSymbol(symbols_text, main, textord, "\xA3", "\\pounds");
        defineSymbol(symbols_text, main, textord, "\xA3", "\\textsterling", true);
        defineSymbol(math, ams, textord, "\u2720", "\\maltese");
        defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese");
        const mathTextSymbols = '0123456789/@."';
        for (let i = 0; i < mathTextSymbols.length; i++) {
          const ch = mathTextSymbols.charAt(i);
          defineSymbol(math, main, textord, ch, ch);
        }
        const textSymbols = '0123456789!@*()-=+";:?/.,';
        for (let i = 0; i < textSymbols.length; i++) {
          const ch = textSymbols.charAt(i);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        for (let i = 0; i < letters.length; i++) {
          const ch = letters.charAt(i);
          defineSymbol(math, main, mathord, ch, ch);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        defineSymbol(math, ams, textord, "C", "\u2102");
        defineSymbol(symbols_text, ams, textord, "C", "\u2102");
        defineSymbol(math, ams, textord, "H", "\u210D");
        defineSymbol(symbols_text, ams, textord, "H", "\u210D");
        defineSymbol(math, ams, textord, "N", "\u2115");
        defineSymbol(symbols_text, ams, textord, "N", "\u2115");
        defineSymbol(math, ams, textord, "P", "\u2119");
        defineSymbol(symbols_text, ams, textord, "P", "\u2119");
        defineSymbol(math, ams, textord, "Q", "\u211A");
        defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
        defineSymbol(math, ams, textord, "R", "\u211D");
        defineSymbol(symbols_text, ams, textord, "R", "\u211D");
        defineSymbol(math, ams, textord, "Z", "\u2124");
        defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
        defineSymbol(math, main, mathord, "h", "\u210E");
        defineSymbol(symbols_text, main, mathord, "h", "\u210E");
        let wideChar = "";
        for (let i = 0; i < letters.length; i++) {
          const ch = letters.charAt(i);
          wideChar = String.fromCharCode(55349, 56320 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56372 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56424 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56580 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56684 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56736 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56788 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56840 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56944 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          if (i < 26) {
            wideChar = String.fromCharCode(55349, 56632 + i);
            defineSymbol(math, main, mathord, ch, wideChar);
            defineSymbol(symbols_text, main, textord, ch, wideChar);
            wideChar = String.fromCharCode(55349, 56476 + i);
            defineSymbol(math, main, mathord, ch, wideChar);
            defineSymbol(symbols_text, main, textord, ch, wideChar);
          }
        }
        wideChar = String.fromCharCode(55349, 56668);
        defineSymbol(math, main, mathord, "k", wideChar);
        defineSymbol(symbols_text, main, textord, "k", wideChar);
        for (let i = 0; i < 10; i++) {
          const ch = i.toString();
          wideChar = String.fromCharCode(55349, 57294 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57314 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57324 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57334 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
        }
        const extraLatin = "\xD0\xDE\xFE";
        for (let i = 0; i < extraLatin.length; i++) {
          const ch = extraLatin.charAt(i);
          defineSymbol(math, main, mathord, ch, ch);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        ;
        const wideLatinLetterData = [
          ["mathbf", "textbf", "Main-Bold"],
          ["mathbf", "textbf", "Main-Bold"],
          ["mathnormal", "textit", "Math-Italic"],
          ["mathnormal", "textit", "Math-Italic"],
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          ["mathscr", "textscr", "Script-Regular"],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          ["mathbb", "textbb", "AMS-Regular"],
          ["mathbb", "textbb", "AMS-Regular"],
          ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
          ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          ["", "", ""],
          ["", "", ""],
          ["mathtt", "texttt", "Typewriter-Regular"],
          ["mathtt", "texttt", "Typewriter-Regular"]
        ];
        const wideNumeralData = [
          ["mathbf", "textbf", "Main-Bold"],
          ["", "", ""],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathtt", "texttt", "Typewriter-Regular"]
        ];
        const wideCharacterFont = function(wideChar2, mode) {
          const H = wideChar2.charCodeAt(0);
          const L = wideChar2.charCodeAt(1);
          const codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
          const j = mode === "math" ? 0 : 1;
          if (119808 <= codePoint && codePoint < 120484) {
            const i = Math.floor((codePoint - 119808) / 26);
            return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
          } else if (120782 <= codePoint && codePoint <= 120831) {
            const i = Math.floor((codePoint - 120782) / 10);
            return [wideNumeralData[i][2], wideNumeralData[i][j]];
          } else if (codePoint === 120485 || codePoint === 120486) {
            return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
          } else if (120486 < codePoint && codePoint < 120782) {
            return ["", ""];
          } else {
            throw new src_ParseError("Unsupported character: " + wideChar2);
          }
        };
        ;
        class DocumentFragment {
          constructor(children) {
            this.children = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.children = children;
            this.classes = [];
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = {};
          }
          hasClass(className) {
            return this.classes.includes(className);
          }
          toNode() {
            const frag = document.createDocumentFragment();
            for (let i = 0; i < this.children.length; i++) {
              frag.appendChild(this.children[i].toNode());
            }
            return frag;
          }
          toMarkup() {
            let markup = "";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            return markup;
          }
          toText() {
            const toText = (child) => child.toText();
            return this.children.map(toText).join("");
          }
        }
        ;
        const lookupSymbol = function(value, fontName, mode) {
          if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
            value = src_symbols[mode][value].replace;
          }
          return {
            value,
            metrics: getCharacterMetrics(value, fontName, mode)
          };
        };
        const makeSymbol = function(value, fontName, mode, options, classes) {
          const lookup = lookupSymbol(value, fontName, mode);
          const metrics = lookup.metrics;
          value = lookup.value;
          let symbolNode;
          if (metrics) {
            let italic = metrics.italic;
            if (mode === "text" || options && options.font === "mathit") {
              italic = 0;
            }
            symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
          } else {
            typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
            symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
          }
          if (options) {
            symbolNode.maxFontSize = options.sizeMultiplier;
            if (options.style.isTight()) {
              symbolNode.classes.push("mtight");
            }
            const color = options.getColor();
            if (color) {
              symbolNode.style.color = color;
            }
          }
          return symbolNode;
        };
        const mathsym = function(value, mode, options, classes) {
          if (classes === void 0) {
            classes = [];
          }
          if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
            return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
          } else if (value === "\\" || src_symbols[mode][value].font === "main") {
            return makeSymbol(value, "Main-Regular", mode, options, classes);
          } else {
            return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
          }
        };
        const boldsymbol = function(value, mode, options, classes, type) {
          if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
            return {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            };
          } else {
            return {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }
        };
        const makeOrd = function(group, options, type) {
          const mode = group.mode;
          const text = group.text;
          const classes = ["mord"];
          const isFont = mode === "math" || mode === "text" && options.font;
          const fontOrFamily = isFont ? options.font : options.fontFamily;
          let wideFontName = "";
          let wideFontClass = "";
          if (text.charCodeAt(0) === 55349) {
            [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
          }
          if (wideFontName.length > 0) {
            return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
          } else if (fontOrFamily) {
            let fontName;
            let fontClasses;
            if (fontOrFamily === "boldsymbol") {
              const fontData = boldsymbol(text, mode, options, classes, type);
              fontName = fontData.fontName;
              fontClasses = [fontData.fontClass];
            } else if (isFont) {
              fontName = fontMap[fontOrFamily].fontName;
              fontClasses = [fontOrFamily];
            } else {
              fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
              fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
            }
            if (lookupSymbol(text, fontName, mode).metrics) {
              return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
            } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
              const parts = [];
              for (let i = 0; i < text.length; i++) {
                parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
              }
              return makeFragment(parts);
            }
          }
          if (type === "mathord") {
            return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
          } else if (type === "textord") {
            const font = src_symbols[mode][text] && src_symbols[mode][text].font;
            if (font === "ams") {
              const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
              return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
            } else if (font === "main" || !font) {
              const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
              return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
            } else {
              const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape);
              return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
            }
          } else {
            throw new Error("unexpected type: " + type + " in makeOrd");
          }
        };
        const canCombine = (prev, next) => {
          if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
            return false;
          }
          if (prev.classes.length === 1) {
            const cls = prev.classes[0];
            if (cls === "mbin" || cls === "mord") {
              return false;
            }
          }
          for (const style in prev.style) {
            if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
              return false;
            }
          }
          for (const style in next.style) {
            if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
              return false;
            }
          }
          return true;
        };
        const tryCombineChars = (chars) => {
          for (let i = 0; i < chars.length - 1; i++) {
            const prev = chars[i];
            const next = chars[i + 1];
            if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
              prev.text += next.text;
              prev.height = Math.max(prev.height, next.height);
              prev.depth = Math.max(prev.depth, next.depth);
              prev.italic = next.italic;
              chars.splice(i + 1, 1);
              i--;
            }
          }
          return chars;
        };
        const sizeElementFromChildren = function(elem) {
          let height = 0;
          let depth = 0;
          let maxFontSize = 0;
          for (let i = 0; i < elem.children.length; i++) {
            const child = elem.children[i];
            if (child.height > height) {
              height = child.height;
            }
            if (child.depth > depth) {
              depth = child.depth;
            }
            if (child.maxFontSize > maxFontSize) {
              maxFontSize = child.maxFontSize;
            }
          }
          elem.height = height;
          elem.depth = depth;
          elem.maxFontSize = maxFontSize;
        };
        const makeSpan = function(classes, children, options, style) {
          const span = new Span(classes, children, options, style);
          sizeElementFromChildren(span);
          return span;
        };
        const makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
        const makeLineSpan = function(className, options, thickness) {
          const line = makeSpan([className], [], options);
          line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
          line.style.borderBottomWidth = makeEm(line.height);
          line.maxFontSize = 1;
          return line;
        };
        const makeAnchor = function(href, classes, children, options) {
          const anchor = new Anchor(href, classes, children, options);
          sizeElementFromChildren(anchor);
          return anchor;
        };
        const makeFragment = function(children) {
          const fragment = new DocumentFragment(children);
          sizeElementFromChildren(fragment);
          return fragment;
        };
        const wrapFragment = function(group, options) {
          if (group instanceof DocumentFragment) {
            return makeSpan([], [group], options);
          }
          return group;
        };
        const getVListChildrenAndDepth = function(params) {
          if (params.positionType === "individualShift") {
            const oldChildren = params.children;
            const children = [oldChildren[0]];
            const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
            let currPos = depth2;
            for (let i = 1; i < oldChildren.length; i++) {
              const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
              const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
              currPos = currPos + diff;
              children.push({
                type: "kern",
                size
              });
              children.push(oldChildren[i]);
            }
            return {
              children,
              depth: depth2
            };
          }
          let depth;
          if (params.positionType === "top") {
            let bottom = params.positionData;
            for (let i = 0; i < params.children.length; i++) {
              const child = params.children[i];
              bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
            }
            depth = bottom;
          } else if (params.positionType === "bottom") {
            depth = -params.positionData;
          } else {
            const firstChild = params.children[0];
            if (firstChild.type !== "elem") {
              throw new Error('First child must have type "elem".');
            }
            if (params.positionType === "shift") {
              depth = -firstChild.elem.depth - params.positionData;
            } else if (params.positionType === "firstBaseline") {
              depth = -firstChild.elem.depth;
            } else {
              throw new Error("Invalid positionType " + params.positionType + ".");
            }
          }
          return {
            children: params.children,
            depth
          };
        };
        const makeVList = function(params, options) {
          const {
            children,
            depth
          } = getVListChildrenAndDepth(params);
          let pstrutSize = 0;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.type === "elem") {
              const elem = child.elem;
              pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
            }
          }
          pstrutSize += 2;
          const pstrut = makeSpan(["pstrut"], []);
          pstrut.style.height = makeEm(pstrutSize);
          const realChildren = [];
          let minPos = depth;
          let maxPos = depth;
          let currPos = depth;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.type === "kern") {
              currPos += child.size;
            } else {
              const elem = child.elem;
              const classes = child.wrapperClasses || [];
              const style = child.wrapperStyle || {};
              const childWrap = makeSpan(classes, [pstrut, elem], void 0, style);
              childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);
              if (child.marginLeft) {
                childWrap.style.marginLeft = child.marginLeft;
              }
              if (child.marginRight) {
                childWrap.style.marginRight = child.marginRight;
              }
              realChildren.push(childWrap);
              currPos += elem.height + elem.depth;
            }
            minPos = Math.min(minPos, currPos);
            maxPos = Math.max(maxPos, currPos);
          }
          const vlist = makeSpan(["vlist"], realChildren);
          vlist.style.height = makeEm(maxPos);
          let rows;
          if (minPos < 0) {
            const emptySpan = makeSpan([], []);
            const depthStrut = makeSpan(["vlist"], [emptySpan]);
            depthStrut.style.height = makeEm(-minPos);
            const topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200B")]);
            rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
          } else {
            rows = [makeSpan(["vlist-r"], [vlist])];
          }
          const vtable = makeSpan(["vlist-t"], rows);
          if (rows.length === 2) {
            vtable.classes.push("vlist-t2");
          }
          vtable.height = maxPos;
          vtable.depth = -minPos;
          return vtable;
        };
        const makeGlue = (measurement, options) => {
          const rule = makeSpan(["mspace"], [], options);
          const size = calculateSize(measurement, options);
          rule.style.marginRight = makeEm(size);
          return rule;
        };
        const retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
          let baseFontName = "";
          switch (fontFamily) {
            case "amsrm":
              baseFontName = "AMS";
              break;
            case "textrm":
              baseFontName = "Main";
              break;
            case "textsf":
              baseFontName = "SansSerif";
              break;
            case "texttt":
              baseFontName = "Typewriter";
              break;
            default:
              baseFontName = fontFamily;
          }
          let fontStylesName;
          if (fontWeight === "textbf" && fontShape === "textit") {
            fontStylesName = "BoldItalic";
          } else if (fontWeight === "textbf") {
            fontStylesName = "Bold";
          } else if (fontWeight === "textit") {
            fontStylesName = "Italic";
          } else {
            fontStylesName = "Regular";
          }
          return baseFontName + "-" + fontStylesName;
        };
        const fontMap = {
          "mathbf": {
            variant: "bold",
            fontName: "Main-Bold"
          },
          "mathrm": {
            variant: "normal",
            fontName: "Main-Regular"
          },
          "textit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathnormal": {
            variant: "italic",
            fontName: "Math-Italic"
          },
          "mathsfit": {
            variant: "sans-serif-italic",
            fontName: "SansSerif-Italic"
          },
          "mathbb": {
            variant: "double-struck",
            fontName: "AMS-Regular"
          },
          "mathcal": {
            variant: "script",
            fontName: "Caligraphic-Regular"
          },
          "mathfrak": {
            variant: "fraktur",
            fontName: "Fraktur-Regular"
          },
          "mathscr": {
            variant: "script",
            fontName: "Script-Regular"
          },
          "mathsf": {
            variant: "sans-serif",
            fontName: "SansSerif-Regular"
          },
          "mathtt": {
            variant: "monospace",
            fontName: "Typewriter-Regular"
          }
        };
        const svgData = {
          vec: ["vec", 0.471, 0.714],
          oiintSize1: ["oiintSize1", 0.957, 0.499],
          oiintSize2: ["oiintSize2", 1.472, 0.659],
          oiiintSize1: ["oiiintSize1", 1.304, 0.499],
          oiiintSize2: ["oiiintSize2", 1.98, 0.659]
        };
        const staticSvg = function(value, options) {
          const [pathName, width, height] = svgData[value];
          const path2 = new PathNode(pathName);
          const svgNode = new SvgNode([path2], {
            "width": makeEm(width),
            "height": makeEm(height),
            "style": "width:" + makeEm(width),
            "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
            "preserveAspectRatio": "xMinYMin"
          });
          const span = makeSvgSpan(["overlay"], [svgNode], options);
          span.height = height;
          span.style.height = makeEm(height);
          span.style.width = makeEm(width);
          return span;
        };
        var buildCommon = {
          fontMap,
          makeSymbol,
          mathsym,
          makeSpan,
          makeSvgSpan,
          makeLineSpan,
          makeAnchor,
          makeFragment,
          wrapFragment,
          makeVList,
          makeOrd,
          makeGlue,
          staticSvg,
          svgData,
          tryCombineChars
        };
        ;
        const thinspace = {
          number: 3,
          unit: "mu"
        };
        const mediumspace = {
          number: 4,
          unit: "mu"
        };
        const thickspace = {
          number: 5,
          unit: "mu"
        };
        const spacings = {
          mord: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            minner: thinspace
          },
          mbin: {
            mord: mediumspace,
            mop: mediumspace,
            mopen: mediumspace,
            minner: mediumspace
          },
          mrel: {
            mord: thickspace,
            mop: thickspace,
            mopen: thickspace,
            minner: thickspace
          },
          mopen: {},
          mclose: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mpunct: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            mopen: thinspace,
            mclose: thinspace,
            mpunct: thinspace,
            minner: thinspace
          },
          minner: {
            mord: thinspace,
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            mopen: thinspace,
            mpunct: thinspace,
            minner: thinspace
          }
        };
        const tightSpacings = {
          mord: {
            mop: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace
          },
          mbin: {},
          mrel: {},
          mopen: {},
          mclose: {
            mop: thinspace
          },
          mpunct: {},
          minner: {
            mop: thinspace
          }
        };
        ;
        const _functions = {};
        const _htmlGroupBuilders = {};
        const _mathmlGroupBuilders = {};
        function defineFunction(_ref) {
          let {
            type,
            names,
            props,
            handler,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref;
          const data = {
            type,
            numArgs: props.numArgs,
            argTypes: props.argTypes,
            allowedInArgument: !!props.allowedInArgument,
            allowedInText: !!props.allowedInText,
            allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
            numOptionalArgs: props.numOptionalArgs || 0,
            infix: !!props.infix,
            primitive: !!props.primitive,
            handler
          };
          for (let i = 0; i < names.length; ++i) {
            _functions[names[i]] = data;
          }
          if (type) {
            if (htmlBuilder2) {
              _htmlGroupBuilders[type] = htmlBuilder2;
            }
            if (mathmlBuilder2) {
              _mathmlGroupBuilders[type] = mathmlBuilder2;
            }
          }
        }
        function defineFunctionBuilders(_ref2) {
          let {
            type,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref2;
          defineFunction({
            type,
            names: [],
            props: {
              numArgs: 0
            },
            handler() {
              throw new Error("Should never be called.");
            },
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          });
        }
        const normalizeArgument = function(arg) {
          return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
        };
        const ordargument = function(arg) {
          return arg.type === "ordgroup" ? arg.body : [arg];
        };
        ;
        const buildHTML_makeSpan = buildCommon.makeSpan;
        const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
        const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
        const styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        const DomEnum = {
          mord: "mord",
          mop: "mop",
          mbin: "mbin",
          mrel: "mrel",
          mopen: "mopen",
          mclose: "mclose",
          mpunct: "mpunct",
          minner: "minner"
        };
        const buildExpression = function(expression, options, isRealGroup, surrounding) {
          if (surrounding === void 0) {
            surrounding = [null, null];
          }
          const groups = [];
          for (let i = 0; i < expression.length; i++) {
            const output = buildGroup(expression[i], options);
            if (output instanceof DocumentFragment) {
              const children = output.children;
              groups.push(...children);
            } else {
              groups.push(output);
            }
          }
          buildCommon.tryCombineChars(groups);
          if (!isRealGroup) {
            return groups;
          }
          let glueOptions = options;
          if (expression.length === 1) {
            const node = expression[0];
            if (node.type === "sizing") {
              glueOptions = options.havingSize(node.size);
            } else if (node.type === "styling") {
              glueOptions = options.havingStyle(styleMap[node.style]);
            }
          }
          const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
          const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
          const isRoot = isRealGroup === "root";
          traverseNonSpaceNodes(groups, (node, prev) => {
            const prevType = prev.classes[0];
            const type = node.classes[0];
            if (prevType === "mbin" && binRightCanceller.includes(type)) {
              prev.classes[0] = "mord";
            } else if (type === "mbin" && binLeftCanceller.includes(prevType)) {
              node.classes[0] = "mord";
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          traverseNonSpaceNodes(groups, (node, prev) => {
            const prevType = getTypeOfDomTree(prev);
            const type = getTypeOfDomTree(node);
            const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
            if (space) {
              return buildCommon.makeGlue(space, glueOptions);
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          return groups;
        };
        const traverseNonSpaceNodes = function(nodes, callback, prev, next, isRoot) {
          if (next) {
            nodes.push(next);
          }
          let i = 0;
          for (; i < nodes.length; i++) {
            const node = nodes[i];
            const partialGroup = checkPartialGroup(node);
            if (partialGroup) {
              traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
              continue;
            }
            const nonspace = !node.hasClass("mspace");
            if (nonspace) {
              const result = callback(node, prev.node);
              if (result) {
                if (prev.insertAfter) {
                  prev.insertAfter(result);
                } else {
                  nodes.unshift(result);
                  i++;
                }
              }
            }
            if (nonspace) {
              prev.node = node;
            } else if (isRoot && node.hasClass("newline")) {
              prev.node = buildHTML_makeSpan(["leftmost"]);
            }
            prev.insertAfter = ((index) => (n) => {
              nodes.splice(index + 1, 0, n);
              i++;
            })(i);
          }
          if (next) {
            nodes.pop();
          }
        };
        const checkPartialGroup = function(node) {
          if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
            return node;
          }
          return null;
        };
        const getOutermostNode = function(node, side) {
          const partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            const children = partialGroup.children;
            if (children.length) {
              if (side === "right") {
                return getOutermostNode(children[children.length - 1], "right");
              } else if (side === "left") {
                return getOutermostNode(children[0], "left");
              }
            }
          }
          return node;
        };
        const getTypeOfDomTree = function(node, side) {
          if (!node) {
            return null;
          }
          if (side) {
            node = getOutermostNode(node, side);
          }
          return DomEnum[node.classes[0]] || null;
        };
        const makeNullDelimiter = function(options, classes) {
          const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
          return buildHTML_makeSpan(classes.concat(moreClasses));
        };
        const buildGroup = function(group, options, baseOptions) {
          if (!group) {
            return buildHTML_makeSpan();
          }
          if (_htmlGroupBuilders[group.type]) {
            let groupNode = _htmlGroupBuilders[group.type](group, options);
            if (baseOptions && options.size !== baseOptions.size) {
              groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
              const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              groupNode.height *= multiplier;
              groupNode.depth *= multiplier;
            }
            return groupNode;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildHTMLUnbreakable(children, options) {
          const body = buildHTML_makeSpan(["base"], children, options);
          const strut = buildHTML_makeSpan(["strut"]);
          strut.style.height = makeEm(body.height + body.depth);
          if (body.depth) {
            strut.style.verticalAlign = makeEm(-body.depth);
          }
          body.children.unshift(strut);
          return body;
        }
        function buildHTML(tree, options) {
          let tag = null;
          if (tree.length === 1 && tree[0].type === "tag") {
            tag = tree[0].tag;
            tree = tree[0].body;
          }
          const expression = buildExpression(tree, options, "root");
          let eqnNum;
          if (expression.length === 2 && expression[1].hasClass("tag")) {
            eqnNum = expression.pop();
          }
          const children = [];
          let parts = [];
          for (let i = 0; i < expression.length; i++) {
            parts.push(expression[i]);
            if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
              let nobreak = false;
              while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                i++;
                parts.push(expression[i]);
                if (expression[i].hasClass("nobreak")) {
                  nobreak = true;
                }
              }
              if (!nobreak) {
                children.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
            } else if (expression[i].hasClass("newline")) {
              parts.pop();
              if (parts.length > 0) {
                children.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
              children.push(expression[i]);
            }
          }
          if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
          }
          let tagChild;
          if (tag) {
            tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
            tagChild.classes = ["tag"];
            children.push(tagChild);
          } else if (eqnNum) {
            children.push(eqnNum);
          }
          const htmlNode = buildHTML_makeSpan(["katex-html"], children);
          htmlNode.setAttribute("aria-hidden", "true");
          if (tagChild) {
            const strut = tagChild.children[0];
            strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
            if (htmlNode.depth) {
              strut.style.verticalAlign = makeEm(-htmlNode.depth);
            }
          }
          return htmlNode;
        }
        ;
        function newDocumentFragment(children) {
          return new DocumentFragment(children);
        }
        class MathNode {
          constructor(type, children, classes) {
            this.type = void 0;
            this.attributes = void 0;
            this.children = void 0;
            this.classes = void 0;
            this.type = type;
            this.attributes = {};
            this.children = children || [];
            this.classes = classes || [];
          }
          setAttribute(name, value) {
            this.attributes[name] = value;
          }
          getAttribute(name) {
            return this.attributes[name];
          }
          toNode() {
            const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            if (this.classes.length > 0) {
              node.className = createClass(this.classes);
            }
            for (let i = 0; i < this.children.length; i++) {
              if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
                let text = this.children[i].toText() + this.children[++i].toText();
                while (this.children[i + 1] instanceof TextNode) {
                  text += this.children[++i].toText();
                }
                node.appendChild(new TextNode(text).toNode());
              } else {
                node.appendChild(this.children[i].toNode());
              }
            }
            return node;
          }
          toMarkup() {
            let markup = "<" + this.type;
            for (const attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + '="';
                markup += utils.escape(this.attributes[attr]);
                markup += '"';
              }
            }
            if (this.classes.length > 0) {
              markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
            }
            markup += ">";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</" + this.type + ">";
            return markup;
          }
          toText() {
            return this.children.map((child) => child.toText()).join("");
          }
        }
        class TextNode {
          constructor(text) {
            this.text = void 0;
            this.text = text;
          }
          toNode() {
            return document.createTextNode(this.text);
          }
          toMarkup() {
            return utils.escape(this.toText());
          }
          toText() {
            return this.text;
          }
        }
        class SpaceNode {
          constructor(width) {
            this.width = void 0;
            this.character = void 0;
            this.width = width;
            if (width >= 0.05555 && width <= 0.05556) {
              this.character = "\u200A";
            } else if (width >= 0.1666 && width <= 0.1667) {
              this.character = "\u2009";
            } else if (width >= 0.2222 && width <= 0.2223) {
              this.character = "\u2005";
            } else if (width >= 0.2777 && width <= 0.2778) {
              this.character = "\u2005\u200A";
            } else if (width >= -0.05556 && width <= -0.05555) {
              this.character = "\u200A\u2063";
            } else if (width >= -0.1667 && width <= -0.1666) {
              this.character = "\u2009\u2063";
            } else if (width >= -0.2223 && width <= -0.2222) {
              this.character = "\u205F\u2063";
            } else if (width >= -0.2778 && width <= -0.2777) {
              this.character = "\u2005\u2063";
            } else {
              this.character = null;
            }
          }
          toNode() {
            if (this.character) {
              return document.createTextNode(this.character);
            } else {
              const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
              node.setAttribute("width", makeEm(this.width));
              return node;
            }
          }
          toMarkup() {
            if (this.character) {
              return "<mtext>" + this.character + "</mtext>";
            } else {
              return '<mspace width="' + makeEm(this.width) + '"/>';
            }
          }
          toText() {
            if (this.character) {
              return this.character;
            } else {
              return " ";
            }
          }
        }
        var mathMLTree = {
          MathNode,
          TextNode,
          SpaceNode,
          newDocumentFragment
        };
        ;
        const makeText = function(text, mode, options) {
          if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
            text = src_symbols[mode][text].replace;
          }
          return new mathMLTree.TextNode(text);
        };
        const makeRow = function(body) {
          if (body.length === 1) {
            return body[0];
          } else {
            return new mathMLTree.MathNode("mrow", body);
          }
        };
        const getVariant = function(group, options) {
          if (options.fontFamily === "texttt") {
            return "monospace";
          } else if (options.fontFamily === "textsf") {
            if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "sans-serif-bold-italic";
            } else if (options.fontShape === "textit") {
              return "sans-serif-italic";
            } else if (options.fontWeight === "textbf") {
              return "bold-sans-serif";
            } else {
              return "sans-serif";
            }
          } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "bold-italic";
          } else if (options.fontShape === "textit") {
            return "italic";
          } else if (options.fontWeight === "textbf") {
            return "bold";
          }
          const font = options.font;
          if (!font || font === "mathnormal") {
            return null;
          }
          const mode = group.mode;
          if (font === "mathit") {
            return "italic";
          } else if (font === "boldsymbol") {
            return group.type === "textord" ? "bold" : "bold-italic";
          } else if (font === "mathbf") {
            return "bold";
          } else if (font === "mathbb") {
            return "double-struck";
          } else if (font === "mathsfit") {
            return "sans-serif-italic";
          } else if (font === "mathfrak") {
            return "fraktur";
          } else if (font === "mathscr" || font === "mathcal") {
            return "script";
          } else if (font === "mathsf") {
            return "sans-serif";
          } else if (font === "mathtt") {
            return "monospace";
          }
          let text = group.text;
          if (["\\imath", "\\jmath"].includes(text)) {
            return null;
          }
          if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
            text = src_symbols[mode][text].replace;
          }
          const fontName = buildCommon.fontMap[font].fontName;
          if (getCharacterMetrics(text, fontName, mode)) {
            return buildCommon.fontMap[font].variant;
          }
          return null;
        };
        function isNumberPunctuation(group) {
          if (!group) {
            return false;
          }
          if (group.type === "mi" && group.children.length === 1) {
            const child = group.children[0];
            return child instanceof TextNode && child.text === ".";
          } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
            const child = group.children[0];
            return child instanceof TextNode && child.text === ",";
          } else {
            return false;
          }
        }
        const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
          if (expression.length === 1) {
            const group = buildMathML_buildGroup(expression[0], options);
            if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
              group.setAttribute("lspace", "0em");
              group.setAttribute("rspace", "0em");
            }
            return [group];
          }
          const groups = [];
          let lastGroup;
          for (let i = 0; i < expression.length; i++) {
            const group = buildMathML_buildGroup(expression[i], options);
            if (group instanceof MathNode && lastGroup instanceof MathNode) {
              if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                lastGroup.children.push(...group.children);
                continue;
              } else if (group.type === "mn" && lastGroup.type === "mn") {
                lastGroup.children.push(...group.children);
                continue;
              } else if (isNumberPunctuation(group) && lastGroup.type === "mn") {
                lastGroup.children.push(...group.children);
                continue;
              } else if (group.type === "mn" && isNumberPunctuation(lastGroup)) {
                group.children = [...lastGroup.children, ...group.children];
                groups.pop();
              } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
                const base = group.children[0];
                if (base instanceof MathNode && base.type === "mn") {
                  base.children = [...lastGroup.children, ...base.children];
                  groups.pop();
                }
              } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                const lastChild = lastGroup.children[0];
                if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                  const child = group.children[0];
                  if (child instanceof TextNode && child.text.length > 0) {
                    child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                    groups.pop();
                  }
                }
              }
            }
            groups.push(group);
            lastGroup = group;
          }
          return groups;
        };
        const buildExpressionRow = function(expression, options, isOrdgroup) {
          return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
        };
        const buildMathML_buildGroup = function(group, options) {
          if (!group) {
            return new mathMLTree.MathNode("mrow");
          }
          if (_mathmlGroupBuilders[group.type]) {
            const result = _mathmlGroupBuilders[group.type](group, options);
            return result;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
          const expression = buildMathML_buildExpression(tree, options);
          let wrapper;
          if (expression.length === 1 && expression[0] instanceof MathNode && ["mrow", "mtable"].includes(expression[0].type)) {
            wrapper = expression[0];
          } else {
            wrapper = new mathMLTree.MathNode("mrow", expression);
          }
          const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
          annotation.setAttribute("encoding", "application/x-tex");
          const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
          const math2 = new mathMLTree.MathNode("math", [semantics]);
          math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
          if (isDisplayMode) {
            math2.setAttribute("display", "block");
          }
          const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
          return buildCommon.makeSpan([wrapperClass], [math2]);
        }
        ;
        const optionsFromSettings = function(settings) {
          return new src_Options({
            style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
            maxSize: settings.maxSize,
            minRuleThickness: settings.minRuleThickness
          });
        };
        const displayWrap = function(node, settings) {
          if (settings.displayMode) {
            const classes = ["katex-display"];
            if (settings.leqno) {
              classes.push("leqno");
            }
            if (settings.fleqn) {
              classes.push("fleqn");
            }
            node = buildCommon.makeSpan(classes, [node]);
          }
          return node;
        };
        const buildTree = function(tree, expression, settings) {
          const options = optionsFromSettings(settings);
          let katexNode;
          if (settings.output === "mathml") {
            return buildMathML(tree, expression, options, settings.displayMode, true);
          } else if (settings.output === "html") {
            const htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          } else {
            const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
            const htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
          }
          return displayWrap(katexNode, settings);
        };
        const buildHTMLTree = function(tree, expression, settings) {
          const options = optionsFromSettings(settings);
          const htmlNode = buildHTML(tree, options);
          const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          return displayWrap(katexNode, settings);
        };
        var src_buildTree = null;
        ;
        const stretchyCodePoint = {
          widehat: "^",
          widecheck: "\u02C7",
          widetilde: "~",
          utilde: "~",
          overleftarrow: "\u2190",
          underleftarrow: "\u2190",
          xleftarrow: "\u2190",
          overrightarrow: "\u2192",
          underrightarrow: "\u2192",
          xrightarrow: "\u2192",
          underbrace: "\u23DF",
          overbrace: "\u23DE",
          overgroup: "\u23E0",
          undergroup: "\u23E1",
          overleftrightarrow: "\u2194",
          underleftrightarrow: "\u2194",
          xleftrightarrow: "\u2194",
          Overrightarrow: "\u21D2",
          xRightarrow: "\u21D2",
          overleftharpoon: "\u21BC",
          xleftharpoonup: "\u21BC",
          overrightharpoon: "\u21C0",
          xrightharpoonup: "\u21C0",
          xLeftarrow: "\u21D0",
          xLeftrightarrow: "\u21D4",
          xhookleftarrow: "\u21A9",
          xhookrightarrow: "\u21AA",
          xmapsto: "\u21A6",
          xrightharpoondown: "\u21C1",
          xleftharpoondown: "\u21BD",
          xrightleftharpoons: "\u21CC",
          xleftrightharpoons: "\u21CB",
          xtwoheadleftarrow: "\u219E",
          xtwoheadrightarrow: "\u21A0",
          xlongequal: "=",
          xtofrom: "\u21C4",
          xrightleftarrows: "\u21C4",
          xrightequilibrium: "\u21CC",
          xleftequilibrium: "\u21CB",
          "\\cdrightarrow": "\u2192",
          "\\cdleftarrow": "\u2190",
          "\\cdlongequal": "="
        };
        const mathMLnode = function(label) {
          const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
          node.setAttribute("stretchy", "true");
          return node;
        };
        const katexImagesData = {
          overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
          "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
          xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
          "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
          Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
          xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
          xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
          overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
          overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
          xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
          "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
          xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
          xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
          overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
          underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
          underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
          xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
          xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
          xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
          xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
          xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
          overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
          undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
          xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
          xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
          xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
          xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
          xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
        };
        const groupLength = function(arg) {
          if (arg.type === "ordgroup") {
            return arg.body.length;
          } else {
            return 1;
          }
        };
        const svgSpan = function(group, options) {
          function buildSvgSpan_() {
            let viewBoxWidth = 4e5;
            const label = group.label.slice(1);
            if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
              const grp = group;
              const numChars = groupLength(grp.base);
              let viewBoxHeight;
              let pathName;
              let height2;
              if (numChars > 5) {
                if (label === "widehat" || label === "widecheck") {
                  viewBoxHeight = 420;
                  viewBoxWidth = 2364;
                  height2 = 0.42;
                  pathName = label + "4";
                } else {
                  viewBoxHeight = 312;
                  viewBoxWidth = 2340;
                  height2 = 0.34;
                  pathName = "tilde4";
                }
              } else {
                const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                if (label === "widehat" || label === "widecheck") {
                  viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                  viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                  height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                  pathName = label + imgIndex;
                } else {
                  viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                  viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                  height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                  pathName = "tilde" + imgIndex;
                }
              }
              const path2 = new PathNode(pathName);
              const svgNode = new SvgNode([path2], {
                "width": "100%",
                "height": makeEm(height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                "preserveAspectRatio": "none"
              });
              return {
                span: buildCommon.makeSvgSpan([], [svgNode], options),
                minWidth: 0,
                height: height2
              };
            } else {
              const spans = [];
              const data = katexImagesData[label];
              const [paths, minWidth2, viewBoxHeight] = data;
              const height2 = viewBoxHeight / 1e3;
              const numSvgChildren = paths.length;
              let widthClasses;
              let aligns;
              if (numSvgChildren === 1) {
                const align1 = data[3];
                widthClasses = ["hide-tail"];
                aligns = [align1];
              } else if (numSvgChildren === 2) {
                widthClasses = ["halfarrow-left", "halfarrow-right"];
                aligns = ["xMinYMin", "xMaxYMin"];
              } else if (numSvgChildren === 3) {
                widthClasses = ["brace-left", "brace-center", "brace-right"];
                aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
              } else {
                throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
              }
              for (let i = 0; i < numSvgChildren; i++) {
                const path2 = new PathNode(paths[i]);
                const svgNode = new SvgNode([path2], {
                  "width": "400em",
                  "height": makeEm(height2),
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                  "preserveAspectRatio": aligns[i] + " slice"
                });
                const span2 = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);
                if (numSvgChildren === 1) {
                  return {
                    span: span2,
                    minWidth: minWidth2,
                    height: height2
                  };
                } else {
                  span2.style.height = makeEm(height2);
                  spans.push(span2);
                }
              }
              return {
                span: buildCommon.makeSpan(["stretchy"], spans, options),
                minWidth: minWidth2,
                height: height2
              };
            }
          }
          const {
            span,
            minWidth,
            height
          } = buildSvgSpan_();
          span.height = height;
          span.style.height = makeEm(height);
          if (minWidth > 0) {
            span.style.minWidth = makeEm(minWidth);
          }
          return span;
        };
        const encloseSpan = function(inner2, label, topPad, bottomPad, options) {
          let img;
          const totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
          if (/fbox|color|angl/.test(label)) {
            img = buildCommon.makeSpan(["stretchy", label], [], options);
            if (label === "fbox") {
              const color = options.color && options.getColor();
              if (color) {
                img.style.borderColor = color;
              }
            }
          } else {
            const lines = [];
            if (/^[bx]cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "0",
                "x2": "100%",
                "y2": "100%",
                "stroke-width": "0.046em"
              }));
            }
            if (/^x?cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "100%",
                "x2": "100%",
                "y2": "0",
                "stroke-width": "0.046em"
              }));
            }
            const svgNode = new SvgNode(lines, {
              "width": "100%",
              "height": makeEm(totalHeight)
            });
            img = buildCommon.makeSvgSpan([], [svgNode], options);
          }
          img.height = totalHeight;
          img.style.height = makeEm(totalHeight);
          return img;
        };
        var stretchy = {
          encloseSpan,
          mathMLnode,
          svgSpan
        };
        ;
        function assertNodeType(node, type) {
          if (!node || node.type !== type) {
            throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
          }
          return node;
        }
        function assertSymbolNodeType(node) {
          const typedNode = checkSymbolNodeType(node);
          if (!typedNode) {
            throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
          }
          return typedNode;
        }
        function checkSymbolNodeType(node) {
          if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
            return node;
          }
          return null;
        }
        ;
        const htmlBuilder = (grp, options) => {
          let base;
          let group;
          let supSubGroup;
          if (grp && grp.type === "supsub") {
            group = assertNodeType(grp.base, "accent");
            base = group.base;
            grp.base = base;
            supSubGroup = assertSpan(buildGroup(grp, options));
            grp.base = group;
          } else {
            group = assertNodeType(grp, "accent");
            base = group.base;
          }
          const body = buildGroup(base, options.havingCrampedStyle());
          const mustShift = group.isShifty && utils.isCharacterBox(base);
          let skew = 0;
          if (mustShift) {
            const baseChar = utils.getBaseElem(base);
            const baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
            skew = assertSymbolDomNode(baseGroup).skew;
          }
          const accentBelow = group.label === "\\c";
          let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
          let accentBody;
          if (!group.isStretchy) {
            let accent2;
            let width;
            if (group.label === "\\vec") {
              accent2 = buildCommon.staticSvg("vec", options);
              width = buildCommon.svgData.vec[1];
            } else {
              accent2 = buildCommon.makeOrd({
                mode: group.mode,
                text: group.label
              }, options, "textord");
              accent2 = assertSymbolDomNode(accent2);
              accent2.italic = 0;
              width = accent2.width;
              if (accentBelow) {
                clearance += accent2.depth;
              }
            }
            accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
            const accentFull = group.label === "\\textcircled";
            if (accentFull) {
              accentBody.classes.push("accent-full");
              clearance = body.height;
            }
            let left = skew;
            if (!accentFull) {
              left -= width / 2;
            }
            accentBody.style.left = makeEm(left);
            if (group.label === "\\textcircled") {
              accentBody.style.top = ".2em";
            }
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: -clearance
              }, {
                type: "elem",
                elem: accentBody
              }]
            }, options);
          } else {
            accentBody = stretchy.svgSpan(group, options);
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"],
                wrapperStyle: skew > 0 ? {
                  width: "calc(100% - " + makeEm(2 * skew) + ")",
                  marginLeft: makeEm(2 * skew)
                } : void 0
              }]
            }, options);
          }
          const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
          if (supSubGroup) {
            supSubGroup.children[0] = accentWrap;
            supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
            supSubGroup.classes[0] = "mord";
            return supSubGroup;
          } else {
            return accentWrap;
          }
        };
        const mathmlBuilder = (group, options) => {
          const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
          const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
          node.setAttribute("accent", "true");
          return node;
        };
        const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
        defineFunction({
          type: "accent",
          names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
          props: {
            numArgs: 1
          },
          handler: (context, args) => {
            const base = normalizeArgument(args[0]);
            const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
            const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
            return {
              type: "accent",
              mode: context.parser.mode,
              label: context.funcName,
              isStretchy,
              isShifty,
              base
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        defineFunction({
          type: "accent",
          names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
          props: {
            numArgs: 1,
            allowedInText: true,
            allowedInMath: true,
            argTypes: ["primitive"]
          },
          handler: (context, args) => {
            const base = args[0];
            let mode = context.parser.mode;
            if (mode === "math") {
              context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
              mode = "text";
            }
            return {
              type: "accent",
              mode,
              label: context.funcName,
              isStretchy: false,
              isShifty: true,
              base
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        ;
        defineFunction({
          type: "accentUnder",
          names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
          props: {
            numArgs: 1
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const base = args[0];
            return {
              type: "accentUnder",
              mode: parser.mode,
              label: funcName,
              base
            };
          },
          htmlBuilder: (group, options) => {
            const innerGroup = buildGroup(group.base, options);
            const accentBody = stretchy.svgSpan(group, options);
            const kern = group.label === "\\utilde" ? 0.12 : 0;
            const vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: kern
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
          },
          mathmlBuilder: (group, options) => {
            const accentNode = stretchy.mathMLnode(group.label);
            const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            node.setAttribute("accentunder", "true");
            return node;
          }
        });
        ;
        const paddedNode = (group) => {
          const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
          node.setAttribute("width", "+0.6em");
          node.setAttribute("lspace", "0.3em");
          return node;
        };
        defineFunction({
          type: "xArrow",
          names: [
            "\\xleftarrow",
            "\\xrightarrow",
            "\\xLeftarrow",
            "\\xRightarrow",
            "\\xleftrightarrow",
            "\\xLeftrightarrow",
            "\\xhookleftarrow",
            "\\xhookrightarrow",
            "\\xmapsto",
            "\\xrightharpoondown",
            "\\xrightharpoonup",
            "\\xleftharpoondown",
            "\\xleftharpoonup",
            "\\xrightleftharpoons",
            "\\xleftrightharpoons",
            "\\xlongequal",
            "\\xtwoheadrightarrow",
            "\\xtwoheadleftarrow",
            "\\xtofrom",
            "\\xrightleftarrows",
            "\\xrightequilibrium",
            "\\xleftequilibrium",
            "\\\\cdrightarrow",
            "\\\\cdleftarrow",
            "\\\\cdlongequal"
          ],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler(_ref, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "xArrow",
              mode: parser.mode,
              label: funcName,
              body: args[0],
              below: optArgs[0]
            };
          },
          htmlBuilder(group, options) {
            const style = options.style;
            let newOptions = options.havingStyle(style.sup());
            const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
            const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
            upperGroup.classes.push(arrowPrefix + "-arrow-pad");
            let lowerGroup;
            if (group.below) {
              newOptions = options.havingStyle(style.sub());
              lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
              lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
            }
            const arrowBody = stretchy.svgSpan(group, options);
            const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
            let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
            if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
              upperShift -= upperGroup.depth;
            }
            let vlist;
            if (lowerGroup) {
              const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }, {
                  type: "elem",
                  elem: lowerGroup,
                  shift: lowerShift
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }]
              }, options);
            }
            vlist.children[0].children[0].children[1].classes.push("svg-align");
            return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const arrowNode = stretchy.mathMLnode(group.label);
            arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
            let node;
            if (group.body) {
              const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
              if (group.below) {
                const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
              } else {
                node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
              }
            } else if (group.below) {
              const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
            } else {
              node = paddedNode();
              node = new mathMLTree.MathNode("mover", [arrowNode, node]);
            }
            return node;
          }
        });
        ;
        const mclass_makeSpan = buildCommon.makeSpan;
        function mclass_htmlBuilder(group, options) {
          const elements = buildExpression(group.body, options, true);
          return mclass_makeSpan([group.mclass], elements, options);
        }
        function mclass_mathmlBuilder(group, options) {
          let node;
          const inner2 = buildMathML_buildExpression(group.body, options);
          if (group.mclass === "minner") {
            node = new mathMLTree.MathNode("mpadded", inner2);
          } else if (group.mclass === "mord") {
            if (group.isCharacterBox) {
              node = inner2[0];
              node.type = "mi";
            } else {
              node = new mathMLTree.MathNode("mi", inner2);
            }
          } else {
            if (group.isCharacterBox) {
              node = inner2[0];
              node.type = "mo";
            } else {
              node = new mathMLTree.MathNode("mo", inner2);
            }
            if (group.mclass === "mbin") {
              node.attributes.lspace = "0.22em";
              node.attributes.rspace = "0.22em";
            } else if (group.mclass === "mpunct") {
              node.attributes.lspace = "0em";
              node.attributes.rspace = "0.17em";
            } else if (group.mclass === "mopen" || group.mclass === "mclose") {
              node.attributes.lspace = "0em";
              node.attributes.rspace = "0em";
            } else if (group.mclass === "minner") {
              node.attributes.lspace = "0.0556em";
              node.attributes.width = "+0.1111em";
            }
          }
          return node;
        }
        defineFunction({
          type: "mclass",
          names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: "m" + funcName.slice(5),
              body: ordargument(body),
              isCharacterBox: utils.isCharacterBox(body)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        const binrelClass = (arg) => {
          const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
          if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
            return "m" + atom.family;
          } else {
            return "mord";
          }
        };
        defineFunction({
          type: "mclass",
          names: ["\\@binrel"],
          props: {
            numArgs: 2
          },
          handler(_ref2, args) {
            let {
              parser
            } = _ref2;
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: binrelClass(args[0]),
              body: ordargument(args[1]),
              isCharacterBox: utils.isCharacterBox(args[1])
            };
          }
        });
        defineFunction({
          type: "mclass",
          names: ["\\stackrel", "\\overset", "\\underset"],
          props: {
            numArgs: 2
          },
          handler(_ref3, args) {
            let {
              parser,
              funcName
            } = _ref3;
            const baseArg = args[1];
            const shiftedArg = args[0];
            let mclass;
            if (funcName !== "\\stackrel") {
              mclass = binrelClass(baseArg);
            } else {
              mclass = "mrel";
            }
            const baseOp = {
              type: "op",
              mode: baseArg.mode,
              limits: true,
              alwaysHandleSupSub: true,
              parentIsSupSub: false,
              symbol: false,
              suppressBaseShift: funcName !== "\\stackrel",
              body: ordargument(baseArg)
            };
            const supsub = {
              type: "supsub",
              mode: shiftedArg.mode,
              base: baseOp,
              sup: funcName === "\\underset" ? null : shiftedArg,
              sub: funcName === "\\underset" ? shiftedArg : null
            };
            return {
              type: "mclass",
              mode: parser.mode,
              mclass,
              body: [supsub],
              isCharacterBox: utils.isCharacterBox(supsub)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        ;
        defineFunction({
          type: "pmb",
          names: ["\\pmb"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "pmb",
              mode: parser.mode,
              mclass: binrelClass(args[0]),
              body: ordargument(args[0])
            };
          },
          htmlBuilder(group, options) {
            const elements = buildExpression(group.body, options, true);
            const node = buildCommon.makeSpan([group.mclass], elements, options);
            node.style.textShadow = "0.02em 0.01em 0.04px";
            return node;
          },
          mathmlBuilder(group, style) {
            const inner2 = buildMathML_buildExpression(group.body, style);
            const node = new mathMLTree.MathNode("mstyle", inner2);
            node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
            return node;
          }
        });
        ;
        const cdArrowFunctionName = {
          ">": "\\\\cdrightarrow",
          "<": "\\\\cdleftarrow",
          "=": "\\\\cdlongequal",
          "A": "\\uparrow",
          "V": "\\downarrow",
          "|": "\\Vert",
          ".": "no arrow"
        };
        const newCell = () => {
          return {
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          };
        };
        const isStartOfArrow = (node) => {
          return node.type === "textord" && node.text === "@";
        };
        const isLabelEnd = (node, endChar) => {
          return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
        };
        function cdArrow(arrowChar, labels, parser) {
          const funcName = cdArrowFunctionName[arrowChar];
          switch (funcName) {
            case "\\\\cdrightarrow":
            case "\\\\cdleftarrow":
              return parser.callFunction(funcName, [labels[0]], [labels[1]]);
            case "\\uparrow":
            case "\\downarrow": {
              const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
              const bareArrow = {
                type: "atom",
                text: funcName,
                mode: "math",
                family: "rel"
              };
              const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
              const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
              const arrowGroup = {
                type: "ordgroup",
                mode: "math",
                body: [leftLabel, sizedArrow, rightLabel]
              };
              return parser.callFunction("\\\\cdparent", [arrowGroup], []);
            }
            case "\\\\cdlongequal":
              return parser.callFunction("\\\\cdlongequal", [], []);
            case "\\Vert": {
              const arrow = {
                type: "textord",
                text: "\\Vert",
                mode: "math"
              };
              return parser.callFunction("\\Big", [arrow], []);
            }
            default:
              return {
                type: "textord",
                text: " ",
                mode: "math"
              };
          }
        }
        function parseCD(parser) {
          const parsedRows = [];
          parser.gullet.beginGroup();
          parser.gullet.macros.set("\\cr", "\\\\\\relax");
          parser.gullet.beginGroup();
          while (true) {
            parsedRows.push(parser.parseExpression(false, "\\\\"));
            parser.gullet.endGroup();
            parser.gullet.beginGroup();
            const next = parser.fetch().text;
            if (next === "&" || next === "\\\\") {
              parser.consume();
            } else if (next === "\\end") {
              if (parsedRows[parsedRows.length - 1].length === 0) {
                parsedRows.pop();
              }
              break;
            } else {
              throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
            }
          }
          let row = [];
          const body = [row];
          for (let i = 0; i < parsedRows.length; i++) {
            const rowNodes = parsedRows[i];
            let cell = newCell();
            for (let j = 0; j < rowNodes.length; j++) {
              if (!isStartOfArrow(rowNodes[j])) {
                cell.body.push(rowNodes[j]);
              } else {
                row.push(cell);
                j += 1;
                const arrowChar = assertSymbolNodeType(rowNodes[j]).text;
                const labels = new Array(2);
                labels[0] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                labels[1] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                if ("=|.".indexOf(arrowChar) > -1) {
                } else if ("<>AV".indexOf(arrowChar) > -1) {
                  for (let labelNum = 0; labelNum < 2; labelNum++) {
                    let inLabel = true;
                    for (let k = j + 1; k < rowNodes.length; k++) {
                      if (isLabelEnd(rowNodes[k], arrowChar)) {
                        inLabel = false;
                        j = k;
                        break;
                      }
                      if (isStartOfArrow(rowNodes[k])) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                      }
                      labels[labelNum].body.push(rowNodes[k]);
                    }
                    if (inLabel) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                    }
                  }
                } else {
                  throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
                }
                const arrow = cdArrow(arrowChar, labels, parser);
                const wrappedArrow = {
                  type: "styling",
                  body: [arrow],
                  mode: "math",
                  style: "display"
                };
                row.push(wrappedArrow);
                cell = newCell();
              }
            }
            if (i % 2 === 0) {
              row.push(cell);
            } else {
              row.shift();
            }
            row = [];
            body.push(row);
          }
          parser.gullet.endGroup();
          parser.gullet.endGroup();
          const cols = new Array(body[0].length).fill({
            type: "align",
            align: "c",
            pregap: 0.25,
            postgap: 0.25
          });
          return {
            type: "array",
            mode: "math",
            body,
            arraystretch: 1,
            addJot: true,
            rowGaps: [null],
            cols,
            colSeparationType: "CD",
            hLinesBeforeRow: new Array(body.length + 1).fill([])
          };
        }
        defineFunction({
          type: "cdlabel",
          names: ["\\\\cdleft", "\\\\cdright"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "cdlabel",
              mode: parser.mode,
              side: funcName.slice(4),
              label: args[0]
            };
          },
          htmlBuilder(group, options) {
            const newOptions = options.havingStyle(options.style.sup());
            const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
            label.classes.push("cd-label-" + group.side);
            label.style.bottom = makeEm(0.8 - label.depth);
            label.height = 0;
            label.depth = 0;
            return label;
          },
          mathmlBuilder(group, options) {
            let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
            label = new mathMLTree.MathNode("mpadded", [label]);
            label.setAttribute("width", "0");
            if (group.side === "left") {
              label.setAttribute("lspace", "-1width");
            }
            label.setAttribute("voffset", "0.7em");
            label = new mathMLTree.MathNode("mstyle", [label]);
            label.setAttribute("displaystyle", "false");
            label.setAttribute("scriptlevel", "1");
            return label;
          }
        });
        defineFunction({
          type: "cdlabelparent",
          names: ["\\\\cdparent"],
          props: {
            numArgs: 1
          },
          handler(_ref2, args) {
            let {
              parser
            } = _ref2;
            return {
              type: "cdlabelparent",
              mode: parser.mode,
              fragment: args[0]
            };
          },
          htmlBuilder(group, options) {
            const parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
            parent.classes.push("cd-vert-arrow");
            return parent;
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
          }
        });
        ;
        defineFunction({
          type: "textord",
          names: ["\\@char"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const arg = assertNodeType(args[0], "ordgroup");
            const group = arg.body;
            let number = "";
            for (let i = 0; i < group.length; i++) {
              const node = assertNodeType(group[i], "textord");
              number += node.text;
            }
            let code = parseInt(number);
            let text;
            if (isNaN(code)) {
              throw new src_ParseError("\\@char has non-numeric argument " + number);
            } else if (code < 0 || code >= 1114111) {
              throw new src_ParseError("\\@char with invalid code point " + number);
            } else if (code <= 65535) {
              text = String.fromCharCode(code);
            } else {
              code -= 65536;
              text = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
            }
            return {
              type: "textord",
              mode: parser.mode,
              text
            };
          }
        });
        ;
        const color_htmlBuilder = (group, options) => {
          const elements = buildExpression(group.body, options.withColor(group.color), false);
          return buildCommon.makeFragment(elements);
        };
        const color_mathmlBuilder = (group, options) => {
          const inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
          const node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("mathcolor", group.color);
          return node;
        };
        defineFunction({
          type: "color",
          names: ["\\textcolor"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "original"]
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const color = assertNodeType(args[0], "color-token").color;
            const body = args[1];
            return {
              type: "color",
              mode: parser.mode,
              color,
              body: ordargument(body)
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        defineFunction({
          type: "color",
          names: ["\\color"],
          props: {
            numArgs: 1,
            allowedInText: true,
            argTypes: ["color"]
          },
          handler(_ref2, args) {
            let {
              parser,
              breakOnTokenText
            } = _ref2;
            const color = assertNodeType(args[0], "color-token").color;
            parser.gullet.macros.set("\\current@color", color);
            const body = parser.parseExpression(true, breakOnTokenText);
            return {
              type: "color",
              mode: parser.mode,
              color,
              body
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        ;
        defineFunction({
          type: "cr",
          names: ["\\\\"],
          props: {
            numArgs: 0,
            numOptionalArgs: 0,
            allowedInText: true
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
            const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
            return {
              type: "cr",
              mode: parser.mode,
              newLine,
              size: size && assertNodeType(size, "size").value
            };
          },
          htmlBuilder(group, options) {
            const span = buildCommon.makeSpan(["mspace"], [], options);
            if (group.newLine) {
              span.classes.push("newline");
              if (group.size) {
                span.style.marginTop = makeEm(calculateSize(group.size, options));
              }
            }
            return span;
          },
          mathmlBuilder(group, options) {
            const node = new mathMLTree.MathNode("mspace");
            if (group.newLine) {
              node.setAttribute("linebreak", "newline");
              if (group.size) {
                node.setAttribute("height", makeEm(calculateSize(group.size, options)));
              }
            }
            return node;
          }
        });
        ;
        const globalMap = {
          "\\global": "\\global",
          "\\long": "\\\\globallong",
          "\\\\globallong": "\\\\globallong",
          "\\def": "\\gdef",
          "\\gdef": "\\gdef",
          "\\edef": "\\xdef",
          "\\xdef": "\\xdef",
          "\\let": "\\\\globallet",
          "\\futurelet": "\\\\globalfuture"
        };
        const checkControlSequence = (tok) => {
          const name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          return name;
        };
        const getRHS = (parser) => {
          let tok = parser.gullet.popToken();
          if (tok.text === "=") {
            tok = parser.gullet.popToken();
            if (tok.text === " ") {
              tok = parser.gullet.popToken();
            }
          }
          return tok;
        };
        const letCommand = (parser, name, tok, global2) => {
          let macro = parser.gullet.macros.get(tok.text);
          if (macro == null) {
            tok.noexpand = true;
            macro = {
              tokens: [tok],
              numArgs: 0,
              unexpandable: !parser.gullet.isExpandable(tok.text)
            };
          }
          parser.gullet.macros.set(name, macro, global2);
        };
        defineFunction({
          type: "internal",
          names: [
            "\\global",
            "\\long",
            "\\\\globallong"
          ],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler(_ref) {
            let {
              parser,
              funcName
            } = _ref;
            parser.consumeSpaces();
            const token = parser.fetch();
            if (globalMap[token.text]) {
              if (funcName === "\\global" || funcName === "\\\\globallong") {
                token.text = globalMap[token.text];
              }
              return assertNodeType(parser.parseFunction(), "internal");
            }
            throw new src_ParseError("Invalid token after macro prefix", token);
          }
        });
        defineFunction({
          type: "internal",
          names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref2) {
            let {
              parser,
              funcName
            } = _ref2;
            let tok = parser.gullet.popToken();
            const name = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            let numArgs = 0;
            let insert;
            const delimiters2 = [[]];
            while (parser.gullet.future().text !== "{") {
              tok = parser.gullet.popToken();
              if (tok.text === "#") {
                if (parser.gullet.future().text === "{") {
                  insert = parser.gullet.future();
                  delimiters2[numArgs].push("{");
                  break;
                }
                tok = parser.gullet.popToken();
                if (!/^[1-9]$/.test(tok.text)) {
                  throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                }
                if (parseInt(tok.text) !== numArgs + 1) {
                  throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                }
                numArgs++;
                delimiters2.push([]);
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Expected a macro definition");
              } else {
                delimiters2[numArgs].push(tok.text);
              }
            }
            let {
              tokens
            } = parser.gullet.consumeArg();
            if (insert) {
              tokens.unshift(insert);
            }
            if (funcName === "\\edef" || funcName === "\\xdef") {
              tokens = parser.gullet.expandTokens(tokens);
              tokens.reverse();
            }
            parser.gullet.macros.set(name, {
              tokens,
              numArgs,
              delimiters: delimiters2
            }, funcName === globalMap[funcName]);
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\let",
            "\\\\globallet"
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref3) {
            let {
              parser,
              funcName
            } = _ref3;
            const name = checkControlSequence(parser.gullet.popToken());
            parser.gullet.consumeSpaces();
            const tok = getRHS(parser);
            letCommand(parser, name, tok, funcName === "\\\\globallet");
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\futurelet",
            "\\\\globalfuture"
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref4) {
            let {
              parser,
              funcName
            } = _ref4;
            const name = checkControlSequence(parser.gullet.popToken());
            const middle = parser.gullet.popToken();
            const tok = parser.gullet.popToken();
            letCommand(parser, name, tok, funcName === "\\\\globalfuture");
            parser.gullet.pushToken(tok);
            parser.gullet.pushToken(middle);
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        ;
        const getMetrics = function(symbol, font, mode) {
          const replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
          const metrics = getCharacterMetrics(replace || symbol, font, mode);
          if (!metrics) {
            throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
          }
          return metrics;
        };
        const styleWrap = function(delim, toStyle, options, classes) {
          const newOptions = options.havingBaseStyle(toStyle);
          const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
          const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
          span.height *= delimSizeMultiplier;
          span.depth *= delimSizeMultiplier;
          span.maxFontSize = newOptions.sizeMultiplier;
          return span;
        };
        const centerSpan = function(span, options, style) {
          const newOptions = options.havingBaseStyle(style);
          const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
          span.classes.push("delimcenter");
          span.style.top = makeEm(shift);
          span.height -= shift;
          span.depth += shift;
        };
        const makeSmallDelim = function(delim, style, center, options, mode, classes) {
          const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
          const span = styleWrap(text, style, options, classes);
          if (center) {
            centerSpan(span, options, style);
          }
          return span;
        };
        const mathrmSize = function(value, size, mode, options) {
          return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
        };
        const makeLargeDelim = function(delim, size, center, options, mode, classes) {
          const inner2 = mathrmSize(delim, size, mode, options);
          const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
          if (center) {
            centerSpan(span, options, src_Style.TEXT);
          }
          return span;
        };
        const makeGlyphSpan = function(symbol, font, mode) {
          let sizeClass;
          if (font === "Size1-Regular") {
            sizeClass = "delim-size1";
          } else {
            sizeClass = "delim-size4";
          }
          const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
          return {
            type: "elem",
            elem: corner
          };
        };
        const makeInner = function(ch, height, options) {
          const width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
          const path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
          const svgNode = new SvgNode([path2], {
            "width": makeEm(width),
            "height": makeEm(height),
            "style": "width:" + makeEm(width),
            "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
            "preserveAspectRatio": "xMinYMin"
          });
          const span = buildCommon.makeSvgSpan([], [svgNode], options);
          span.height = height;
          span.style.height = makeEm(height);
          span.style.width = makeEm(width);
          return {
            type: "elem",
            elem: span
          };
        };
        const lapInEms = 8e-3;
        const lap = {
          type: "kern",
          size: -1 * lapInEms
        };
        const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
        const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
        const makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
          let top;
          let middle;
          let repeat;
          let bottom;
          let svgLabel = "";
          let viewBoxWidth = 0;
          top = repeat = bottom = delim;
          middle = null;
          let font = "Size1-Regular";
          if (delim === "\\uparrow") {
            repeat = bottom = "\u23D0";
          } else if (delim === "\\Uparrow") {
            repeat = bottom = "\u2016";
          } else if (delim === "\\downarrow") {
            top = repeat = "\u23D0";
          } else if (delim === "\\Downarrow") {
            top = repeat = "\u2016";
          } else if (delim === "\\updownarrow") {
            top = "\\uparrow";
            repeat = "\u23D0";
            bottom = "\\downarrow";
          } else if (delim === "\\Updownarrow") {
            top = "\\Uparrow";
            repeat = "\u2016";
            bottom = "\\Downarrow";
          } else if (verts.includes(delim)) {
            repeat = "\u2223";
            svgLabel = "vert";
            viewBoxWidth = 333;
          } else if (doubleVerts.includes(delim)) {
            repeat = "\u2225";
            svgLabel = "doublevert";
            viewBoxWidth = 556;
          } else if (delim === "[" || delim === "\\lbrack") {
            top = "\u23A1";
            repeat = "\u23A2";
            bottom = "\u23A3";
            font = "Size4-Regular";
            svgLabel = "lbrack";
            viewBoxWidth = 667;
          } else if (delim === "]" || delim === "\\rbrack") {
            top = "\u23A4";
            repeat = "\u23A5";
            bottom = "\u23A6";
            font = "Size4-Regular";
            svgLabel = "rbrack";
            viewBoxWidth = 667;
          } else if (delim === "\\lfloor" || delim === "\u230A") {
            repeat = top = "\u23A2";
            bottom = "\u23A3";
            font = "Size4-Regular";
            svgLabel = "lfloor";
            viewBoxWidth = 667;
          } else if (delim === "\\lceil" || delim === "\u2308") {
            top = "\u23A1";
            repeat = bottom = "\u23A2";
            font = "Size4-Regular";
            svgLabel = "lceil";
            viewBoxWidth = 667;
          } else if (delim === "\\rfloor" || delim === "\u230B") {
            repeat = top = "\u23A5";
            bottom = "\u23A6";
            font = "Size4-Regular";
            svgLabel = "rfloor";
            viewBoxWidth = 667;
          } else if (delim === "\\rceil" || delim === "\u2309") {
            top = "\u23A4";
            repeat = bottom = "\u23A5";
            font = "Size4-Regular";
            svgLabel = "rceil";
            viewBoxWidth = 667;
          } else if (delim === "(" || delim === "\\lparen") {
            top = "\u239B";
            repeat = "\u239C";
            bottom = "\u239D";
            font = "Size4-Regular";
            svgLabel = "lparen";
            viewBoxWidth = 875;
          } else if (delim === ")" || delim === "\\rparen") {
            top = "\u239E";
            repeat = "\u239F";
            bottom = "\u23A0";
            font = "Size4-Regular";
            svgLabel = "rparen";
            viewBoxWidth = 875;
          } else if (delim === "\\{" || delim === "\\lbrace") {
            top = "\u23A7";
            middle = "\u23A8";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\}" || delim === "\\rbrace") {
            top = "\u23AB";
            middle = "\u23AC";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\lgroup" || delim === "\u27EE") {
            top = "\u23A7";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\rgroup" || delim === "\u27EF") {
            top = "\u23AB";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\lmoustache" || delim === "\u23B0") {
            top = "\u23A7";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\rmoustache" || delim === "\u23B1") {
            top = "\u23AB";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          }
          const topMetrics = getMetrics(top, font, mode);
          const topHeightTotal = topMetrics.height + topMetrics.depth;
          const repeatMetrics = getMetrics(repeat, font, mode);
          const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
          const bottomMetrics = getMetrics(bottom, font, mode);
          const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
          let middleHeightTotal = 0;
          let middleFactor = 1;
          if (middle !== null) {
            const middleMetrics = getMetrics(middle, font, mode);
            middleHeightTotal = middleMetrics.height + middleMetrics.depth;
            middleFactor = 2;
          }
          const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
          const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
          const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
          let axisHeight = options.fontMetrics().axisHeight;
          if (center) {
            axisHeight *= options.sizeMultiplier;
          }
          const depth = realHeightTotal / 2 - axisHeight;
          const stack = [];
          if (svgLabel.length > 0) {
            const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
            const viewBoxHeight = Math.round(realHeightTotal * 1e3);
            const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
            const path2 = new PathNode(svgLabel, pathStr);
            const width = (viewBoxWidth / 1e3).toFixed(3) + "em";
            const height = (viewBoxHeight / 1e3).toFixed(3) + "em";
            const svg = new SvgNode([path2], {
              "width": width,
              "height": height,
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
            });
            const wrapper = buildCommon.makeSvgSpan([], [svg], options);
            wrapper.height = viewBoxHeight / 1e3;
            wrapper.style.width = width;
            wrapper.style.height = height;
            stack.push({
              type: "elem",
              elem: wrapper
            });
          } else {
            stack.push(makeGlyphSpan(bottom, font, mode));
            stack.push(lap);
            if (middle === null) {
              const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
              stack.push(makeInner(repeat, innerHeight, options));
            } else {
              const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
              stack.push(makeInner(repeat, innerHeight, options));
              stack.push(lap);
              stack.push(makeGlyphSpan(middle, font, mode));
              stack.push(lap);
              stack.push(makeInner(repeat, innerHeight, options));
            }
            stack.push(lap);
            stack.push(makeGlyphSpan(top, font, mode));
          }
          const newOptions = options.havingBaseStyle(src_Style.TEXT);
          const inner2 = buildCommon.makeVList({
            positionType: "bottom",
            positionData: depth,
            children: stack
          }, newOptions);
          return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
        };
        const vbPad = 80;
        const emPad = 0.08;
        const sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
          const path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
          const pathNode = new PathNode(sqrtName, path2);
          const svg = new SvgNode([pathNode], {
            "width": "400em",
            "height": makeEm(height),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
        };
        const makeSqrtImage = function(height, options) {
          const newOptions = options.havingBaseSizing();
          const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
          let sizeMultiplier = newOptions.sizeMultiplier;
          const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
          let span;
          let spanHeight = 0;
          let texHeight = 0;
          let viewBoxHeight = 0;
          let advanceWidth;
          if (delim.type === "small") {
            viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
            if (height < 1) {
              sizeMultiplier = 1;
            } else if (height < 1.4) {
              sizeMultiplier = 0.7;
            }
            spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
            texHeight = (1 + extraVinculum) / sizeMultiplier;
            span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "0.853em";
            advanceWidth = 0.833 / sizeMultiplier;
          } else if (delim.type === "large") {
            viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
            texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
            spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
            span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "1.02em";
            advanceWidth = 1 / sizeMultiplier;
          } else {
            spanHeight = height + extraVinculum + emPad;
            texHeight = height + extraVinculum;
            viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
            span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "0.742em";
            advanceWidth = 1.056;
          }
          span.height = texHeight;
          span.style.height = makeEm(spanHeight);
          return {
            span,
            advanceWidth,
            ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
          };
        };
        const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
        const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
        const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
        const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
        const makeSizedDelim = function(delim, size, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
            delim = "\\rangle";
          }
          if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {
            return makeLargeDelim(delim, size, false, options, mode, classes);
          } else if (stackAlwaysDelimiters.includes(delim)) {
            return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
          } else {
            throw new src_ParseError("Illegal delimiter: '" + delim + "'");
          }
        };
        const stackNeverDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }];
        const stackAlwaysDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "stack"
        }];
        const stackLargeDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }, {
          type: "stack"
        }];
        const delimTypeToFont = function(type) {
          if (type.type === "small") {
            return "Main-Regular";
          } else if (type.type === "large") {
            return "Size" + type.size + "-Regular";
          } else if (type.type === "stack") {
            return "Size4-Regular";
          } else {
            throw new Error("Add support for delim type '" + type.type + "' here.");
          }
        };
        const traverseSequence = function(delim, height, sequence, options) {
          const start = Math.min(2, 3 - options.style.size);
          for (let i = start; i < sequence.length; i++) {
            if (sequence[i].type === "stack") {
              break;
            }
            const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
            let heightDepth = metrics.height + metrics.depth;
            if (sequence[i].type === "small") {
              const newOptions = options.havingBaseStyle(sequence[i].style);
              heightDepth *= newOptions.sizeMultiplier;
            }
            if (heightDepth > height) {
              return sequence[i];
            }
          }
          return sequence[sequence.length - 1];
        };
        const makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
            delim = "\\rangle";
          }
          let sequence;
          if (stackNeverDelimiters.includes(delim)) {
            sequence = stackNeverDelimiterSequence;
          } else if (stackLargeDelimiters.includes(delim)) {
            sequence = stackLargeDelimiterSequence;
          } else {
            sequence = stackAlwaysDelimiterSequence;
          }
          const delimType = traverseSequence(delim, height, sequence, options);
          if (delimType.type === "small") {
            return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
          } else if (delimType.type === "large") {
            return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
          } else {
            return makeStackedDelim(delim, height, center, options, mode, classes);
          }
        };
        const makeLeftRightDelim = function(delim, height, depth, options, mode, classes) {
          const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
          const delimiterFactor = 901;
          const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
          const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
          const totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
          return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
        };
        var delimiter = {
          sqrtImage: makeSqrtImage,
          sizedDelim: makeSizedDelim,
          sizeToMaxHeight,
          customSizedDelim: makeCustomSizedDelim,
          leftRightDelim: makeLeftRightDelim
        };
        ;
        const delimiterSizes = {
          "\\bigl": {
            mclass: "mopen",
            size: 1
          },
          "\\Bigl": {
            mclass: "mopen",
            size: 2
          },
          "\\biggl": {
            mclass: "mopen",
            size: 3
          },
          "\\Biggl": {
            mclass: "mopen",
            size: 4
          },
          "\\bigr": {
            mclass: "mclose",
            size: 1
          },
          "\\Bigr": {
            mclass: "mclose",
            size: 2
          },
          "\\biggr": {
            mclass: "mclose",
            size: 3
          },
          "\\Biggr": {
            mclass: "mclose",
            size: 4
          },
          "\\bigm": {
            mclass: "mrel",
            size: 1
          },
          "\\Bigm": {
            mclass: "mrel",
            size: 2
          },
          "\\biggm": {
            mclass: "mrel",
            size: 3
          },
          "\\Biggm": {
            mclass: "mrel",
            size: 4
          },
          "\\big": {
            mclass: "mord",
            size: 1
          },
          "\\Big": {
            mclass: "mord",
            size: 2
          },
          "\\bigg": {
            mclass: "mord",
            size: 3
          },
          "\\Bigg": {
            mclass: "mord",
            size: 4
          }
        };
        const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
        function checkDelimiter(delim, context) {
          const symDelim = checkSymbolNodeType(delim);
          if (symDelim && delimiters.includes(symDelim.text)) {
            return symDelim;
          } else if (symDelim) {
            throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
          } else {
            throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
          }
        }
        defineFunction({
          type: "delimsizing",
          names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
          props: {
            numArgs: 1,
            argTypes: ["primitive"]
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            return {
              type: "delimsizing",
              mode: context.parser.mode,
              size: delimiterSizes[context.funcName].size,
              mclass: delimiterSizes[context.funcName].mclass,
              delim: delim.text
            };
          },
          htmlBuilder: (group, options) => {
            if (group.delim === ".") {
              return buildCommon.makeSpan([group.mclass]);
            }
            return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
          },
          mathmlBuilder: (group) => {
            const children = [];
            if (group.delim !== ".") {
              children.push(makeText(group.delim, group.mode));
            }
            const node = new mathMLTree.MathNode("mo", children);
            if (group.mclass === "mopen" || group.mclass === "mclose") {
              node.setAttribute("fence", "true");
            } else {
              node.setAttribute("fence", "false");
            }
            node.setAttribute("stretchy", "true");
            const size = makeEm(delimiter.sizeToMaxHeight[group.size]);
            node.setAttribute("minsize", size);
            node.setAttribute("maxsize", size);
            return node;
          }
        });
        function assertParsed(group) {
          if (!group.body) {
            throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
        }
        defineFunction({
          type: "leftright-right",
          names: ["\\right"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const color = context.parser.gullet.macros.get("\\current@color");
            if (color && typeof color !== "string") {
              throw new src_ParseError("\\current@color set to non-string in \\right");
            }
            return {
              type: "leftright-right",
              mode: context.parser.mode,
              delim: checkDelimiter(args[0], context).text,
              color
            };
          }
        });
        defineFunction({
          type: "leftright",
          names: ["\\left"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            const parser = context.parser;
            ++parser.leftrightDepth;
            const body = parser.parseExpression(false);
            --parser.leftrightDepth;
            parser.expect("\\right", false);
            const right = assertNodeType(parser.parseFunction(), "leftright-right");
            return {
              type: "leftright",
              mode: parser.mode,
              body,
              left: delim.text,
              right: right.delim,
              rightColor: right.color
            };
          },
          htmlBuilder: (group, options) => {
            assertParsed(group);
            const inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
            let innerHeight = 0;
            let innerDepth = 0;
            let hadMiddle = false;
            for (let i = 0; i < inner2.length; i++) {
              if (inner2[i].isMiddle) {
                hadMiddle = true;
              } else {
                innerHeight = Math.max(inner2[i].height, innerHeight);
                innerDepth = Math.max(inner2[i].depth, innerDepth);
              }
            }
            innerHeight *= options.sizeMultiplier;
            innerDepth *= options.sizeMultiplier;
            let leftDelim;
            if (group.left === ".") {
              leftDelim = makeNullDelimiter(options, ["mopen"]);
            } else {
              leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
            }
            inner2.unshift(leftDelim);
            if (hadMiddle) {
              for (let i = 1; i < inner2.length; i++) {
                const middleDelim = inner2[i];
                const isMiddle = middleDelim.isMiddle;
                if (isMiddle) {
                  inner2[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                }
              }
            }
            let rightDelim;
            if (group.right === ".") {
              rightDelim = makeNullDelimiter(options, ["mclose"]);
            } else {
              const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
              rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
            }
            inner2.push(rightDelim);
            return buildCommon.makeSpan(["minner"], inner2, options);
          },
          mathmlBuilder: (group, options) => {
            assertParsed(group);
            const inner2 = buildMathML_buildExpression(group.body, options);
            if (group.left !== ".") {
              const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
              leftNode.setAttribute("fence", "true");
              inner2.unshift(leftNode);
            }
            if (group.right !== ".") {
              const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
              rightNode.setAttribute("fence", "true");
              if (group.rightColor) {
                rightNode.setAttribute("mathcolor", group.rightColor);
              }
              inner2.push(rightNode);
            }
            return makeRow(inner2);
          }
        });
        defineFunction({
          type: "middle",
          names: ["\\middle"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            if (!context.parser.leftrightDepth) {
              throw new src_ParseError("\\middle without preceding \\left", delim);
            }
            return {
              type: "middle",
              mode: context.parser.mode,
              delim: delim.text
            };
          },
          htmlBuilder: (group, options) => {
            let middleDelim;
            if (group.delim === ".") {
              middleDelim = makeNullDelimiter(options, []);
            } else {
              middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
              const isMiddle = {
                delim: group.delim,
                options
              };
              middleDelim.isMiddle = isMiddle;
            }
            return middleDelim;
          },
          mathmlBuilder: (group, options) => {
            const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
            const middleNode = new mathMLTree.MathNode("mo", [textNode]);
            middleNode.setAttribute("fence", "true");
            middleNode.setAttribute("lspace", "0.05em");
            middleNode.setAttribute("rspace", "0.05em");
            return middleNode;
          }
        });
        ;
        const enclose_htmlBuilder = (group, options) => {
          const inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
          const label = group.label.slice(1);
          let scale = options.sizeMultiplier;
          let img;
          let imgShift = 0;
          const isSingleChar = utils.isCharacterBox(group.body);
          if (label === "sout") {
            img = buildCommon.makeSpan(["stretchy", "sout"]);
            img.height = options.fontMetrics().defaultRuleThickness / scale;
            imgShift = -0.5 * options.fontMetrics().xHeight;
          } else if (label === "phase") {
            const lineWeight = calculateSize({
              number: 0.6,
              unit: "pt"
            }, options);
            const clearance = calculateSize({
              number: 0.35,
              unit: "ex"
            }, options);
            const newOptions = options.havingBaseSizing();
            scale = scale / newOptions.sizeMultiplier;
            const angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
            inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
            const viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
            const path2 = phasePath(viewBoxHeight);
            const svgNode = new SvgNode([new PathNode("phase", path2)], {
              "width": "400em",
              "height": makeEm(viewBoxHeight / 1e3),
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
            img.style.height = makeEm(angleHeight);
            imgShift = inner2.depth + lineWeight + clearance;
          } else {
            if (/cancel/.test(label)) {
              if (!isSingleChar) {
                inner2.classes.push("cancel-pad");
              }
            } else if (label === "angl") {
              inner2.classes.push("anglpad");
            } else {
              inner2.classes.push("boxpad");
            }
            let topPad = 0;
            let bottomPad = 0;
            let ruleThickness = 0;
            if (/box/.test(label)) {
              ruleThickness = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
              topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
              bottomPad = topPad;
            } else if (label === "angl") {
              ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
              topPad = 4 * ruleThickness;
              bottomPad = Math.max(0, 0.25 - inner2.depth);
            } else {
              topPad = isSingleChar ? 0.2 : 0;
              bottomPad = topPad;
            }
            img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
            if (/fbox|boxed|fcolorbox/.test(label)) {
              img.style.borderStyle = "solid";
              img.style.borderWidth = makeEm(ruleThickness);
            } else if (label === "angl" && ruleThickness !== 0.049) {
              img.style.borderTopWidth = makeEm(ruleThickness);
              img.style.borderRightWidth = makeEm(ruleThickness);
            }
            imgShift = inner2.depth + bottomPad;
            if (group.backgroundColor) {
              img.style.backgroundColor = group.backgroundColor;
              if (group.borderColor) {
                img.style.borderColor = group.borderColor;
              }
            }
          }
          let vlist;
          if (group.backgroundColor) {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift
                },
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                }
              ]
            }, options);
          } else {
            const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                },
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift,
                  wrapperClasses: classes
                }
              ]
            }, options);
          }
          if (/cancel/.test(label)) {
            vlist.height = inner2.height;
            vlist.depth = inner2.depth;
          }
          if (/cancel/.test(label) && !isSingleChar) {
            return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
          } else {
            return buildCommon.makeSpan(["mord"], [vlist], options);
          }
        };
        const enclose_mathmlBuilder = (group, options) => {
          let fboxsep = 0;
          const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
          switch (group.label) {
            case "\\cancel":
              node.setAttribute("notation", "updiagonalstrike");
              break;
            case "\\bcancel":
              node.setAttribute("notation", "downdiagonalstrike");
              break;
            case "\\phase":
              node.setAttribute("notation", "phasorangle");
              break;
            case "\\sout":
              node.setAttribute("notation", "horizontalstrike");
              break;
            case "\\fbox":
              node.setAttribute("notation", "box");
              break;
            case "\\angl":
              node.setAttribute("notation", "actuarial");
              break;
            case "\\fcolorbox":
            case "\\colorbox":
              fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
              node.setAttribute("width", "+" + 2 * fboxsep + "pt");
              node.setAttribute("height", "+" + 2 * fboxsep + "pt");
              node.setAttribute("lspace", fboxsep + "pt");
              node.setAttribute("voffset", fboxsep + "pt");
              if (group.label === "\\fcolorbox") {
                const thk = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
                node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
              }
              break;
            case "\\xcancel":
              node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
              break;
          }
          if (group.backgroundColor) {
            node.setAttribute("mathbackground", group.backgroundColor);
          }
          return node;
        };
        defineFunction({
          type: "enclose",
          names: ["\\colorbox"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "text"]
          },
          handler(_ref, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref;
            const color = assertNodeType(args[0], "color-token").color;
            const body = args[1];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              backgroundColor: color,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fcolorbox"],
          props: {
            numArgs: 3,
            allowedInText: true,
            argTypes: ["color", "color", "text"]
          },
          handler(_ref2, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref2;
            const borderColor = assertNodeType(args[0], "color-token").color;
            const backgroundColor = assertNodeType(args[1], "color-token").color;
            const body = args[2];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              backgroundColor,
              borderColor,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fbox"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: true
          },
          handler(_ref3, args) {
            let {
              parser
            } = _ref3;
            return {
              type: "enclose",
              mode: parser.mode,
              label: "\\fbox",
              body: args[0]
            };
          }
        });
        defineFunction({
          type: "enclose",
          names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
          props: {
            numArgs: 1
          },
          handler(_ref4, args) {
            let {
              parser,
              funcName
            } = _ref4;
            const body = args[0];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\angl"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: false
          },
          handler(_ref5, args) {
            let {
              parser
            } = _ref5;
            return {
              type: "enclose",
              mode: parser.mode,
              label: "\\angl",
              body: args[0]
            };
          }
        });
        ;
        const _environments = {};
        function defineEnvironment(_ref) {
          let {
            type,
            names,
            props,
            handler,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref;
          const data = {
            type,
            numArgs: props.numArgs || 0,
            allowedInText: false,
            numOptionalArgs: 0,
            handler
          };
          for (let i = 0; i < names.length; ++i) {
            _environments[names[i]] = data;
          }
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
        ;
        const _macros = {};
        function defineMacro(name, body) {
          _macros[name] = body;
        }
        ;
        class SourceLocation {
          constructor(lexer, start, end) {
            this.lexer = void 0;
            this.start = void 0;
            this.end = void 0;
            this.lexer = lexer;
            this.start = start;
            this.end = end;
          }
          static range(first, second) {
            if (!second) {
              return first && first.loc;
            } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
              return null;
            } else {
              return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
            }
          }
        }
        ;
        class Token2 {
          constructor(text, loc) {
            this.text = void 0;
            this.loc = void 0;
            this.noexpand = void 0;
            this.treatAsRelax = void 0;
            this.text = text;
            this.loc = loc;
          }
          range(endToken, text) {
            return new Token2(text, SourceLocation.range(this, endToken));
          }
        }
        ;
        function getHLines(parser) {
          const hlineInfo = [];
          parser.consumeSpaces();
          let nxt = parser.fetch().text;
          if (nxt === "\\relax") {
            parser.consume();
            parser.consumeSpaces();
            nxt = parser.fetch().text;
          }
          while (nxt === "\\hline" || nxt === "\\hdashline") {
            parser.consume();
            hlineInfo.push(nxt === "\\hdashline");
            parser.consumeSpaces();
            nxt = parser.fetch().text;
          }
          return hlineInfo;
        }
        const validateAmsEnvironmentContext = (context) => {
          const settings = context.parser.settings;
          if (!settings.displayMode) {
            throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
          }
        };
        function getAutoTag(name) {
          if (name.indexOf("ed") === -1) {
            return name.indexOf("*") === -1;
          }
        }
        function parseArray(parser, _ref, style) {
          let {
            hskipBeforeAndAfter,
            addJot,
            cols,
            arraystretch,
            colSeparationType,
            autoTag,
            singleRow,
            emptySingleRow,
            maxNumCols,
            leqno
          } = _ref;
          parser.gullet.beginGroup();
          if (!singleRow) {
            parser.gullet.macros.set("\\cr", "\\\\\\relax");
          }
          if (!arraystretch) {
            const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
            if (stretch == null) {
              arraystretch = 1;
            } else {
              arraystretch = parseFloat(stretch);
              if (!arraystretch || arraystretch < 0) {
                throw new src_ParseError("Invalid \\arraystretch: " + stretch);
              }
            }
          }
          parser.gullet.beginGroup();
          let row = [];
          const body = [row];
          const rowGaps = [];
          const hLinesBeforeRow = [];
          const tags = autoTag != null ? [] : void 0;
          function beginRow() {
            if (autoTag) {
              parser.gullet.macros.set("\\@eqnsw", "1", true);
            }
          }
          function endRow() {
            if (tags) {
              if (parser.gullet.macros.get("\\df@tag")) {
                tags.push(parser.subparse([new Token2("\\df@tag")]));
                parser.gullet.macros.set("\\df@tag", void 0, true);
              } else {
                tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
              }
            }
          }
          beginRow();
          hLinesBeforeRow.push(getHLines(parser));
          while (true) {
            let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
            parser.gullet.endGroup();
            parser.gullet.beginGroup();
            cell = {
              type: "ordgroup",
              mode: parser.mode,
              body: cell
            };
            if (style) {
              cell = {
                type: "styling",
                mode: parser.mode,
                style,
                body: [cell]
              };
            }
            row.push(cell);
            const next = parser.fetch().text;
            if (next === "&") {
              if (maxNumCols && row.length === maxNumCols) {
                if (singleRow || colSeparationType) {
                  throw new src_ParseError("Too many tab characters: &", parser.nextToken);
                } else {
                  parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
              }
              parser.consume();
            } else if (next === "\\end") {
              endRow();
              if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                body.pop();
              }
              if (hLinesBeforeRow.length < body.length + 1) {
                hLinesBeforeRow.push([]);
              }
              break;
            } else if (next === "\\\\") {
              parser.consume();
              let size;
              if (parser.gullet.future().text !== " ") {
                size = parser.parseSizeGroup(true);
              }
              rowGaps.push(size ? size.value : null);
              endRow();
              hLinesBeforeRow.push(getHLines(parser));
              row = [];
              body.push(row);
              beginRow();
            } else {
              throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
            }
          }
          parser.gullet.endGroup();
          parser.gullet.endGroup();
          return {
            type: "array",
            mode: parser.mode,
            addJot,
            arraystretch,
            body,
            cols,
            rowGaps,
            hskipBeforeAndAfter,
            hLinesBeforeRow,
            colSeparationType,
            tags,
            leqno
          };
        }
        function dCellStyle(envName) {
          if (envName.slice(0, 1) === "d") {
            return "display";
          } else {
            return "text";
          }
        }
        const array_htmlBuilder = function(group, options) {
          let r;
          let c;
          const nr = group.body.length;
          const hLinesBeforeRow = group.hLinesBeforeRow;
          let nc = 0;
          let body = new Array(nr);
          const hlines = [];
          const ruleThickness = Math.max(options.fontMetrics().arrayRuleWidth, options.minRuleThickness);
          const pt = 1 / options.fontMetrics().ptPerEm;
          let arraycolsep = 5 * pt;
          if (group.colSeparationType && group.colSeparationType === "small") {
            const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
            arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
          }
          const baselineskip = group.colSeparationType === "CD" ? calculateSize({
            number: 3,
            unit: "ex"
          }, options) : 12 * pt;
          const jot = 3 * pt;
          const arrayskip = group.arraystretch * baselineskip;
          const arstrutHeight = 0.7 * arrayskip;
          const arstrutDepth = 0.3 * arrayskip;
          let totalHeight = 0;
          function setHLinePos(hlinesInGap) {
            for (let i = 0; i < hlinesInGap.length; ++i) {
              if (i > 0) {
                totalHeight += 0.25;
              }
              hlines.push({
                pos: totalHeight,
                isDashed: hlinesInGap[i]
              });
            }
          }
          setHLinePos(hLinesBeforeRow[0]);
          for (r = 0; r < group.body.length; ++r) {
            const inrow = group.body[r];
            let height = arstrutHeight;
            let depth = arstrutDepth;
            if (nc < inrow.length) {
              nc = inrow.length;
            }
            const outrow = new Array(inrow.length);
            for (c = 0; c < inrow.length; ++c) {
              const elt = buildGroup(inrow[c], options);
              if (depth < elt.depth) {
                depth = elt.depth;
              }
              if (height < elt.height) {
                height = elt.height;
              }
              outrow[c] = elt;
            }
            const rowGap = group.rowGaps[r];
            let gap = 0;
            if (rowGap) {
              gap = calculateSize(rowGap, options);
              if (gap > 0) {
                gap += arstrutDepth;
                if (depth < gap) {
                  depth = gap;
                }
                gap = 0;
              }
            }
            if (group.addJot) {
              depth += jot;
            }
            outrow.height = height;
            outrow.depth = depth;
            totalHeight += height;
            outrow.pos = totalHeight;
            totalHeight += depth + gap;
            body[r] = outrow;
            setHLinePos(hLinesBeforeRow[r + 1]);
          }
          const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
          const colDescriptions = group.cols || [];
          const cols = [];
          let colSep;
          let colDescrNum;
          const tagSpans = [];
          if (group.tags && group.tags.some((tag) => tag)) {
            for (r = 0; r < nr; ++r) {
              const rw = body[r];
              const shift = rw.pos - offset;
              const tag = group.tags[r];
              let tagSpan;
              if (tag === true) {
                tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
              } else if (tag === false) {
                tagSpan = buildCommon.makeSpan([], [], options);
              } else {
                tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
              }
              tagSpan.depth = rw.depth;
              tagSpan.height = rw.height;
              tagSpans.push({
                type: "elem",
                elem: tagSpan,
                shift
              });
            }
          }
          for (c = 0, colDescrNum = 0; c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
            let colDescr = colDescriptions[colDescrNum] || {};
            let firstSeparator = true;
            while (colDescr.type === "separator") {
              if (!firstSeparator) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
                cols.push(colSep);
              }
              if (colDescr.separator === "|" || colDescr.separator === ":") {
                const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                separator.style.height = makeEm(totalHeight);
                separator.style.borderRightWidth = makeEm(ruleThickness);
                separator.style.borderRightStyle = lineType;
                separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
                const shift = totalHeight - offset;
                if (shift) {
                  separator.style.verticalAlign = makeEm(-shift);
                }
                cols.push(separator);
              } else {
                throw new src_ParseError("Invalid separator type: " + colDescr.separator);
              }
              colDescrNum++;
              colDescr = colDescriptions[colDescrNum] || {};
              firstSeparator = false;
            }
            if (c >= nc) {
              continue;
            }
            let sepwidth;
            if (c > 0 || group.hskipBeforeAndAfter) {
              sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(sepwidth);
                cols.push(colSep);
              }
            }
            let col = [];
            for (r = 0; r < nr; ++r) {
              const row = body[r];
              const elem = row[c];
              if (!elem) {
                continue;
              }
              const shift = row.pos - offset;
              elem.depth = row.depth;
              elem.height = row.height;
              col.push({
                type: "elem",
                elem,
                shift
              });
            }
            col = buildCommon.makeVList({
              positionType: "individualShift",
              children: col
            }, options);
            col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
            cols.push(col);
            if (c < nc - 1 || group.hskipBeforeAndAfter) {
              sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(sepwidth);
                cols.push(colSep);
              }
            }
          }
          body = buildCommon.makeSpan(["mtable"], cols);
          if (hlines.length > 0) {
            const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
            const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
            const vListElems = [{
              type: "elem",
              elem: body,
              shift: 0
            }];
            while (hlines.length > 0) {
              const hline = hlines.pop();
              const lineShift = hline.pos - offset;
              if (hline.isDashed) {
                vListElems.push({
                  type: "elem",
                  elem: dashes,
                  shift: lineShift
                });
              } else {
                vListElems.push({
                  type: "elem",
                  elem: line,
                  shift: lineShift
                });
              }
            }
            body = buildCommon.makeVList({
              positionType: "individualShift",
              children: vListElems
            }, options);
          }
          if (tagSpans.length === 0) {
            return buildCommon.makeSpan(["mord"], [body], options);
          } else {
            let eqnNumCol = buildCommon.makeVList({
              positionType: "individualShift",
              children: tagSpans
            }, options);
            eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
            return buildCommon.makeFragment([body, eqnNumCol]);
          }
        };
        const alignMap = {
          c: "center ",
          l: "left ",
          r: "right "
        };
        const array_mathmlBuilder = function(group, options) {
          const tbl = [];
          const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
          const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
          for (let i = 0; i < group.body.length; i++) {
            const rw = group.body[i];
            const row = [];
            for (let j = 0; j < rw.length; j++) {
              row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
            }
            if (group.tags && group.tags[i]) {
              row.unshift(glue);
              row.push(glue);
              if (group.leqno) {
                row.unshift(tag);
              } else {
                row.push(tag);
              }
            }
            tbl.push(new mathMLTree.MathNode("mtr", row));
          }
          let table = new mathMLTree.MathNode("mtable", tbl);
          const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
          table.setAttribute("rowspacing", makeEm(gap));
          let menclose = "";
          let align = "";
          if (group.cols && group.cols.length > 0) {
            const cols = group.cols;
            let columnLines = "";
            let prevTypeWasAlign = false;
            let iStart = 0;
            let iEnd = cols.length;
            if (cols[0].type === "separator") {
              menclose += "top ";
              iStart = 1;
            }
            if (cols[cols.length - 1].type === "separator") {
              menclose += "bottom ";
              iEnd -= 1;
            }
            for (let i = iStart; i < iEnd; i++) {
              if (cols[i].type === "align") {
                align += alignMap[cols[i].align];
                if (prevTypeWasAlign) {
                  columnLines += "none ";
                }
                prevTypeWasAlign = true;
              } else if (cols[i].type === "separator") {
                if (prevTypeWasAlign) {
                  columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                  prevTypeWasAlign = false;
                }
              }
            }
            table.setAttribute("columnalign", align.trim());
            if (/[sd]/.test(columnLines)) {
              table.setAttribute("columnlines", columnLines.trim());
            }
          }
          if (group.colSeparationType === "align") {
            const cols = group.cols || [];
            let spacing2 = "";
            for (let i = 1; i < cols.length; i++) {
              spacing2 += i % 2 ? "0em " : "1em ";
            }
            table.setAttribute("columnspacing", spacing2.trim());
          } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
            table.setAttribute("columnspacing", "0em");
          } else if (group.colSeparationType === "small") {
            table.setAttribute("columnspacing", "0.2778em");
          } else if (group.colSeparationType === "CD") {
            table.setAttribute("columnspacing", "0.5em");
          } else {
            table.setAttribute("columnspacing", "1em");
          }
          let rowLines = "";
          const hlines = group.hLinesBeforeRow;
          menclose += hlines[0].length > 0 ? "left " : "";
          menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
          for (let i = 1; i < hlines.length - 1; i++) {
            rowLines += hlines[i].length === 0 ? "none " : hlines[i][0] ? "dashed " : "solid ";
          }
          if (/[sd]/.test(rowLines)) {
            table.setAttribute("rowlines", rowLines.trim());
          }
          if (menclose !== "") {
            table = new mathMLTree.MathNode("menclose", [table]);
            table.setAttribute("notation", menclose.trim());
          }
          if (group.arraystretch && group.arraystretch < 1) {
            table = new mathMLTree.MathNode("mstyle", [table]);
            table.setAttribute("scriptlevel", "1");
          }
          return table;
        };
        const alignedHandler = function(context, args) {
          if (context.envName.indexOf("ed") === -1) {
            validateAmsEnvironmentContext(context);
          }
          const cols = [];
          const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
          const isSplit = context.envName === "split";
          const res = parseArray(context.parser, {
            cols,
            addJot: true,
            autoTag: isSplit ? void 0 : getAutoTag(context.envName),
            emptySingleRow: true,
            colSeparationType: separationType,
            maxNumCols: isSplit ? 2 : void 0,
            leqno: context.parser.settings.leqno
          }, "display");
          let numMaths;
          let numCols = 0;
          const emptyGroup = {
            type: "ordgroup",
            mode: context.mode,
            body: []
          };
          if (args[0] && args[0].type === "ordgroup") {
            let arg0 = "";
            for (let i = 0; i < args[0].body.length; i++) {
              const textord2 = assertNodeType(args[0].body[i], "textord");
              arg0 += textord2.text;
            }
            numMaths = Number(arg0);
            numCols = numMaths * 2;
          }
          const isAligned = !numCols;
          res.body.forEach(function(row) {
            for (let i = 1; i < row.length; i += 2) {
              const styling = assertNodeType(row[i], "styling");
              const ordgroup = assertNodeType(styling.body[0], "ordgroup");
              ordgroup.body.unshift(emptyGroup);
            }
            if (!isAligned) {
              const curMaths = row.length / 2;
              if (numMaths < curMaths) {
                throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
              }
            } else if (numCols < row.length) {
              numCols = row.length;
            }
          });
          for (let i = 0; i < numCols; ++i) {
            let align = "r";
            let pregap = 0;
            if (i % 2 === 1) {
              align = "l";
            } else if (i > 0 && isAligned) {
              pregap = 1;
            }
            cols[i] = {
              type: "align",
              align,
              pregap,
              postgap: 0
            };
          }
          res.colSeparationType = isAligned ? "align" : "alignat";
          return res;
        };
        defineEnvironment({
          type: "array",
          names: ["array", "darray"],
          props: {
            numArgs: 1
          },
          handler(context, args) {
            const symNode = checkSymbolNodeType(args[0]);
            const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            const cols = colalign.map(function(nde) {
              const node = assertSymbolNodeType(nde);
              const ca = node.text;
              if ("lcr".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              } else if (ca === "|") {
                return {
                  type: "separator",
                  separator: "|"
                };
              } else if (ca === ":") {
                return {
                  type: "separator",
                  separator: ":"
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            const res = {
              cols,
              hskipBeforeAndAfter: true,
              maxNumCols: cols.length
            };
            return parseArray(context.parser, res, dCellStyle(context.envName));
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const delimiters2 = {
              "matrix": null,
              "pmatrix": ["(", ")"],
              "bmatrix": ["[", "]"],
              "Bmatrix": ["\\{", "\\}"],
              "vmatrix": ["|", "|"],
              "Vmatrix": ["\\Vert", "\\Vert"]
            }[context.envName.replace("*", "")];
            let colAlign = "c";
            const payload = {
              hskipBeforeAndAfter: false,
              cols: [{
                type: "align",
                align: colAlign
              }]
            };
            if (context.envName.charAt(context.envName.length - 1) === "*") {
              const parser = context.parser;
              parser.consumeSpaces();
              if (parser.fetch().text === "[") {
                parser.consume();
                parser.consumeSpaces();
                colAlign = parser.fetch().text;
                if ("lcr".indexOf(colAlign) === -1) {
                  throw new src_ParseError("Expected l or c or r", parser.nextToken);
                }
                parser.consume();
                parser.consumeSpaces();
                parser.expect("]");
                parser.consume();
                payload.cols = [{
                  type: "align",
                  align: colAlign
                }];
              }
            }
            const res = parseArray(context.parser, payload, dCellStyle(context.envName));
            const numCols = Math.max(0, ...res.body.map((row) => row.length));
            res.cols = new Array(numCols).fill({
              type: "align",
              align: colAlign
            });
            return delimiters2 ? {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: delimiters2[0],
              right: delimiters2[1],
              rightColor: void 0
            } : res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["smallmatrix"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const payload = {
              arraystretch: 0.5
            };
            const res = parseArray(context.parser, payload, "script");
            res.colSeparationType = "small";
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["subarray"],
          props: {
            numArgs: 1
          },
          handler(context, args) {
            const symNode = checkSymbolNodeType(args[0]);
            const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            const cols = colalign.map(function(nde) {
              const node = assertSymbolNodeType(nde);
              const ca = node.text;
              if ("lc".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            if (cols.length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            let res = {
              cols,
              hskipBeforeAndAfter: false,
              arraystretch: 0.5
            };
            res = parseArray(context.parser, res, "script");
            if (res.body.length > 0 && res.body[0].length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["cases", "dcases", "rcases", "drcases"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const payload = {
              arraystretch: 1.2,
              cols: [{
                type: "align",
                align: "l",
                pregap: 0,
                postgap: 1
              }, {
                type: "align",
                align: "l",
                pregap: 0,
                postgap: 0
              }]
            };
            const res = parseArray(context.parser, payload, dCellStyle(context.envName));
            return {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: context.envName.indexOf("r") > -1 ? "." : "\\{",
              right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
              rightColor: void 0
            };
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["align", "align*", "aligned", "split"],
          props: {
            numArgs: 0
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["gathered", "gather", "gather*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            if (["gather", "gather*"].includes(context.envName)) {
              validateAmsEnvironmentContext(context);
            }
            const res = {
              cols: [{
                type: "align",
                align: "c"
              }],
              addJot: true,
              colSeparationType: "gather",
              autoTag: getAutoTag(context.envName),
              emptySingleRow: true,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["alignat", "alignat*", "alignedat"],
          props: {
            numArgs: 1
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["equation", "equation*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            validateAmsEnvironmentContext(context);
            const res = {
              autoTag: getAutoTag(context.envName),
              emptySingleRow: true,
              singleRow: true,
              maxNumCols: 1,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["CD"],
          props: {
            numArgs: 0
          },
          handler(context) {
            validateAmsEnvironmentContext(context);
            return parseCD(context.parser);
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
        defineMacro("\\notag", "\\nonumber");
        defineFunction({
          type: "text",
          names: ["\\hline", "\\hdashline"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: true
          },
          handler(context, args) {
            throw new src_ParseError(context.funcName + " valid only within array environment");
          }
        });
        ;
        const environments = _environments;
        var src_environments = environments;
        ;
        defineFunction({
          type: "environment",
          names: ["\\begin", "\\end"],
          props: {
            numArgs: 1,
            argTypes: ["text"]
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const nameGroup = args[0];
            if (nameGroup.type !== "ordgroup") {
              throw new src_ParseError("Invalid environment name", nameGroup);
            }
            let envName = "";
            for (let i = 0; i < nameGroup.body.length; ++i) {
              envName += assertNodeType(nameGroup.body[i], "textord").text;
            }
            if (funcName === "\\begin") {
              if (!src_environments.hasOwnProperty(envName)) {
                throw new src_ParseError("No such environment: " + envName, nameGroup);
              }
              const env = src_environments[envName];
              const {
                args: args2,
                optArgs
              } = parser.parseArguments("\\begin{" + envName + "}", env);
              const context = {
                mode: parser.mode,
                envName,
                parser
              };
              const result = env.handler(context, args2, optArgs);
              parser.expect("\\end", false);
              const endNameToken = parser.nextToken;
              const end = assertNodeType(parser.parseFunction(), "environment");
              if (end.name !== envName) {
                throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
              }
              return result;
            }
            return {
              type: "environment",
              mode: parser.mode,
              name: envName,
              nameGroup
            };
          }
        });
        ;
        const font_htmlBuilder = (group, options) => {
          const font = group.font;
          const newOptions = options.withFont(font);
          return buildGroup(group.body, newOptions);
        };
        const font_mathmlBuilder = (group, options) => {
          const font = group.font;
          const newOptions = options.withFont(font);
          return buildMathML_buildGroup(group.body, newOptions);
        };
        const fontAliases = {
          "\\Bbb": "\\mathbb",
          "\\bold": "\\mathbf",
          "\\frak": "\\mathfrak",
          "\\bm": "\\boldsymbol"
        };
        defineFunction({
          type: "font",
          names: [
            "\\mathrm",
            "\\mathit",
            "\\mathbf",
            "\\mathnormal",
            "\\mathsfit",
            "\\mathbb",
            "\\mathcal",
            "\\mathfrak",
            "\\mathscr",
            "\\mathsf",
            "\\mathtt",
            "\\Bbb",
            "\\bold",
            "\\frak"
          ],
          props: {
            numArgs: 1,
            allowedInArgument: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = normalizeArgument(args[0]);
            let func = funcName;
            if (func in fontAliases) {
              func = fontAliases[func];
            }
            return {
              type: "font",
              mode: parser.mode,
              font: func.slice(1),
              body
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        defineFunction({
          type: "mclass",
          names: ["\\boldsymbol", "\\bm"],
          props: {
            numArgs: 1
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            const isCharacterBox2 = utils.isCharacterBox(body);
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: binrelClass(body),
              body: [{
                type: "font",
                mode: parser.mode,
                font: "boldsymbol",
                body
              }],
              isCharacterBox: isCharacterBox2
            };
          }
        });
        defineFunction({
          type: "font",
          names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: (_ref3, args) => {
            let {
              parser,
              funcName,
              breakOnTokenText
            } = _ref3;
            const {
              mode
            } = parser;
            const body = parser.parseExpression(true, breakOnTokenText);
            const style = "math" + funcName.slice(1);
            return {
              type: "font",
              mode,
              font: style,
              body: {
                type: "ordgroup",
                mode: parser.mode,
                body
              }
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        ;
        const adjustStyle = (size, originalStyle) => {
          let style = originalStyle;
          if (size === "display") {
            style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
          } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
            style = src_Style.TEXT;
          } else if (size === "script") {
            style = src_Style.SCRIPT;
          } else if (size === "scriptscript") {
            style = src_Style.SCRIPTSCRIPT;
          }
          return style;
        };
        const genfrac_htmlBuilder = (group, options) => {
          const style = adjustStyle(group.size, options.style);
          const nstyle = style.fracNum();
          const dstyle = style.fracDen();
          let newOptions;
          newOptions = options.havingStyle(nstyle);
          const numerm = buildGroup(group.numer, newOptions, options);
          if (group.continued) {
            const hStrut = 8.5 / options.fontMetrics().ptPerEm;
            const dStrut = 3.5 / options.fontMetrics().ptPerEm;
            numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
            numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
          }
          newOptions = options.havingStyle(dstyle);
          const denomm = buildGroup(group.denom, newOptions, options);
          let rule;
          let ruleWidth;
          let ruleSpacing;
          if (group.hasBarLine) {
            if (group.barSize) {
              ruleWidth = calculateSize(group.barSize, options);
              rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
            } else {
              rule = buildCommon.makeLineSpan("frac-line", options);
            }
            ruleWidth = rule.height;
            ruleSpacing = rule.height;
          } else {
            rule = null;
            ruleWidth = 0;
            ruleSpacing = options.fontMetrics().defaultRuleThickness;
          }
          let numShift;
          let clearance;
          let denomShift;
          if (style.size === src_Style.DISPLAY.size || group.size === "display") {
            numShift = options.fontMetrics().num1;
            if (ruleWidth > 0) {
              clearance = 3 * ruleSpacing;
            } else {
              clearance = 7 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom1;
          } else {
            if (ruleWidth > 0) {
              numShift = options.fontMetrics().num2;
              clearance = ruleSpacing;
            } else {
              numShift = options.fontMetrics().num3;
              clearance = 3 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom2;
          }
          let frac;
          if (!rule) {
            const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
            if (candidateClearance < clearance) {
              numShift += 0.5 * (clearance - candidateClearance);
              denomShift += 0.5 * (clearance - candidateClearance);
            }
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          } else {
            const axisHeight = options.fontMetrics().axisHeight;
            if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
              numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
            }
            if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
              denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
            }
            const midShift = -(axisHeight - 0.5 * ruleWidth);
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: rule,
                shift: midShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          }
          newOptions = options.havingStyle(style);
          frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
          frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
          let delimSize;
          if (style.size === src_Style.DISPLAY.size) {
            delimSize = options.fontMetrics().delim1;
          } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
            delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
          } else {
            delimSize = options.fontMetrics().delim2;
          }
          let leftDelim;
          let rightDelim;
          if (group.leftDelim == null) {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
          }
          if (group.continued) {
            rightDelim = buildCommon.makeSpan([]);
          } else if (group.rightDelim == null) {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
          }
          return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
        };
        const genfrac_mathmlBuilder = (group, options) => {
          let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
          if (!group.hasBarLine) {
            node.setAttribute("linethickness", "0px");
          } else if (group.barSize) {
            const ruleWidth = calculateSize(group.barSize, options);
            node.setAttribute("linethickness", makeEm(ruleWidth));
          }
          const style = adjustStyle(group.size, options.style);
          if (style.size !== options.style.size) {
            node = new mathMLTree.MathNode("mstyle", [node]);
            const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
            node.setAttribute("displaystyle", isDisplay);
            node.setAttribute("scriptlevel", "0");
          }
          if (group.leftDelim != null || group.rightDelim != null) {
            const withDelims = [];
            if (group.leftDelim != null) {
              const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
              leftOp.setAttribute("fence", "true");
              withDelims.push(leftOp);
            }
            withDelims.push(node);
            if (group.rightDelim != null) {
              const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
              rightOp.setAttribute("fence", "true");
              withDelims.push(rightOp);
            }
            return makeRow(withDelims);
          }
          return node;
        };
        defineFunction({
          type: "genfrac",
          names: [
            "\\dfrac",
            "\\frac",
            "\\tfrac",
            "\\dbinom",
            "\\binom",
            "\\tbinom",
            "\\\\atopfrac",
            "\\\\bracefrac",
            "\\\\brackfrac"
          ],
          props: {
            numArgs: 2,
            allowedInArgument: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const numer = args[0];
            const denom = args[1];
            let hasBarLine;
            let leftDelim = null;
            let rightDelim = null;
            let size = "auto";
            switch (funcName) {
              case "\\dfrac":
              case "\\frac":
              case "\\tfrac":
                hasBarLine = true;
                break;
              case "\\\\atopfrac":
                hasBarLine = false;
                break;
              case "\\dbinom":
              case "\\binom":
              case "\\tbinom":
                hasBarLine = false;
                leftDelim = "(";
                rightDelim = ")";
                break;
              case "\\\\bracefrac":
                hasBarLine = false;
                leftDelim = "\\{";
                rightDelim = "\\}";
                break;
              case "\\\\brackfrac":
                hasBarLine = false;
                leftDelim = "[";
                rightDelim = "]";
                break;
              default:
                throw new Error("Unrecognized genfrac command");
            }
            switch (funcName) {
              case "\\dfrac":
              case "\\dbinom":
                size = "display";
                break;
              case "\\tfrac":
              case "\\tbinom":
                size = "text";
                break;
            }
            return {
              type: "genfrac",
              mode: parser.mode,
              continued: false,
              numer,
              denom,
              hasBarLine,
              leftDelim,
              rightDelim,
              size,
              barSize: null
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "genfrac",
          names: ["\\cfrac"],
          props: {
            numArgs: 2
          },
          handler: (_ref2, args) => {
            let {
              parser,
              funcName
            } = _ref2;
            const numer = args[0];
            const denom = args[1];
            return {
              type: "genfrac",
              mode: parser.mode,
              continued: true,
              numer,
              denom,
              hasBarLine: true,
              leftDelim: null,
              rightDelim: null,
              size: "display",
              barSize: null
            };
          }
        });
        defineFunction({
          type: "infix",
          names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
          props: {
            numArgs: 0,
            infix: true
          },
          handler(_ref3) {
            let {
              parser,
              funcName,
              token
            } = _ref3;
            let replaceWith;
            switch (funcName) {
              case "\\over":
                replaceWith = "\\frac";
                break;
              case "\\choose":
                replaceWith = "\\binom";
                break;
              case "\\atop":
                replaceWith = "\\\\atopfrac";
                break;
              case "\\brace":
                replaceWith = "\\\\bracefrac";
                break;
              case "\\brack":
                replaceWith = "\\\\brackfrac";
                break;
              default:
                throw new Error("Unrecognized infix genfrac command");
            }
            return {
              type: "infix",
              mode: parser.mode,
              replaceWith,
              token
            };
          }
        });
        const stylArray = ["display", "text", "script", "scriptscript"];
        const delimFromValue = function(delimString) {
          let delim = null;
          if (delimString.length > 0) {
            delim = delimString;
            delim = delim === "." ? null : delim;
          }
          return delim;
        };
        defineFunction({
          type: "genfrac",
          names: ["\\genfrac"],
          props: {
            numArgs: 6,
            allowedInArgument: true,
            argTypes: ["math", "math", "size", "text", "math", "math"]
          },
          handler(_ref4, args) {
            let {
              parser
            } = _ref4;
            const numer = args[4];
            const denom = args[5];
            const leftNode = normalizeArgument(args[0]);
            const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
            const rightNode = normalizeArgument(args[1]);
            const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
            const barNode = assertNodeType(args[2], "size");
            let hasBarLine;
            let barSize = null;
            if (barNode.isBlank) {
              hasBarLine = true;
            } else {
              barSize = barNode.value;
              hasBarLine = barSize.number > 0;
            }
            let size = "auto";
            let styl = args[3];
            if (styl.type === "ordgroup") {
              if (styl.body.length > 0) {
                const textOrd = assertNodeType(styl.body[0], "textord");
                size = stylArray[Number(textOrd.text)];
              }
            } else {
              styl = assertNodeType(styl, "textord");
              size = stylArray[Number(styl.text)];
            }
            return {
              type: "genfrac",
              mode: parser.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim,
              rightDelim,
              size
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "infix",
          names: ["\\above"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            infix: true
          },
          handler(_ref5, args) {
            let {
              parser,
              funcName,
              token
            } = _ref5;
            return {
              type: "infix",
              mode: parser.mode,
              replaceWith: "\\\\abovefrac",
              size: assertNodeType(args[0], "size").value,
              token
            };
          }
        });
        defineFunction({
          type: "genfrac",
          names: ["\\\\abovefrac"],
          props: {
            numArgs: 3,
            argTypes: ["math", "size", "math"]
          },
          handler: (_ref6, args) => {
            let {
              parser,
              funcName
            } = _ref6;
            const numer = args[0];
            const barSize = assert(assertNodeType(args[1], "infix").size);
            const denom = args[2];
            const hasBarLine = barSize.number > 0;
            return {
              type: "genfrac",
              mode: parser.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim: null,
              rightDelim: null,
              size: "auto"
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        ;
        const horizBrace_htmlBuilder = (grp, options) => {
          const style = options.style;
          let supSubGroup;
          let group;
          if (grp.type === "supsub") {
            supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
            group = assertNodeType(grp.base, "horizBrace");
          } else {
            group = assertNodeType(grp, "horizBrace");
          }
          const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
          const braceBody = stretchy.svgSpan(group, options);
          let vlist;
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: braceBody
              }]
            }, options);
            vlist.children[0].children[0].children[1].classes.push("svg-align");
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: body.depth + 0.1 + braceBody.height,
              children: [{
                type: "elem",
                elem: braceBody
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: body
              }]
            }, options);
            vlist.children[0].children[0].children[0].classes.push("svg-align");
          }
          if (supSubGroup) {
            const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            if (group.isOver) {
              vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: vSpan
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: supSubGroup
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "bottom",
                positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                children: [{
                  type: "elem",
                  elem: supSubGroup
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: vSpan
                }]
              }, options);
            }
          }
          return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
        };
        const horizBrace_mathmlBuilder = (group, options) => {
          const accentNode = stretchy.mathMLnode(group.label);
          return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
        };
        defineFunction({
          type: "horizBrace",
          names: ["\\overbrace", "\\underbrace"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "horizBrace",
              mode: parser.mode,
              label: funcName,
              isOver: /^\\over/.test(funcName),
              base: args[0]
            };
          },
          htmlBuilder: horizBrace_htmlBuilder,
          mathmlBuilder: horizBrace_mathmlBuilder
        });
        ;
        defineFunction({
          type: "href",
          names: ["\\href"],
          props: {
            numArgs: 2,
            argTypes: ["url", "original"],
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            const body = args[1];
            const href = assertNodeType(args[0], "url").url;
            if (!parser.settings.isTrusted({
              command: "\\href",
              url: href
            })) {
              return parser.formatUnsupportedCmd("\\href");
            }
            return {
              type: "href",
              mode: parser.mode,
              href,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options, false);
            return buildCommon.makeAnchor(group.href, [], elements, options);
          },
          mathmlBuilder: (group, options) => {
            let math2 = buildExpressionRow(group.body, options);
            if (!(math2 instanceof MathNode)) {
              math2 = new MathNode("mrow", [math2]);
            }
            math2.setAttribute("href", group.href);
            return math2;
          }
        });
        defineFunction({
          type: "href",
          names: ["\\url"],
          props: {
            numArgs: 1,
            argTypes: ["url"],
            allowedInText: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const href = assertNodeType(args[0], "url").url;
            if (!parser.settings.isTrusted({
              command: "\\url",
              url: href
            })) {
              return parser.formatUnsupportedCmd("\\url");
            }
            const chars = [];
            for (let i = 0; i < href.length; i++) {
              let c = href[i];
              if (c === "~") {
                c = "\\textasciitilde";
              }
              chars.push({
                type: "textord",
                mode: "text",
                text: c
              });
            }
            const body = {
              type: "text",
              mode: parser.mode,
              font: "\\texttt",
              body: chars
            };
            return {
              type: "href",
              mode: parser.mode,
              href,
              body: ordargument(body)
            };
          }
        });
        ;
        defineFunction({
          type: "hbox",
          names: ["\\hbox"],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInText: true,
            primitive: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "hbox",
              mode: parser.mode,
              body: ordargument(args[0])
            };
          },
          htmlBuilder(group, options) {
            const elements = buildExpression(group.body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
          }
        });
        ;
        defineFunction({
          type: "html",
          names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
          props: {
            numArgs: 2,
            argTypes: ["raw", "original"],
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName,
              token
            } = _ref;
            const value = assertNodeType(args[0], "raw").string;
            const body = args[1];
            if (parser.settings.strict) {
              parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
            }
            let trustContext;
            const attributes = {};
            switch (funcName) {
              case "\\htmlClass":
                attributes.class = value;
                trustContext = {
                  command: "\\htmlClass",
                  class: value
                };
                break;
              case "\\htmlId":
                attributes.id = value;
                trustContext = {
                  command: "\\htmlId",
                  id: value
                };
                break;
              case "\\htmlStyle":
                attributes.style = value;
                trustContext = {
                  command: "\\htmlStyle",
                  style: value
                };
                break;
              case "\\htmlData": {
                const data = value.split(",");
                for (let i = 0; i < data.length; i++) {
                  const item = data[i];
                  const firstEquals = item.indexOf("=");
                  if (firstEquals < 0) {
                    throw new src_ParseError("\\htmlData key/value '" + item + "' missing equals sign");
                  }
                  const key = item.slice(0, firstEquals);
                  const value2 = item.slice(firstEquals + 1);
                  attributes["data-" + key.trim()] = value2;
                }
                trustContext = {
                  command: "\\htmlData",
                  attributes
                };
                break;
              }
              default:
                throw new Error("Unrecognized html command");
            }
            if (!parser.settings.isTrusted(trustContext)) {
              return parser.formatUnsupportedCmd(funcName);
            }
            return {
              type: "html",
              mode: parser.mode,
              attributes,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options, false);
            const classes = ["enclosing"];
            if (group.attributes.class) {
              classes.push(...group.attributes.class.trim().split(/\s+/));
            }
            const span = buildCommon.makeSpan(classes, elements, options);
            for (const attr in group.attributes) {
              if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
                span.setAttribute(attr, group.attributes[attr]);
              }
            }
            return span;
          },
          mathmlBuilder: (group, options) => {
            return buildExpressionRow(group.body, options);
          }
        });
        ;
        defineFunction({
          type: "htmlmathml",
          names: ["\\html@mathml"],
          props: {
            numArgs: 2,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            return {
              type: "htmlmathml",
              mode: parser.mode,
              html: ordargument(args[0]),
              mathml: ordargument(args[1])
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.html, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            return buildExpressionRow(group.mathml, options);
          }
        });
        ;
        const sizeData = function(str) {
          if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
            return {
              number: +str,
              unit: "bp"
            };
          } else {
            const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
            if (!match) {
              throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
            }
            const data = {
              number: +(match[1] + match[2]),
              unit: match[3]
            };
            if (!validUnit(data)) {
              throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
            }
            return data;
          }
        };
        defineFunction({
          type: "includegraphics",
          names: ["\\includegraphics"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            argTypes: ["raw", "url"],
            allowedInText: false
          },
          handler: (_ref, args, optArgs) => {
            let {
              parser
            } = _ref;
            let width = {
              number: 0,
              unit: "em"
            };
            let height = {
              number: 0.9,
              unit: "em"
            };
            let totalheight = {
              number: 0,
              unit: "em"
            };
            let alt = "";
            if (optArgs[0]) {
              const attributeStr = assertNodeType(optArgs[0], "raw").string;
              const attributes = attributeStr.split(",");
              for (let i = 0; i < attributes.length; i++) {
                const keyVal = attributes[i].split("=");
                if (keyVal.length === 2) {
                  const str = keyVal[1].trim();
                  switch (keyVal[0].trim()) {
                    case "alt":
                      alt = str;
                      break;
                    case "width":
                      width = sizeData(str);
                      break;
                    case "height":
                      height = sizeData(str);
                      break;
                    case "totalheight":
                      totalheight = sizeData(str);
                      break;
                    default:
                      throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                  }
                }
              }
            }
            const src = assertNodeType(args[0], "url").url;
            if (alt === "") {
              alt = src;
              alt = alt.replace(/^.*[\\/]/, "");
              alt = alt.substring(0, alt.lastIndexOf("."));
            }
            if (!parser.settings.isTrusted({
              command: "\\includegraphics",
              url: src
            })) {
              return parser.formatUnsupportedCmd("\\includegraphics");
            }
            return {
              type: "includegraphics",
              mode: parser.mode,
              alt,
              width,
              height,
              totalheight,
              src
            };
          },
          htmlBuilder: (group, options) => {
            const height = calculateSize(group.height, options);
            let depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
            }
            let width = 0;
            if (group.width.number > 0) {
              width = calculateSize(group.width, options);
            }
            const style = {
              height: makeEm(height + depth)
            };
            if (width > 0) {
              style.width = makeEm(width);
            }
            if (depth > 0) {
              style.verticalAlign = makeEm(-depth);
            }
            const node = new Img(group.src, group.alt, style);
            node.height = height;
            node.depth = depth;
            return node;
          },
          mathmlBuilder: (group, options) => {
            const node = new mathMLTree.MathNode("mglyph", []);
            node.setAttribute("alt", group.alt);
            const height = calculateSize(group.height, options);
            let depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
              node.setAttribute("valign", makeEm(-depth));
            }
            node.setAttribute("height", makeEm(height + depth));
            if (group.width.number > 0) {
              const width = calculateSize(group.width, options);
              node.setAttribute("width", makeEm(width));
            }
            node.setAttribute("src", group.src);
            return node;
          }
        });
        ;
        defineFunction({
          type: "kern",
          names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            primitive: true,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const size = assertNodeType(args[0], "size");
            if (parser.settings.strict) {
              const mathFunction = funcName[1] === "m";
              const muUnit = size.value.unit === "mu";
              if (mathFunction) {
                if (!muUnit) {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                }
                if (parser.mode !== "math") {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                }
              } else {
                if (muUnit) {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                }
              }
            }
            return {
              type: "kern",
              mode: parser.mode,
              dimension: size.value
            };
          },
          htmlBuilder(group, options) {
            return buildCommon.makeGlue(group.dimension, options);
          },
          mathmlBuilder(group, options) {
            const dimension = calculateSize(group.dimension, options);
            return new mathMLTree.SpaceNode(dimension);
          }
        });
        ;
        defineFunction({
          type: "lap",
          names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "lap",
              mode: parser.mode,
              alignment: funcName.slice(5),
              body
            };
          },
          htmlBuilder: (group, options) => {
            let inner2;
            if (group.alignment === "clap") {
              inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
              inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
            } else {
              inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
            }
            const fix = buildCommon.makeSpan(["fix"], []);
            let node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
            const strut = buildCommon.makeSpan(["strut"]);
            strut.style.height = makeEm(node.height + node.depth);
            if (node.depth) {
              strut.style.verticalAlign = makeEm(-node.depth);
            }
            node.children.unshift(strut);
            node = buildCommon.makeSpan(["thinbox"], [node], options);
            return buildCommon.makeSpan(["mord", "vbox"], [node], options);
          },
          mathmlBuilder: (group, options) => {
            const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.alignment !== "rlap") {
              const offset = group.alignment === "llap" ? "-1" : "-0.5";
              node.setAttribute("lspace", offset + "width");
            }
            node.setAttribute("width", "0px");
            return node;
          }
        });
        ;
        defineFunction({
          type: "styling",
          names: ["\\(", "$"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler(_ref, args) {
            let {
              funcName,
              parser
            } = _ref;
            const outerMode = parser.mode;
            parser.switchMode("math");
            const close = funcName === "\\(" ? "\\)" : "$";
            const body = parser.parseExpression(false, close);
            parser.expect(close);
            parser.switchMode(outerMode);
            return {
              type: "styling",
              mode: parser.mode,
              style: "text",
              body
            };
          }
        });
        defineFunction({
          type: "text",
          names: ["\\)", "\\]"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler(context, args) {
            throw new src_ParseError("Mismatched " + context.funcName);
          }
        });
        ;
        const chooseMathStyle = (group, options) => {
          switch (options.style.size) {
            case src_Style.DISPLAY.size:
              return group.display;
            case src_Style.TEXT.size:
              return group.text;
            case src_Style.SCRIPT.size:
              return group.script;
            case src_Style.SCRIPTSCRIPT.size:
              return group.scriptscript;
            default:
              return group.text;
          }
        };
        defineFunction({
          type: "mathchoice",
          names: ["\\mathchoice"],
          props: {
            numArgs: 4,
            primitive: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            return {
              type: "mathchoice",
              mode: parser.mode,
              display: ordargument(args[0]),
              text: ordargument(args[1]),
              script: ordargument(args[2]),
              scriptscript: ordargument(args[3])
            };
          },
          htmlBuilder: (group, options) => {
            const body = chooseMathStyle(group, options);
            const elements = buildExpression(body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            const body = chooseMathStyle(group, options);
            return buildExpressionRow(body, options);
          }
        });
        ;
        const assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
          base = buildCommon.makeSpan([], [base]);
          const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
          let sub2;
          let sup2;
          if (supGroup) {
            const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
            sup2 = {
              elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
            };
          }
          if (subGroup) {
            const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
            sub2 = {
              elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
            };
          }
          let finalGroup;
          if (sup2 && sub2) {
            const bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: bottom,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub2.elem,
                marginLeft: makeEm(-slant)
              }, {
                type: "kern",
                size: sub2.kern
              }, {
                type: "elem",
                elem: base
              }, {
                type: "kern",
                size: sup2.kern
              }, {
                type: "elem",
                elem: sup2.elem,
                marginLeft: makeEm(slant)
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else if (sub2) {
            const top = base.height - baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "top",
              positionData: top,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub2.elem,
                marginLeft: makeEm(-slant)
              }, {
                type: "kern",
                size: sub2.kern
              }, {
                type: "elem",
                elem: base
              }]
            }, options);
          } else if (sup2) {
            const bottom = base.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: bottom,
              children: [{
                type: "elem",
                elem: base
              }, {
                type: "kern",
                size: sup2.kern
              }, {
                type: "elem",
                elem: sup2.elem,
                marginLeft: makeEm(slant)
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else {
            return base;
          }
          const parts = [finalGroup];
          if (sub2 && slant !== 0 && !subIsSingleCharacter) {
            const spacer = buildCommon.makeSpan(["mspace"], [], options);
            spacer.style.marginRight = makeEm(slant);
            parts.unshift(spacer);
          }
          return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
        };
        ;
        const noSuccessor = ["\\smallint"];
        const op_htmlBuilder = (grp, options) => {
          let supGroup;
          let subGroup;
          let hasLimits = false;
          let group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "op");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "op");
          }
          const style = options.style;
          let large = false;
          if (style.size === src_Style.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {
            large = true;
          }
          let base;
          if (group.symbol) {
            const fontName = large ? "Size2-Regular" : "Size1-Regular";
            let stash = "";
            if (group.name === "\\oiint" || group.name === "\\oiiint") {
              stash = group.name.slice(1);
              group.name = stash === "oiint" ? "\\iint" : "\\iiint";
            }
            base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
            if (stash.length > 0) {
              const italic = base.italic;
              const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
              base = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: base,
                  shift: 0
                }, {
                  type: "elem",
                  elem: oval,
                  shift: large ? 0.08 : 0
                }]
              }, options);
              group.name = "\\" + stash;
              base.classes.unshift("mop");
              base.italic = italic;
            }
          } else if (group.body) {
            const inner2 = buildExpression(group.body, options, true);
            if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
              base = inner2[0];
              base.classes[0] = "mop";
            } else {
              base = buildCommon.makeSpan(["mop"], inner2, options);
            }
          } else {
            const output = [];
            for (let i = 1; i < group.name.length; i++) {
              output.push(buildCommon.mathsym(group.name[i], group.mode, options));
            }
            base = buildCommon.makeSpan(["mop"], output, options);
          }
          let baseShift = 0;
          let slant = 0;
          if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
            baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
            slant = base.italic;
          }
          if (hasLimits) {
            return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
          } else {
            if (baseShift) {
              base.style.position = "relative";
              base.style.top = makeEm(baseShift);
            }
            return base;
          }
        };
        const op_mathmlBuilder = (group, options) => {
          let node;
          if (group.symbol) {
            node = new MathNode("mo", [makeText(group.name, group.mode)]);
            if (noSuccessor.includes(group.name)) {
              node.setAttribute("largeop", "false");
            }
          } else if (group.body) {
            node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
          } else {
            node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
            const operator = new MathNode("mo", [makeText("\u2061", "text")]);
            if (group.parentIsSupSub) {
              node = new MathNode("mrow", [node, operator]);
            } else {
              node = newDocumentFragment([node, operator]);
            }
          }
          return node;
        };
        const singleCharBigOps = {
          "\u220F": "\\prod",
          "\u2210": "\\coprod",
          "\u2211": "\\sum",
          "\u22C0": "\\bigwedge",
          "\u22C1": "\\bigvee",
          "\u22C2": "\\bigcap",
          "\u22C3": "\\bigcup",
          "\u2A00": "\\bigodot",
          "\u2A01": "\\bigoplus",
          "\u2A02": "\\bigotimes",
          "\u2A04": "\\biguplus",
          "\u2A06": "\\bigsqcup"
        };
        defineFunction({
          type: "op",
          names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
          props: {
            numArgs: 0
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            let fName = funcName;
            if (fName.length === 1) {
              fName = singleCharBigOps[fName];
            }
            return {
              type: "op",
              mode: parser.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\mathop"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              body: ordargument(body)
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        const singleCharIntegrals = {
          "\u222B": "\\int",
          "\u222C": "\\iint",
          "\u222D": "\\iiint",
          "\u222E": "\\oint",
          "\u222F": "\\oiint",
          "\u2230": "\\oiiint"
        };
        defineFunction({
          type: "op",
          names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
          props: {
            numArgs: 0
          },
          handler(_ref3) {
            let {
              parser,
              funcName
            } = _ref3;
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
          props: {
            numArgs: 0
          },
          handler(_ref4) {
            let {
              parser,
              funcName
            } = _ref4;
            return {
              type: "op",
              mode: parser.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
          props: {
            numArgs: 0,
            allowedInArgument: true
          },
          handler(_ref5) {
            let {
              parser,
              funcName
            } = _ref5;
            let fName = funcName;
            if (fName.length === 1) {
              fName = singleCharIntegrals[fName];
            }
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        ;
        const operatorname_htmlBuilder = (grp, options) => {
          let supGroup;
          let subGroup;
          let hasLimits = false;
          let group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "operatorname");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "operatorname");
          }
          let base;
          if (group.body.length > 0) {
            const body = group.body.map((child) => {
              const childText = child.text;
              if (typeof childText === "string") {
                return {
                  type: "textord",
                  mode: child.mode,
                  text: childText
                };
              } else {
                return child;
              }
            });
            const expression = buildExpression(body, options.withFont("mathrm"), true);
            for (let i = 0; i < expression.length; i++) {
              const child = expression[i];
              if (child instanceof SymbolNode) {
                child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
              }
            }
            base = buildCommon.makeSpan(["mop"], expression, options);
          } else {
            base = buildCommon.makeSpan(["mop"], [], options);
          }
          if (hasLimits) {
            return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
          } else {
            return base;
          }
        };
        const operatorname_mathmlBuilder = (group, options) => {
          let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
          let isAllString = true;
          for (let i = 0; i < expression.length; i++) {
            const node = expression[i];
            if (node instanceof mathMLTree.SpaceNode) {
            } else if (node instanceof mathMLTree.MathNode) {
              switch (node.type) {
                case "mi":
                case "mn":
                case "ms":
                case "mspace":
                case "mtext":
                  break;
                case "mo": {
                  const child = node.children[0];
                  if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  } else {
                    isAllString = false;
                  }
                  break;
                }
                default:
                  isAllString = false;
              }
            } else {
              isAllString = false;
            }
          }
          if (isAllString) {
            const word = expression.map((node) => node.toText()).join("");
            expression = [new mathMLTree.TextNode(word)];
          }
          const identifier = new mathMLTree.MathNode("mi", expression);
          identifier.setAttribute("mathvariant", "normal");
          const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            return new mathMLTree.MathNode("mrow", [identifier, operator]);
          } else {
            return mathMLTree.newDocumentFragment([identifier, operator]);
          }
        };
        defineFunction({
          type: "operatorname",
          names: ["\\operatorname@", "\\operatornamewithlimits"],
          props: {
            numArgs: 1
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "operatorname",
              mode: parser.mode,
              body: ordargument(body),
              alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
              limits: false,
              parentIsSupSub: false
            };
          },
          htmlBuilder: operatorname_htmlBuilder,
          mathmlBuilder: operatorname_mathmlBuilder
        });
        defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
        ;
        defineFunctionBuilders({
          type: "ordgroup",
          htmlBuilder(group, options) {
            if (group.semisimple) {
              return buildCommon.makeFragment(buildExpression(group.body, options, false));
            }
            return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
          },
          mathmlBuilder(group, options) {
            return buildExpressionRow(group.body, options, true);
          }
        });
        ;
        defineFunction({
          type: "overline",
          names: ["\\overline"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const body = args[0];
            return {
              type: "overline",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder(group, options) {
            const innerGroup = buildGroup(group.body, options.havingCrampedStyle());
            const line = buildCommon.makeLineSpan("overline-line", options);
            const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            const vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: innerGroup
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: defaultRuleThickness
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
            operator.setAttribute("stretchy", "true");
            const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
            node.setAttribute("accent", "true");
            return node;
          }
        });
        ;
        defineFunction({
          type: "phantom",
          names: ["\\phantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            const body = args[0];
            return {
              type: "phantom",
              mode: parser.mode,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options.withPhantom(), false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(group.body, options);
            return new mathMLTree.MathNode("mphantom", inner2);
          }
        });
        defineFunction({
          type: "hphantom",
          names: ["\\hphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            return {
              type: "hphantom",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder: (group, options) => {
            let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
            node.height = 0;
            node.depth = 0;
            if (node.children) {
              for (let i = 0; i < node.children.length; i++) {
                node.children[i].height = 0;
                node.children[i].depth = 0;
              }
            }
            node = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [node], options);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            const phantom = new mathMLTree.MathNode("mphantom", inner2);
            const node = new mathMLTree.MathNode("mpadded", [phantom]);
            node.setAttribute("height", "0px");
            node.setAttribute("depth", "0px");
            return node;
          }
        });
        defineFunction({
          type: "vphantom",
          names: ["\\vphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref3, args) => {
            let {
              parser
            } = _ref3;
            const body = args[0];
            return {
              type: "vphantom",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder: (group, options) => {
            const inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
            const fix = buildCommon.makeSpan(["fix"], []);
            return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            const phantom = new mathMLTree.MathNode("mphantom", inner2);
            const node = new mathMLTree.MathNode("mpadded", [phantom]);
            node.setAttribute("width", "0px");
            return node;
          }
        });
        ;
        defineFunction({
          type: "raisebox",
          names: ["\\raisebox"],
          props: {
            numArgs: 2,
            argTypes: ["size", "hbox"],
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const amount = assertNodeType(args[0], "size").value;
            const body = args[1];
            return {
              type: "raisebox",
              mode: parser.mode,
              dy: amount,
              body
            };
          },
          htmlBuilder(group, options) {
            const body = buildGroup(group.body, options);
            const dy = calculateSize(group.dy, options);
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: -dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder(group, options) {
            const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            const dy = group.dy.number + group.dy.unit;
            node.setAttribute("voffset", dy);
            return node;
          }
        });
        ;
        defineFunction({
          type: "internal",
          names: ["\\relax"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInArgument: true
          },
          handler(_ref) {
            let {
              parser
            } = _ref;
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        ;
        defineFunction({
          type: "rule",
          names: ["\\rule"],
          props: {
            numArgs: 2,
            numOptionalArgs: 1,
            allowedInText: true,
            allowedInMath: true,
            argTypes: ["size", "size", "size"]
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const shift = optArgs[0];
            const width = assertNodeType(args[0], "size");
            const height = assertNodeType(args[1], "size");
            return {
              type: "rule",
              mode: parser.mode,
              shift: shift && assertNodeType(shift, "size").value,
              width: width.value,
              height: height.value
            };
          },
          htmlBuilder(group, options) {
            const rule = buildCommon.makeSpan(["mord", "rule"], [], options);
            const width = calculateSize(group.width, options);
            const height = calculateSize(group.height, options);
            const shift = group.shift ? calculateSize(group.shift, options) : 0;
            rule.style.borderRightWidth = makeEm(width);
            rule.style.borderTopWidth = makeEm(height);
            rule.style.bottom = makeEm(shift);
            rule.width = width;
            rule.height = height + shift;
            rule.depth = -shift;
            rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
            return rule;
          },
          mathmlBuilder(group, options) {
            const width = calculateSize(group.width, options);
            const height = calculateSize(group.height, options);
            const shift = group.shift ? calculateSize(group.shift, options) : 0;
            const color = options.color && options.getColor() || "black";
            const rule = new mathMLTree.MathNode("mspace");
            rule.setAttribute("mathbackground", color);
            rule.setAttribute("width", makeEm(width));
            rule.setAttribute("height", makeEm(height));
            const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
            if (shift >= 0) {
              wrapper.setAttribute("height", makeEm(shift));
            } else {
              wrapper.setAttribute("height", makeEm(shift));
              wrapper.setAttribute("depth", makeEm(-shift));
            }
            wrapper.setAttribute("voffset", makeEm(shift));
            return wrapper;
          }
        });
        ;
        function sizingGroup(value, options, baseOptions) {
          const inner2 = buildExpression(value, options, false);
          const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          for (let i = 0; i < inner2.length; i++) {
            const pos = inner2[i].classes.indexOf("sizing");
            if (pos < 0) {
              Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
            } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
              inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
            }
            inner2[i].height *= multiplier;
            inner2[i].depth *= multiplier;
          }
          return buildCommon.makeFragment(inner2);
        }
        const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
        const sizing_htmlBuilder = (group, options) => {
          const newOptions = options.havingSize(group.size);
          return sizingGroup(group.body, newOptions, options);
        };
        defineFunction({
          type: "sizing",
          names: sizeFuncs,
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              breakOnTokenText,
              funcName,
              parser
            } = _ref;
            const body = parser.parseExpression(false, breakOnTokenText);
            return {
              type: "sizing",
              mode: parser.mode,
              size: sizeFuncs.indexOf(funcName) + 1,
              body
            };
          },
          htmlBuilder: sizing_htmlBuilder,
          mathmlBuilder: (group, options) => {
            const newOptions = options.havingSize(group.size);
            const inner2 = buildMathML_buildExpression(group.body, newOptions);
            const node = new mathMLTree.MathNode("mstyle", inner2);
            node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
            return node;
          }
        });
        ;
        defineFunction({
          type: "smash",
          names: ["\\smash"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args, optArgs) => {
            let {
              parser
            } = _ref;
            let smashHeight = false;
            let smashDepth = false;
            const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
            if (tbArg) {
              let letter = "";
              for (let i = 0; i < tbArg.body.length; ++i) {
                const node = tbArg.body[i];
                letter = node.text;
                if (letter === "t") {
                  smashHeight = true;
                } else if (letter === "b") {
                  smashDepth = true;
                } else {
                  smashHeight = false;
                  smashDepth = false;
                  break;
                }
              }
            } else {
              smashHeight = true;
              smashDepth = true;
            }
            const body = args[0];
            return {
              type: "smash",
              mode: parser.mode,
              body,
              smashHeight,
              smashDepth
            };
          },
          htmlBuilder: (group, options) => {
            const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            if (!group.smashHeight && !group.smashDepth) {
              return node;
            }
            if (group.smashHeight) {
              node.height = 0;
              if (node.children) {
                for (let i = 0; i < node.children.length; i++) {
                  node.children[i].height = 0;
                }
              }
            }
            if (group.smashDepth) {
              node.depth = 0;
              if (node.children) {
                for (let i = 0; i < node.children.length; i++) {
                  node.children[i].depth = 0;
                }
              }
            }
            const smashedNode = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [smashedNode], options);
          },
          mathmlBuilder: (group, options) => {
            const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.smashHeight) {
              node.setAttribute("height", "0px");
            }
            if (group.smashDepth) {
              node.setAttribute("depth", "0px");
            }
            return node;
          }
        });
        ;
        defineFunction({
          type: "sqrt",
          names: ["\\sqrt"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const index = optArgs[0];
            const body = args[0];
            return {
              type: "sqrt",
              mode: parser.mode,
              body,
              index
            };
          },
          htmlBuilder(group, options) {
            let inner2 = buildGroup(group.body, options.havingCrampedStyle());
            if (inner2.height === 0) {
              inner2.height = options.fontMetrics().xHeight;
            }
            inner2 = buildCommon.wrapFragment(inner2, options);
            const metrics = options.fontMetrics();
            const theta = metrics.defaultRuleThickness;
            let phi = theta;
            if (options.style.id < src_Style.TEXT.id) {
              phi = options.fontMetrics().xHeight;
            }
            let lineClearance = theta + phi / 4;
            const minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
            const {
              span: img,
              ruleWidth,
              advanceWidth
            } = delimiter.sqrtImage(minDelimiterHeight, options);
            const delimDepth = img.height - ruleWidth;
            if (delimDepth > inner2.height + inner2.depth + lineClearance) {
              lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
            }
            const imgShift = img.height - inner2.height - lineClearance - ruleWidth;
            inner2.style.paddingLeft = makeEm(advanceWidth);
            const body = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: inner2,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: -(inner2.height + imgShift)
              }, {
                type: "elem",
                elem: img
              }, {
                type: "kern",
                size: ruleWidth
              }]
            }, options);
            if (!group.index) {
              return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
            } else {
              const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
              const rootm = buildGroup(group.index, newOptions, options);
              const toShift = 0.6 * (body.height - body.depth);
              const rootVList = buildCommon.makeVList({
                positionType: "shift",
                positionData: -toShift,
                children: [{
                  type: "elem",
                  elem: rootm
                }]
              }, options);
              const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
              return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
            }
          },
          mathmlBuilder(group, options) {
            const {
              body,
              index
            } = group;
            return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
          }
        });
        ;
        const styling_styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        defineFunction({
          type: "styling",
          names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref, args) {
            let {
              breakOnTokenText,
              funcName,
              parser
            } = _ref;
            const body = parser.parseExpression(true, breakOnTokenText);
            const style = funcName.slice(1, funcName.length - 5);
            return {
              type: "styling",
              mode: parser.mode,
              style,
              body
            };
          },
          htmlBuilder(group, options) {
            const newStyle = styling_styleMap[group.style];
            const newOptions = options.havingStyle(newStyle).withFont("");
            return sizingGroup(group.body, newOptions, options);
          },
          mathmlBuilder(group, options) {
            const newStyle = styling_styleMap[group.style];
            const newOptions = options.havingStyle(newStyle);
            const inner2 = buildMathML_buildExpression(group.body, newOptions);
            const node = new mathMLTree.MathNode("mstyle", inner2);
            const styleAttributes = {
              "display": ["0", "true"],
              "text": ["0", "false"],
              "script": ["1", "false"],
              "scriptscript": ["2", "false"]
            };
            const attr = styleAttributes[group.style];
            node.setAttribute("scriptlevel", attr[0]);
            node.setAttribute("displaystyle", attr[1]);
            return node;
          }
        });
        ;
        const htmlBuilderDelegate = function(group, options) {
          const base = group.base;
          if (!base) {
            return null;
          } else if (base.type === "op") {
            const delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
            return delegate ? op_htmlBuilder : null;
          } else if (base.type === "operatorname") {
            const delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);
            return delegate ? operatorname_htmlBuilder : null;
          } else if (base.type === "accent") {
            return utils.isCharacterBox(base.base) ? htmlBuilder : null;
          } else if (base.type === "horizBrace") {
            const isSup = !group.sub;
            return isSup === base.isOver ? horizBrace_htmlBuilder : null;
          } else {
            return null;
          }
        };
        defineFunctionBuilders({
          type: "supsub",
          htmlBuilder(group, options) {
            const builderDelegate = htmlBuilderDelegate(group, options);
            if (builderDelegate) {
              return builderDelegate(group, options);
            }
            const {
              base: valueBase,
              sup: valueSup,
              sub: valueSub
            } = group;
            const base = buildGroup(valueBase, options);
            let supm;
            let subm;
            const metrics = options.fontMetrics();
            let supShift = 0;
            let subShift = 0;
            const isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
            if (valueSup) {
              const newOptions = options.havingStyle(options.style.sup());
              supm = buildGroup(valueSup, newOptions, options);
              if (!isCharacterBox2) {
                supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            if (valueSub) {
              const newOptions = options.havingStyle(options.style.sub());
              subm = buildGroup(valueSub, newOptions, options);
              if (!isCharacterBox2) {
                subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            let minSupShift;
            if (options.style === src_Style.DISPLAY) {
              minSupShift = metrics.sup1;
            } else if (options.style.cramped) {
              minSupShift = metrics.sup3;
            } else {
              minSupShift = metrics.sup2;
            }
            const multiplier = options.sizeMultiplier;
            const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
            let marginLeft = null;
            if (subm) {
              const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
              if (base instanceof SymbolNode || isOiint) {
                marginLeft = makeEm(-base.italic);
              }
            }
            let supsub;
            if (supm && subm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              subShift = Math.max(subShift, metrics.sub2);
              const ruleWidth = metrics.defaultRuleThickness;
              const maxWidth = 4 * ruleWidth;
              if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                subShift = maxWidth - (supShift - supm.depth) + subm.height;
                const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                if (psi > 0) {
                  supShift += psi;
                  subShift -= psi;
                }
              }
              const vlistElem = [{
                type: "elem",
                elem: subm,
                shift: subShift,
                marginRight,
                marginLeft
              }, {
                type: "elem",
                elem: supm,
                shift: -supShift,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "individualShift",
                children: vlistElem
              }, options);
            } else if (subm) {
              subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
              const vlistElem = [{
                type: "elem",
                elem: subm,
                marginLeft,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: subShift,
                children: vlistElem
              }, options);
            } else if (supm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: -supShift,
                children: [{
                  type: "elem",
                  elem: supm,
                  marginRight
                }]
              }, options);
            } else {
              throw new Error("supsub must have either sup or sub.");
            }
            const mclass = getTypeOfDomTree(base, "right") || "mord";
            return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
          },
          mathmlBuilder(group, options) {
            let isBrace = false;
            let isOver;
            let isSup;
            if (group.base && group.base.type === "horizBrace") {
              isSup = !!group.sup;
              if (isSup === group.base.isOver) {
                isBrace = true;
                isOver = group.base.isOver;
              }
            }
            if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
              group.base.parentIsSupSub = true;
            }
            const children = [buildMathML_buildGroup(group.base, options)];
            if (group.sub) {
              children.push(buildMathML_buildGroup(group.sub, options));
            }
            if (group.sup) {
              children.push(buildMathML_buildGroup(group.sup, options));
            }
            let nodeType;
            if (isBrace) {
              nodeType = isOver ? "mover" : "munder";
            } else if (!group.sub) {
              const base = group.base;
              if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
                nodeType = "mover";
              } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "mover";
              } else {
                nodeType = "msup";
              }
            } else if (!group.sup) {
              const base = group.base;
              if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
                nodeType = "munder";
              } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "munder";
              } else {
                nodeType = "msub";
              }
            } else {
              const base = group.base;
              if (base && base.type === "op" && base.limits && options.style === src_Style.DISPLAY) {
                nodeType = "munderover";
              } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base.limits)) {
                nodeType = "munderover";
              } else {
                nodeType = "msubsup";
              }
            }
            return new mathMLTree.MathNode(nodeType, children);
          }
        });
        ;
        defineFunctionBuilders({
          type: "atom",
          htmlBuilder(group, options) {
            return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
          },
          mathmlBuilder(group, options) {
            const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
            if (group.family === "bin") {
              const variant = getVariant(group, options);
              if (variant === "bold-italic") {
                node.setAttribute("mathvariant", variant);
              }
            } else if (group.family === "punct") {
              node.setAttribute("separator", "true");
            } else if (group.family === "open" || group.family === "close") {
              node.setAttribute("stretchy", "false");
            }
            return node;
          }
        });
        ;
        const defaultVariant = {
          "mi": "italic",
          "mn": "normal",
          "mtext": "normal"
        };
        defineFunctionBuilders({
          type: "mathord",
          htmlBuilder(group, options) {
            return buildCommon.makeOrd(group, options, "mathord");
          },
          mathmlBuilder(group, options) {
            const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
            const variant = getVariant(group, options) || "italic";
            if (variant !== defaultVariant[node.type]) {
              node.setAttribute("mathvariant", variant);
            }
            return node;
          }
        });
        defineFunctionBuilders({
          type: "textord",
          htmlBuilder(group, options) {
            return buildCommon.makeOrd(group, options, "textord");
          },
          mathmlBuilder(group, options) {
            const text = makeText(group.text, group.mode, options);
            const variant = getVariant(group, options) || "normal";
            let node;
            if (group.mode === "text") {
              node = new mathMLTree.MathNode("mtext", [text]);
            } else if (/[0-9]/.test(group.text)) {
              node = new mathMLTree.MathNode("mn", [text]);
            } else if (group.text === "\\prime") {
              node = new mathMLTree.MathNode("mo", [text]);
            } else {
              node = new mathMLTree.MathNode("mi", [text]);
            }
            if (variant !== defaultVariant[node.type]) {
              node.setAttribute("mathvariant", variant);
            }
            return node;
          }
        });
        ;
        const cssSpace = {
          "\\nobreak": "nobreak",
          "\\allowbreak": "allowbreak"
        };
        const regularSpace = {
          " ": {},
          "\\ ": {},
          "~": {
            className: "nobreak"
          },
          "\\space": {},
          "\\nobreakspace": {
            className: "nobreak"
          }
        };
        defineFunctionBuilders({
          type: "spacing",
          htmlBuilder(group, options) {
            if (regularSpace.hasOwnProperty(group.text)) {
              const className = regularSpace[group.text].className || "";
              if (group.mode === "text") {
                const ord = buildCommon.makeOrd(group, options, "textord");
                ord.classes.push(className);
                return ord;
              } else {
                return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
              }
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
          },
          mathmlBuilder(group, options) {
            let node;
            if (regularSpace.hasOwnProperty(group.text)) {
              node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return new mathMLTree.MathNode("mspace");
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
            return node;
          }
        });
        ;
        const pad = () => {
          const padNode = new mathMLTree.MathNode("mtd", []);
          padNode.setAttribute("width", "50%");
          return padNode;
        };
        defineFunctionBuilders({
          type: "tag",
          mathmlBuilder(group, options) {
            const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
            table.setAttribute("width", "100%");
            return table;
          }
        });
        ;
        const textFontFamilies = {
          "\\text": void 0,
          "\\textrm": "textrm",
          "\\textsf": "textsf",
          "\\texttt": "texttt",
          "\\textnormal": "textrm"
        };
        const textFontWeights = {
          "\\textbf": "textbf",
          "\\textmd": "textmd"
        };
        const textFontShapes = {
          "\\textit": "textit",
          "\\textup": "textup"
        };
        const optionsWithFont = (group, options) => {
          const font = group.font;
          if (!font) {
            return options;
          } else if (textFontFamilies[font]) {
            return options.withTextFontFamily(textFontFamilies[font]);
          } else if (textFontWeights[font]) {
            return options.withTextFontWeight(textFontWeights[font]);
          } else if (font === "\\emph") {
            return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
          }
          return options.withTextFontShape(textFontShapes[font]);
        };
        defineFunction({
          type: "text",
          names: [
            "\\text",
            "\\textrm",
            "\\textsf",
            "\\texttt",
            "\\textnormal",
            "\\textbf",
            "\\textmd",
            "\\textit",
            "\\textup",
            "\\emph"
          ],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInArgument: true,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "text",
              mode: parser.mode,
              body: ordargument(body),
              font: funcName
            };
          },
          htmlBuilder(group, options) {
            const newOptions = optionsWithFont(group, options);
            const inner2 = buildExpression(group.body, newOptions, true);
            return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
          },
          mathmlBuilder(group, options) {
            const newOptions = optionsWithFont(group, options);
            return buildExpressionRow(group.body, newOptions);
          }
        });
        ;
        defineFunction({
          type: "underline",
          names: ["\\underline"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "underline",
              mode: parser.mode,
              body: args[0]
            };
          },
          htmlBuilder(group, options) {
            const innerGroup = buildGroup(group.body, options);
            const line = buildCommon.makeLineSpan("underline-line", options);
            const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            const vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "kern",
                size: defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
            operator.setAttribute("stretchy", "true");
            const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
            node.setAttribute("accentunder", "true");
            return node;
          }
        });
        ;
        defineFunction({
          type: "vcenter",
          names: ["\\vcenter"],
          props: {
            numArgs: 1,
            argTypes: ["original"],
            allowedInText: false
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "vcenter",
              mode: parser.mode,
              body: args[0]
            };
          },
          htmlBuilder(group, options) {
            const body = buildGroup(group.body, options);
            const axisHeight = options.fontMetrics().axisHeight;
            const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
          }
        });
        ;
        defineFunction({
          type: "verb",
          names: ["\\verb"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler(context, args, optArgs) {
            throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
          },
          htmlBuilder(group, options) {
            const text = makeVerb(group);
            const body = [];
            const newOptions = options.havingStyle(options.style.text());
            for (let i = 0; i < text.length; i++) {
              let c = text[i];
              if (c === "~") {
                c = "\\textasciitilde";
              }
              body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
            }
            return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
          },
          mathmlBuilder(group, options) {
            const text = new mathMLTree.TextNode(makeVerb(group));
            const node = new mathMLTree.MathNode("mtext", [text]);
            node.setAttribute("mathvariant", "monospace");
            return node;
          }
        });
        const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
        ;
        const functions = _functions;
        var src_functions = functions;
        ;
        const spaceRegexString = "[ \r\n	]";
        const controlWordRegexString = "\\\\[a-zA-Z@]+";
        const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
        const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
        const controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
        const combiningDiacriticalMarkString = "[\u0300-\u036F]";
        const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
        const tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
        class Lexer {
          constructor(input, settings) {
            this.input = void 0;
            this.settings = void 0;
            this.tokenRegex = void 0;
            this.catcodes = void 0;
            this.input = input;
            this.settings = settings;
            this.tokenRegex = new RegExp(tokenRegexString, "g");
            this.catcodes = {
              "%": 14,
              "~": 13
            };
          }
          setCatcode(char, code) {
            this.catcodes[char] = code;
          }
          lex() {
            const input = this.input;
            const pos = this.tokenRegex.lastIndex;
            if (pos === input.length) {
              return new Token2("EOF", new SourceLocation(this, pos, pos));
            }
            const match = this.tokenRegex.exec(input);
            if (match === null || match.index !== pos) {
              throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation(this, pos, pos + 1)));
            }
            const text = match[6] || match[3] || (match[2] ? "\\ " : " ");
            if (this.catcodes[text] === 14) {
              const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
              if (nlIndex === -1) {
                this.tokenRegex.lastIndex = input.length;
                this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
              } else {
                this.tokenRegex.lastIndex = nlIndex + 1;
              }
              return this.lex();
            }
            return new Token2(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
          }
        }
        ;
        class Namespace {
          constructor(builtins, globalMacros) {
            if (builtins === void 0) {
              builtins = {};
            }
            if (globalMacros === void 0) {
              globalMacros = {};
            }
            this.current = void 0;
            this.builtins = void 0;
            this.undefStack = void 0;
            this.current = globalMacros;
            this.builtins = builtins;
            this.undefStack = [];
          }
          beginGroup() {
            this.undefStack.push({});
          }
          endGroup() {
            if (this.undefStack.length === 0) {
              throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
            }
            const undefs = this.undefStack.pop();
            for (const undef in undefs) {
              if (undefs.hasOwnProperty(undef)) {
                if (undefs[undef] == null) {
                  delete this.current[undef];
                } else {
                  this.current[undef] = undefs[undef];
                }
              }
            }
          }
          endGroups() {
            while (this.undefStack.length > 0) {
              this.endGroup();
            }
          }
          has(name) {
            return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
          }
          get(name) {
            if (this.current.hasOwnProperty(name)) {
              return this.current[name];
            } else {
              return this.builtins[name];
            }
          }
          set(name, value, global2) {
            if (global2 === void 0) {
              global2 = false;
            }
            if (global2) {
              for (let i = 0; i < this.undefStack.length; i++) {
                delete this.undefStack[i][name];
              }
              if (this.undefStack.length > 0) {
                this.undefStack[this.undefStack.length - 1][name] = value;
              }
            } else {
              const top = this.undefStack[this.undefStack.length - 1];
              if (top && !top.hasOwnProperty(name)) {
                top[name] = this.current[name];
              }
            }
            if (value == null) {
              delete this.current[name];
            } else {
              this.current[name] = value;
            }
          }
        }
        ;
        const macros = _macros;
        var src_macros = macros;
        defineMacro("\\noexpand", function(context) {
          const t2 = context.popToken();
          if (context.isExpandable(t2.text)) {
            t2.noexpand = true;
            t2.treatAsRelax = true;
          }
          return {
            tokens: [t2],
            numArgs: 0
          };
        });
        defineMacro("\\expandafter", function(context) {
          const t2 = context.popToken();
          context.expandOnce(true);
          return {
            tokens: [t2],
            numArgs: 0
          };
        });
        defineMacro("\\@firstoftwo", function(context) {
          const args = context.consumeArgs(2);
          return {
            tokens: args[0],
            numArgs: 0
          };
        });
        defineMacro("\\@secondoftwo", function(context) {
          const args = context.consumeArgs(2);
          return {
            tokens: args[1],
            numArgs: 0
          };
        });
        defineMacro("\\@ifnextchar", function(context) {
          const args = context.consumeArgs(3);
          context.consumeSpaces();
          const nextToken = context.future();
          if (args[0].length === 1 && args[0][0].text === nextToken.text) {
            return {
              tokens: args[1],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[2],
              numArgs: 0
            };
          }
        });
        defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
        defineMacro("\\TextOrMath", function(context) {
          const args = context.consumeArgs(2);
          if (context.mode === "text") {
            return {
              tokens: args[0],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[1],
              numArgs: 0
            };
          }
        });
        const digitToNumber = {
          "0": 0,
          "1": 1,
          "2": 2,
          "3": 3,
          "4": 4,
          "5": 5,
          "6": 6,
          "7": 7,
          "8": 8,
          "9": 9,
          "a": 10,
          "A": 10,
          "b": 11,
          "B": 11,
          "c": 12,
          "C": 12,
          "d": 13,
          "D": 13,
          "e": 14,
          "E": 14,
          "f": 15,
          "F": 15
        };
        defineMacro("\\char", function(context) {
          let token = context.popToken();
          let base;
          let number = "";
          if (token.text === "'") {
            base = 8;
            token = context.popToken();
          } else if (token.text === '"') {
            base = 16;
            token = context.popToken();
          } else if (token.text === "`") {
            token = context.popToken();
            if (token.text[0] === "\\") {
              number = token.text.charCodeAt(1);
            } else if (token.text === "EOF") {
              throw new src_ParseError("\\char` missing argument");
            } else {
              number = token.text.charCodeAt(0);
            }
          } else {
            base = 10;
          }
          if (base) {
            number = digitToNumber[token.text];
            if (number == null || number >= base) {
              throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
            }
            let digit;
            while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
              number *= base;
              number += digit;
              context.popToken();
            }
          }
          return "\\@char{" + number + "}";
        });
        const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
          let arg = context.consumeArg().tokens;
          if (arg.length !== 1) {
            throw new src_ParseError("\\newcommand's first argument must be a macro name");
          }
          const name = arg[0].text;
          const exists = context.isDefined(name);
          if (exists && !existsOK) {
            throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
          }
          if (!exists && !nonexistsOK) {
            throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
          }
          let numArgs = 0;
          arg = context.consumeArg().tokens;
          if (arg.length === 1 && arg[0].text === "[") {
            let argText = "";
            let token = context.expandNextToken();
            while (token.text !== "]" && token.text !== "EOF") {
              argText += token.text;
              token = context.expandNextToken();
            }
            if (!argText.match(/^\s*[0-9]+\s*$/)) {
              throw new src_ParseError("Invalid number of arguments: " + argText);
            }
            numArgs = parseInt(argText);
            arg = context.consumeArg().tokens;
          }
          if (!(exists && skipIfExists)) {
            context.macros.set(name, {
              tokens: arg,
              numArgs
            });
          }
          return "";
        };
        defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
        defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
        defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
        defineMacro("\\message", (context) => {
          const arg = context.consumeArgs(1)[0];
          console.log(arg.reverse().map((token) => token.text).join(""));
          return "";
        });
        defineMacro("\\errmessage", (context) => {
          const arg = context.consumeArgs(1)[0];
          console.error(arg.reverse().map((token) => token.text).join(""));
          return "";
        });
        defineMacro("\\show", (context) => {
          const tok = context.popToken();
          const name = tok.text;
          console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
          return "";
        });
        defineMacro("\\bgroup", "{");
        defineMacro("\\egroup", "}");
        defineMacro("~", "\\nobreakspace");
        defineMacro("\\lq", "`");
        defineMacro("\\rq", "'");
        defineMacro("\\aa", "\\r a");
        defineMacro("\\AA", "\\r A");
        defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
        defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
        defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
        defineMacro("\u212C", "\\mathscr{B}");
        defineMacro("\u2130", "\\mathscr{E}");
        defineMacro("\u2131", "\\mathscr{F}");
        defineMacro("\u210B", "\\mathscr{H}");
        defineMacro("\u2110", "\\mathscr{I}");
        defineMacro("\u2112", "\\mathscr{L}");
        defineMacro("\u2133", "\\mathscr{M}");
        defineMacro("\u211B", "\\mathscr{R}");
        defineMacro("\u212D", "\\mathfrak{C}");
        defineMacro("\u210C", "\\mathfrak{H}");
        defineMacro("\u2128", "\\mathfrak{Z}");
        defineMacro("\\Bbbk", "\\Bbb{k}");
        defineMacro("\xB7", "\\cdotp");
        defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
        defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
        defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
        defineMacro("\\mathstrut", "\\vphantom{(}");
        defineMacro("\\underbar", "\\underline{\\text{#1}}");
        defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
        defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
        defineMacro("\\ne", "\\neq");
        defineMacro("\u2260", "\\neq");
        defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
        defineMacro("\u2209", "\\notin");
        defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
        defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
        defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
        defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
        defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
        defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
        defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
        defineMacro("\u27C2", "\\perp");
        defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
        defineMacro("\u220C", "\\notni");
        defineMacro("\u231C", "\\ulcorner");
        defineMacro("\u231D", "\\urcorner");
        defineMacro("\u231E", "\\llcorner");
        defineMacro("\u231F", "\\lrcorner");
        defineMacro("\xA9", "\\copyright");
        defineMacro("\xAE", "\\textregistered");
        defineMacro("\uFE0F", "\\textregistered");
        defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
        defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
        defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
        defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
        defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
        defineMacro("\u22EE", "\\vdots");
        defineMacro("\\varGamma", "\\mathit{\\Gamma}");
        defineMacro("\\varDelta", "\\mathit{\\Delta}");
        defineMacro("\\varTheta", "\\mathit{\\Theta}");
        defineMacro("\\varLambda", "\\mathit{\\Lambda}");
        defineMacro("\\varXi", "\\mathit{\\Xi}");
        defineMacro("\\varPi", "\\mathit{\\Pi}");
        defineMacro("\\varSigma", "\\mathit{\\Sigma}");
        defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
        defineMacro("\\varPhi", "\\mathit{\\Phi}");
        defineMacro("\\varPsi", "\\mathit{\\Psi}");
        defineMacro("\\varOmega", "\\mathit{\\Omega}");
        defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
        defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
        defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
        defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
        defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
        defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
        defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
        defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
        const dotsByToken = {
          ",": "\\dotsc",
          "\\not": "\\dotsb",
          "+": "\\dotsb",
          "=": "\\dotsb",
          "<": "\\dotsb",
          ">": "\\dotsb",
          "-": "\\dotsb",
          "*": "\\dotsb",
          ":": "\\dotsb",
          "\\DOTSB": "\\dotsb",
          "\\coprod": "\\dotsb",
          "\\bigvee": "\\dotsb",
          "\\bigwedge": "\\dotsb",
          "\\biguplus": "\\dotsb",
          "\\bigcap": "\\dotsb",
          "\\bigcup": "\\dotsb",
          "\\prod": "\\dotsb",
          "\\sum": "\\dotsb",
          "\\bigotimes": "\\dotsb",
          "\\bigoplus": "\\dotsb",
          "\\bigodot": "\\dotsb",
          "\\bigsqcup": "\\dotsb",
          "\\And": "\\dotsb",
          "\\longrightarrow": "\\dotsb",
          "\\Longrightarrow": "\\dotsb",
          "\\longleftarrow": "\\dotsb",
          "\\Longleftarrow": "\\dotsb",
          "\\longleftrightarrow": "\\dotsb",
          "\\Longleftrightarrow": "\\dotsb",
          "\\mapsto": "\\dotsb",
          "\\longmapsto": "\\dotsb",
          "\\hookrightarrow": "\\dotsb",
          "\\doteq": "\\dotsb",
          "\\mathbin": "\\dotsb",
          "\\mathrel": "\\dotsb",
          "\\relbar": "\\dotsb",
          "\\Relbar": "\\dotsb",
          "\\xrightarrow": "\\dotsb",
          "\\xleftarrow": "\\dotsb",
          "\\DOTSI": "\\dotsi",
          "\\int": "\\dotsi",
          "\\oint": "\\dotsi",
          "\\iint": "\\dotsi",
          "\\iiint": "\\dotsi",
          "\\iiiint": "\\dotsi",
          "\\idotsint": "\\dotsi",
          "\\DOTSX": "\\dotsx"
        };
        defineMacro("\\dots", function(context) {
          let thedots = "\\dotso";
          const next = context.expandAfterFuture().text;
          if (next in dotsByToken) {
            thedots = dotsByToken[next];
          } else if (next.slice(0, 4) === "\\not") {
            thedots = "\\dotsb";
          } else if (next in src_symbols.math) {
            if (["bin", "rel"].includes(src_symbols.math[next].group)) {
              thedots = "\\dotsb";
            }
          }
          return thedots;
        });
        const spaceAfterDots = {
          ")": true,
          "]": true,
          "\\rbrack": true,
          "\\}": true,
          "\\rbrace": true,
          "\\rangle": true,
          "\\rceil": true,
          "\\rfloor": true,
          "\\rgroup": true,
          "\\rmoustache": true,
          "\\right": true,
          "\\bigr": true,
          "\\biggr": true,
          "\\Bigr": true,
          "\\Biggr": true,
          "$": true,
          ";": true,
          ".": true,
          ",": true
        };
        defineMacro("\\dotso", function(context) {
          const next = context.future().text;
          if (next in spaceAfterDots) {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\dotsc", function(context) {
          const next = context.future().text;
          if (next in spaceAfterDots && next !== ",") {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\cdots", function(context) {
          const next = context.future().text;
          if (next in spaceAfterDots) {
            return "\\@cdots\\,";
          } else {
            return "\\@cdots";
          }
        });
        defineMacro("\\dotsb", "\\cdots");
        defineMacro("\\dotsm", "\\cdots");
        defineMacro("\\dotsi", "\\!\\cdots");
        defineMacro("\\dotsx", "\\ldots\\,");
        defineMacro("\\DOTSI", "\\relax");
        defineMacro("\\DOTSB", "\\relax");
        defineMacro("\\DOTSX", "\\relax");
        defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
        defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
        defineMacro("\\thinspace", "\\,");
        defineMacro("\\>", "\\mskip{4mu}");
        defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
        defineMacro("\\medspace", "\\:");
        defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
        defineMacro("\\thickspace", "\\;");
        defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
        defineMacro("\\negthinspace", "\\!");
        defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
        defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
        defineMacro("\\enspace", "\\kern.5em ");
        defineMacro("\\enskip", "\\hskip.5em\\relax");
        defineMacro("\\quad", "\\hskip1em\\relax");
        defineMacro("\\qquad", "\\hskip2em\\relax");
        defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
        defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
        defineMacro("\\tag@literal", (context) => {
          if (context.macros.get("\\df@tag")) {
            throw new src_ParseError("Multiple \\tag");
          }
          return "\\gdef\\df@tag{\\text{#1}}";
        });
        defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
        defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
        defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
        defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
        defineMacro("\\newline", "\\\\\\relax");
        defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
        const latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
        defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
        defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
        defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
        defineMacro("\\@hspace", "\\hskip #1\\relax");
        defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
        defineMacro("\\ordinarycolon", ":");
        defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
        defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
        defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
        defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
        defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
        defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
        defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
        defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
        defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
        defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
        defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
        defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
        defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
        defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
        defineMacro("\u2237", "\\dblcolon");
        defineMacro("\u2239", "\\eqcolon");
        defineMacro("\u2254", "\\coloneqq");
        defineMacro("\u2255", "\\eqqcolon");
        defineMacro("\u2A74", "\\Coloneqq");
        defineMacro("\\ratio", "\\vcentcolon");
        defineMacro("\\coloncolon", "\\dblcolon");
        defineMacro("\\colonequals", "\\coloneqq");
        defineMacro("\\coloncolonequals", "\\Coloneqq");
        defineMacro("\\equalscolon", "\\eqqcolon");
        defineMacro("\\equalscoloncolon", "\\Eqqcolon");
        defineMacro("\\colonminus", "\\coloneq");
        defineMacro("\\coloncolonminus", "\\Coloneq");
        defineMacro("\\minuscolon", "\\eqcolon");
        defineMacro("\\minuscoloncolon", "\\Eqcolon");
        defineMacro("\\coloncolonapprox", "\\Colonapprox");
        defineMacro("\\coloncolonsim", "\\Colonsim");
        defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
        defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
        defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
        defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
        defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
        defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
        defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
        defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
        defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
        defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
        defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
        defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
        defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
        defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
        defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
        defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
        defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
        defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
        defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
        defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
        defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
        defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
        defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
        defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
        defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
        defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
        defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
        defineMacro("\u27E6", "\\llbracket");
        defineMacro("\u27E7", "\\rrbracket");
        defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
        defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
        defineMacro("\u2983", "\\lBrace");
        defineMacro("\u2984", "\\rBrace");
        defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
        defineMacro("\u29B5", "\\minuso");
        defineMacro("\\darr", "\\downarrow");
        defineMacro("\\dArr", "\\Downarrow");
        defineMacro("\\Darr", "\\Downarrow");
        defineMacro("\\lang", "\\langle");
        defineMacro("\\rang", "\\rangle");
        defineMacro("\\uarr", "\\uparrow");
        defineMacro("\\uArr", "\\Uparrow");
        defineMacro("\\Uarr", "\\Uparrow");
        defineMacro("\\N", "\\mathbb{N}");
        defineMacro("\\R", "\\mathbb{R}");
        defineMacro("\\Z", "\\mathbb{Z}");
        defineMacro("\\alef", "\\aleph");
        defineMacro("\\alefsym", "\\aleph");
        defineMacro("\\Alpha", "\\mathrm{A}");
        defineMacro("\\Beta", "\\mathrm{B}");
        defineMacro("\\bull", "\\bullet");
        defineMacro("\\Chi", "\\mathrm{X}");
        defineMacro("\\clubs", "\\clubsuit");
        defineMacro("\\cnums", "\\mathbb{C}");
        defineMacro("\\Complex", "\\mathbb{C}");
        defineMacro("\\Dagger", "\\ddagger");
        defineMacro("\\diamonds", "\\diamondsuit");
        defineMacro("\\empty", "\\emptyset");
        defineMacro("\\Epsilon", "\\mathrm{E}");
        defineMacro("\\Eta", "\\mathrm{H}");
        defineMacro("\\exist", "\\exists");
        defineMacro("\\harr", "\\leftrightarrow");
        defineMacro("\\hArr", "\\Leftrightarrow");
        defineMacro("\\Harr", "\\Leftrightarrow");
        defineMacro("\\hearts", "\\heartsuit");
        defineMacro("\\image", "\\Im");
        defineMacro("\\infin", "\\infty");
        defineMacro("\\Iota", "\\mathrm{I}");
        defineMacro("\\isin", "\\in");
        defineMacro("\\Kappa", "\\mathrm{K}");
        defineMacro("\\larr", "\\leftarrow");
        defineMacro("\\lArr", "\\Leftarrow");
        defineMacro("\\Larr", "\\Leftarrow");
        defineMacro("\\lrarr", "\\leftrightarrow");
        defineMacro("\\lrArr", "\\Leftrightarrow");
        defineMacro("\\Lrarr", "\\Leftrightarrow");
        defineMacro("\\Mu", "\\mathrm{M}");
        defineMacro("\\natnums", "\\mathbb{N}");
        defineMacro("\\Nu", "\\mathrm{N}");
        defineMacro("\\Omicron", "\\mathrm{O}");
        defineMacro("\\plusmn", "\\pm");
        defineMacro("\\rarr", "\\rightarrow");
        defineMacro("\\rArr", "\\Rightarrow");
        defineMacro("\\Rarr", "\\Rightarrow");
        defineMacro("\\real", "\\Re");
        defineMacro("\\reals", "\\mathbb{R}");
        defineMacro("\\Reals", "\\mathbb{R}");
        defineMacro("\\Rho", "\\mathrm{P}");
        defineMacro("\\sdot", "\\cdot");
        defineMacro("\\sect", "\\S");
        defineMacro("\\spades", "\\spadesuit");
        defineMacro("\\sub", "\\subset");
        defineMacro("\\sube", "\\subseteq");
        defineMacro("\\supe", "\\supseteq");
        defineMacro("\\Tau", "\\mathrm{T}");
        defineMacro("\\thetasym", "\\vartheta");
        defineMacro("\\weierp", "\\wp");
        defineMacro("\\Zeta", "\\mathrm{Z}");
        defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
        defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
        defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
        defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
        defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
        defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
        defineMacro("\\Bra", "\\left\\langle#1\\right|");
        defineMacro("\\Ket", "\\left|#1\\right\\rangle");
        const braketHelper = (one) => (context) => {
          const left = context.consumeArg().tokens;
          const middle = context.consumeArg().tokens;
          const middleDouble = context.consumeArg().tokens;
          const right = context.consumeArg().tokens;
          const oldMiddle = context.macros.get("|");
          const oldMiddleDouble = context.macros.get("\\|");
          context.macros.beginGroup();
          const midMacro = (double) => (context2) => {
            if (one) {
              context2.macros.set("|", oldMiddle);
              if (middleDouble.length) {
                context2.macros.set("\\|", oldMiddleDouble);
              }
            }
            let doubled = double;
            if (!double && middleDouble.length) {
              const nextToken = context2.future();
              if (nextToken.text === "|") {
                context2.popToken();
                doubled = true;
              }
            }
            return {
              tokens: doubled ? middleDouble : middle,
              numArgs: 0
            };
          };
          context.macros.set("|", midMacro(false));
          if (middleDouble.length) {
            context.macros.set("\\|", midMacro(true));
          }
          const arg = context.consumeArg().tokens;
          const expanded = context.expandTokens([
            ...right,
            ...arg,
            ...left
          ]);
          context.macros.endGroup();
          return {
            tokens: expanded.reverse(),
            numArgs: 0
          };
        };
        defineMacro("\\bra@ket", braketHelper(false));
        defineMacro("\\bra@set", braketHelper(true));
        defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
        defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
        defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
        defineMacro("\\angln", "{\\angl n}");
        defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
        defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
        defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
        defineMacro("\\red", "\\textcolor{##df0030}{#1}");
        defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
        defineMacro("\\gray", "\\textcolor{gray}{#1}");
        defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
        defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
        defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
        defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
        defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
        defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
        defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
        defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
        defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
        defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
        defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
        defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
        defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
        defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
        defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
        defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
        defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
        defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
        defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
        defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
        defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
        defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
        defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
        defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
        defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
        defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
        defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
        defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
        defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
        defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
        defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
        defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
        defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
        defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
        defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
        defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
        defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
        defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
        defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
        defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
        defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
        defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
        defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
        defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
        defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
        defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
        defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
        defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
        defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
        defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
        ;
        const implicitCommands = {
          "^": true,
          "_": true,
          "\\limits": true,
          "\\nolimits": true
        };
        class MacroExpander {
          constructor(input, settings, mode) {
            this.settings = void 0;
            this.expansionCount = void 0;
            this.lexer = void 0;
            this.macros = void 0;
            this.stack = void 0;
            this.mode = void 0;
            this.settings = settings;
            this.expansionCount = 0;
            this.feed(input);
            this.macros = new Namespace(src_macros, settings.macros);
            this.mode = mode;
            this.stack = [];
          }
          feed(input) {
            this.lexer = new Lexer(input, this.settings);
          }
          switchMode(newMode) {
            this.mode = newMode;
          }
          beginGroup() {
            this.macros.beginGroup();
          }
          endGroup() {
            this.macros.endGroup();
          }
          endGroups() {
            this.macros.endGroups();
          }
          future() {
            if (this.stack.length === 0) {
              this.pushToken(this.lexer.lex());
            }
            return this.stack[this.stack.length - 1];
          }
          popToken() {
            this.future();
            return this.stack.pop();
          }
          pushToken(token) {
            this.stack.push(token);
          }
          pushTokens(tokens) {
            this.stack.push(...tokens);
          }
          scanArgument(isOptional) {
            let start;
            let end;
            let tokens;
            if (isOptional) {
              this.consumeSpaces();
              if (this.future().text !== "[") {
                return null;
              }
              start = this.popToken();
              ({
                tokens,
                end
              } = this.consumeArg(["]"]));
            } else {
              ({
                tokens,
                start,
                end
              } = this.consumeArg());
            }
            this.pushToken(new Token2("EOF", end.loc));
            this.pushTokens(tokens);
            return new Token2("", SourceLocation.range(start, end));
          }
          consumeSpaces() {
            for (; ; ) {
              const token = this.future();
              if (token.text === " ") {
                this.stack.pop();
              } else {
                break;
              }
            }
          }
          consumeArg(delims) {
            const tokens = [];
            const isDelimited = delims && delims.length > 0;
            if (!isDelimited) {
              this.consumeSpaces();
            }
            const start = this.future();
            let tok;
            let depth = 0;
            let match = 0;
            do {
              tok = this.popToken();
              tokens.push(tok);
              if (tok.text === "{") {
                ++depth;
              } else if (tok.text === "}") {
                --depth;
                if (depth === -1) {
                  throw new src_ParseError("Extra }", tok);
                }
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
              }
              if (delims && isDelimited) {
                if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                  ++match;
                  if (match === delims.length) {
                    tokens.splice(-match, match);
                    break;
                  }
                } else {
                  match = 0;
                }
              }
            } while (depth !== 0 || isDelimited);
            if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
              tokens.pop();
              tokens.shift();
            }
            tokens.reverse();
            return {
              tokens,
              start,
              end: tok
            };
          }
          consumeArgs(numArgs, delimiters2) {
            if (delimiters2) {
              if (delimiters2.length !== numArgs + 1) {
                throw new src_ParseError("The length of delimiters doesn't match the number of args!");
              }
              const delims = delimiters2[0];
              for (let i = 0; i < delims.length; i++) {
                const tok = this.popToken();
                if (delims[i] !== tok.text) {
                  throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                }
              }
            }
            const args = [];
            for (let i = 0; i < numArgs; i++) {
              args.push(this.consumeArg(delimiters2 && delimiters2[i + 1]).tokens);
            }
            return args;
          }
          countExpansion(amount) {
            this.expansionCount += amount;
            if (this.expansionCount > this.settings.maxExpand) {
              throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
          }
          expandOnce(expandableOnly) {
            const topToken = this.popToken();
            const name = topToken.text;
            const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
            if (expansion == null || expandableOnly && expansion.unexpandable) {
              if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
                throw new src_ParseError("Undefined control sequence: " + name);
              }
              this.pushToken(topToken);
              return false;
            }
            this.countExpansion(1);
            let tokens = expansion.tokens;
            const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
            if (expansion.numArgs) {
              tokens = tokens.slice();
              for (let i = tokens.length - 1; i >= 0; --i) {
                let tok = tokens[i];
                if (tok.text === "#") {
                  if (i === 0) {
                    throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                  }
                  tok = tokens[--i];
                  if (tok.text === "#") {
                    tokens.splice(i + 1, 1);
                  } else if (/^[1-9]$/.test(tok.text)) {
                    tokens.splice(i, 2, ...args[+tok.text - 1]);
                  } else {
                    throw new src_ParseError("Not a valid argument number", tok);
                  }
                }
              }
            }
            this.pushTokens(tokens);
            return tokens.length;
          }
          expandAfterFuture() {
            this.expandOnce();
            return this.future();
          }
          expandNextToken() {
            for (; ; ) {
              if (this.expandOnce() === false) {
                const token = this.stack.pop();
                if (token.treatAsRelax) {
                  token.text = "\\relax";
                }
                return token;
              }
            }
            throw new Error();
          }
          expandMacro(name) {
            return this.macros.has(name) ? this.expandTokens([new Token2(name)]) : void 0;
          }
          expandTokens(tokens) {
            const output = [];
            const oldStackLength = this.stack.length;
            this.pushTokens(tokens);
            while (this.stack.length > oldStackLength) {
              if (this.expandOnce(true) === false) {
                const token = this.stack.pop();
                if (token.treatAsRelax) {
                  token.noexpand = false;
                  token.treatAsRelax = false;
                }
                output.push(token);
              }
            }
            this.countExpansion(output.length);
            return output;
          }
          expandMacroAsText(name) {
            const tokens = this.expandMacro(name);
            if (tokens) {
              return tokens.map((token) => token.text).join("");
            } else {
              return tokens;
            }
          }
          _getExpansion(name) {
            const definition = this.macros.get(name);
            if (definition == null) {
              return definition;
            }
            if (name.length === 1) {
              const catcode = this.lexer.catcodes[name];
              if (catcode != null && catcode !== 13) {
                return;
              }
            }
            const expansion = typeof definition === "function" ? definition(this) : definition;
            if (typeof expansion === "string") {
              let numArgs = 0;
              if (expansion.indexOf("#") !== -1) {
                const stripped = expansion.replace(/##/g, "");
                while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                  ++numArgs;
                }
              }
              const bodyLexer = new Lexer(expansion, this.settings);
              const tokens = [];
              let tok = bodyLexer.lex();
              while (tok.text !== "EOF") {
                tokens.push(tok);
                tok = bodyLexer.lex();
              }
              tokens.reverse();
              const expanded = {
                tokens,
                numArgs
              };
              return expanded;
            }
            return expansion;
          }
          isDefined(name) {
            return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
          }
          isExpandable(name) {
            const macro = this.macros.get(name);
            return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
          }
        }
        ;
        const unicodeSubRegEx = /^[]/;
        const uSubsAndSups = Object.freeze({
          "\u208A": "+",
          "\u208B": "-",
          "\u208C": "=",
          "\u208D": "(",
          "\u208E": ")",
          "\u2080": "0",
          "\u2081": "1",
          "\u2082": "2",
          "\u2083": "3",
          "\u2084": "4",
          "\u2085": "5",
          "\u2086": "6",
          "\u2087": "7",
          "\u2088": "8",
          "\u2089": "9",
          "\u2090": "a",
          "\u2091": "e",
          "\u2095": "h",
          "\u1D62": "i",
          "\u2C7C": "j",
          "\u2096": "k",
          "\u2097": "l",
          "\u2098": "m",
          "\u2099": "n",
          "\u2092": "o",
          "\u209A": "p",
          "\u1D63": "r",
          "\u209B": "s",
          "\u209C": "t",
          "\u1D64": "u",
          "\u1D65": "v",
          "\u2093": "x",
          "\u1D66": "\u03B2",
          "\u1D67": "\u03B3",
          "\u1D68": "\u03C1",
          "\u1D69": "\u03D5",
          "\u1D6A": "\u03C7",
          "\u207A": "+",
          "\u207B": "-",
          "\u207C": "=",
          "\u207D": "(",
          "\u207E": ")",
          "\u2070": "0",
          "\xB9": "1",
          "\xB2": "2",
          "\xB3": "3",
          "\u2074": "4",
          "\u2075": "5",
          "\u2076": "6",
          "\u2077": "7",
          "\u2078": "8",
          "\u2079": "9",
          "\u1D2C": "A",
          "\u1D2E": "B",
          "\u1D30": "D",
          "\u1D31": "E",
          "\u1D33": "G",
          "\u1D34": "H",
          "\u1D35": "I",
          "\u1D36": "J",
          "\u1D37": "K",
          "\u1D38": "L",
          "\u1D39": "M",
          "\u1D3A": "N",
          "\u1D3C": "O",
          "\u1D3E": "P",
          "\u1D3F": "R",
          "\u1D40": "T",
          "\u1D41": "U",
          "\u2C7D": "V",
          "\u1D42": "W",
          "\u1D43": "a",
          "\u1D47": "b",
          "\u1D9C": "c",
          "\u1D48": "d",
          "\u1D49": "e",
          "\u1DA0": "f",
          "\u1D4D": "g",
          "\u02B0": "h",
          "\u2071": "i",
          "\u02B2": "j",
          "\u1D4F": "k",
          "\u02E1": "l",
          "\u1D50": "m",
          "\u207F": "n",
          "\u1D52": "o",
          "\u1D56": "p",
          "\u02B3": "r",
          "\u02E2": "s",
          "\u1D57": "t",
          "\u1D58": "u",
          "\u1D5B": "v",
          "\u02B7": "w",
          "\u02E3": "x",
          "\u02B8": "y",
          "\u1DBB": "z",
          "\u1D5D": "\u03B2",
          "\u1D5E": "\u03B3",
          "\u1D5F": "\u03B4",
          "\u1D60": "\u03D5",
          "\u1D61": "\u03C7",
          "\u1DBF": "\u03B8"
        });
        ;
        const unicodeAccents = {
          "\u0301": {
            "text": "\\'",
            "math": "\\acute"
          },
          "\u0300": {
            "text": "\\`",
            "math": "\\grave"
          },
          "\u0308": {
            "text": '\\"',
            "math": "\\ddot"
          },
          "\u0303": {
            "text": "\\~",
            "math": "\\tilde"
          },
          "\u0304": {
            "text": "\\=",
            "math": "\\bar"
          },
          "\u0306": {
            "text": "\\u",
            "math": "\\breve"
          },
          "\u030C": {
            "text": "\\v",
            "math": "\\check"
          },
          "\u0302": {
            "text": "\\^",
            "math": "\\hat"
          },
          "\u0307": {
            "text": "\\.",
            "math": "\\dot"
          },
          "\u030A": {
            "text": "\\r",
            "math": "\\mathring"
          },
          "\u030B": {
            "text": "\\H"
          },
          "\u0327": {
            "text": "\\c"
          }
        };
        const unicodeSymbols = {
          "\xE1": "a\u0301",
          "\xE0": "a\u0300",
          "\xE4": "a\u0308",
          "\u01DF": "a\u0308\u0304",
          "\xE3": "a\u0303",
          "\u0101": "a\u0304",
          "\u0103": "a\u0306",
          "\u1EAF": "a\u0306\u0301",
          "\u1EB1": "a\u0306\u0300",
          "\u1EB5": "a\u0306\u0303",
          "\u01CE": "a\u030C",
          "\xE2": "a\u0302",
          "\u1EA5": "a\u0302\u0301",
          "\u1EA7": "a\u0302\u0300",
          "\u1EAB": "a\u0302\u0303",
          "\u0227": "a\u0307",
          "\u01E1": "a\u0307\u0304",
          "\xE5": "a\u030A",
          "\u01FB": "a\u030A\u0301",
          "\u1E03": "b\u0307",
          "\u0107": "c\u0301",
          "\u1E09": "c\u0327\u0301",
          "\u010D": "c\u030C",
          "\u0109": "c\u0302",
          "\u010B": "c\u0307",
          "\xE7": "c\u0327",
          "\u010F": "d\u030C",
          "\u1E0B": "d\u0307",
          "\u1E11": "d\u0327",
          "\xE9": "e\u0301",
          "\xE8": "e\u0300",
          "\xEB": "e\u0308",
          "\u1EBD": "e\u0303",
          "\u0113": "e\u0304",
          "\u1E17": "e\u0304\u0301",
          "\u1E15": "e\u0304\u0300",
          "\u0115": "e\u0306",
          "\u1E1D": "e\u0327\u0306",
          "\u011B": "e\u030C",
          "\xEA": "e\u0302",
          "\u1EBF": "e\u0302\u0301",
          "\u1EC1": "e\u0302\u0300",
          "\u1EC5": "e\u0302\u0303",
          "\u0117": "e\u0307",
          "\u0229": "e\u0327",
          "\u1E1F": "f\u0307",
          "\u01F5": "g\u0301",
          "\u1E21": "g\u0304",
          "\u011F": "g\u0306",
          "\u01E7": "g\u030C",
          "\u011D": "g\u0302",
          "\u0121": "g\u0307",
          "\u0123": "g\u0327",
          "\u1E27": "h\u0308",
          "\u021F": "h\u030C",
          "\u0125": "h\u0302",
          "\u1E23": "h\u0307",
          "\u1E29": "h\u0327",
          "\xED": "i\u0301",
          "\xEC": "i\u0300",
          "\xEF": "i\u0308",
          "\u1E2F": "i\u0308\u0301",
          "\u0129": "i\u0303",
          "\u012B": "i\u0304",
          "\u012D": "i\u0306",
          "\u01D0": "i\u030C",
          "\xEE": "i\u0302",
          "\u01F0": "j\u030C",
          "\u0135": "j\u0302",
          "\u1E31": "k\u0301",
          "\u01E9": "k\u030C",
          "\u0137": "k\u0327",
          "\u013A": "l\u0301",
          "\u013E": "l\u030C",
          "\u013C": "l\u0327",
          "\u1E3F": "m\u0301",
          "\u1E41": "m\u0307",
          "\u0144": "n\u0301",
          "\u01F9": "n\u0300",
          "\xF1": "n\u0303",
          "\u0148": "n\u030C",
          "\u1E45": "n\u0307",
          "\u0146": "n\u0327",
          "\xF3": "o\u0301",
          "\xF2": "o\u0300",
          "\xF6": "o\u0308",
          "\u022B": "o\u0308\u0304",
          "\xF5": "o\u0303",
          "\u1E4D": "o\u0303\u0301",
          "\u1E4F": "o\u0303\u0308",
          "\u022D": "o\u0303\u0304",
          "\u014D": "o\u0304",
          "\u1E53": "o\u0304\u0301",
          "\u1E51": "o\u0304\u0300",
          "\u014F": "o\u0306",
          "\u01D2": "o\u030C",
          "\xF4": "o\u0302",
          "\u1ED1": "o\u0302\u0301",
          "\u1ED3": "o\u0302\u0300",
          "\u1ED7": "o\u0302\u0303",
          "\u022F": "o\u0307",
          "\u0231": "o\u0307\u0304",
          "\u0151": "o\u030B",
          "\u1E55": "p\u0301",
          "\u1E57": "p\u0307",
          "\u0155": "r\u0301",
          "\u0159": "r\u030C",
          "\u1E59": "r\u0307",
          "\u0157": "r\u0327",
          "\u015B": "s\u0301",
          "\u1E65": "s\u0301\u0307",
          "\u0161": "s\u030C",
          "\u1E67": "s\u030C\u0307",
          "\u015D": "s\u0302",
          "\u1E61": "s\u0307",
          "\u015F": "s\u0327",
          "\u1E97": "t\u0308",
          "\u0165": "t\u030C",
          "\u1E6B": "t\u0307",
          "\u0163": "t\u0327",
          "\xFA": "u\u0301",
          "\xF9": "u\u0300",
          "\xFC": "u\u0308",
          "\u01D8": "u\u0308\u0301",
          "\u01DC": "u\u0308\u0300",
          "\u01D6": "u\u0308\u0304",
          "\u01DA": "u\u0308\u030C",
          "\u0169": "u\u0303",
          "\u1E79": "u\u0303\u0301",
          "\u016B": "u\u0304",
          "\u1E7B": "u\u0304\u0308",
          "\u016D": "u\u0306",
          "\u01D4": "u\u030C",
          "\xFB": "u\u0302",
          "\u016F": "u\u030A",
          "\u0171": "u\u030B",
          "\u1E7D": "v\u0303",
          "\u1E83": "w\u0301",
          "\u1E81": "w\u0300",
          "\u1E85": "w\u0308",
          "\u0175": "w\u0302",
          "\u1E87": "w\u0307",
          "\u1E98": "w\u030A",
          "\u1E8D": "x\u0308",
          "\u1E8B": "x\u0307",
          "\xFD": "y\u0301",
          "\u1EF3": "y\u0300",
          "\xFF": "y\u0308",
          "\u1EF9": "y\u0303",
          "\u0233": "y\u0304",
          "\u0177": "y\u0302",
          "\u1E8F": "y\u0307",
          "\u1E99": "y\u030A",
          "\u017A": "z\u0301",
          "\u017E": "z\u030C",
          "\u1E91": "z\u0302",
          "\u017C": "z\u0307",
          "\xC1": "A\u0301",
          "\xC0": "A\u0300",
          "\xC4": "A\u0308",
          "\u01DE": "A\u0308\u0304",
          "\xC3": "A\u0303",
          "\u0100": "A\u0304",
          "\u0102": "A\u0306",
          "\u1EAE": "A\u0306\u0301",
          "\u1EB0": "A\u0306\u0300",
          "\u1EB4": "A\u0306\u0303",
          "\u01CD": "A\u030C",
          "\xC2": "A\u0302",
          "\u1EA4": "A\u0302\u0301",
          "\u1EA6": "A\u0302\u0300",
          "\u1EAA": "A\u0302\u0303",
          "\u0226": "A\u0307",
          "\u01E0": "A\u0307\u0304",
          "\xC5": "A\u030A",
          "\u01FA": "A\u030A\u0301",
          "\u1E02": "B\u0307",
          "\u0106": "C\u0301",
          "\u1E08": "C\u0327\u0301",
          "\u010C": "C\u030C",
          "\u0108": "C\u0302",
          "\u010A": "C\u0307",
          "\xC7": "C\u0327",
          "\u010E": "D\u030C",
          "\u1E0A": "D\u0307",
          "\u1E10": "D\u0327",
          "\xC9": "E\u0301",
          "\xC8": "E\u0300",
          "\xCB": "E\u0308",
          "\u1EBC": "E\u0303",
          "\u0112": "E\u0304",
          "\u1E16": "E\u0304\u0301",
          "\u1E14": "E\u0304\u0300",
          "\u0114": "E\u0306",
          "\u1E1C": "E\u0327\u0306",
          "\u011A": "E\u030C",
          "\xCA": "E\u0302",
          "\u1EBE": "E\u0302\u0301",
          "\u1EC0": "E\u0302\u0300",
          "\u1EC4": "E\u0302\u0303",
          "\u0116": "E\u0307",
          "\u0228": "E\u0327",
          "\u1E1E": "F\u0307",
          "\u01F4": "G\u0301",
          "\u1E20": "G\u0304",
          "\u011E": "G\u0306",
          "\u01E6": "G\u030C",
          "\u011C": "G\u0302",
          "\u0120": "G\u0307",
          "\u0122": "G\u0327",
          "\u1E26": "H\u0308",
          "\u021E": "H\u030C",
          "\u0124": "H\u0302",
          "\u1E22": "H\u0307",
          "\u1E28": "H\u0327",
          "\xCD": "I\u0301",
          "\xCC": "I\u0300",
          "\xCF": "I\u0308",
          "\u1E2E": "I\u0308\u0301",
          "\u0128": "I\u0303",
          "\u012A": "I\u0304",
          "\u012C": "I\u0306",
          "\u01CF": "I\u030C",
          "\xCE": "I\u0302",
          "\u0130": "I\u0307",
          "\u0134": "J\u0302",
          "\u1E30": "K\u0301",
          "\u01E8": "K\u030C",
          "\u0136": "K\u0327",
          "\u0139": "L\u0301",
          "\u013D": "L\u030C",
          "\u013B": "L\u0327",
          "\u1E3E": "M\u0301",
          "\u1E40": "M\u0307",
          "\u0143": "N\u0301",
          "\u01F8": "N\u0300",
          "\xD1": "N\u0303",
          "\u0147": "N\u030C",
          "\u1E44": "N\u0307",
          "\u0145": "N\u0327",
          "\xD3": "O\u0301",
          "\xD2": "O\u0300",
          "\xD6": "O\u0308",
          "\u022A": "O\u0308\u0304",
          "\xD5": "O\u0303",
          "\u1E4C": "O\u0303\u0301",
          "\u1E4E": "O\u0303\u0308",
          "\u022C": "O\u0303\u0304",
          "\u014C": "O\u0304",
          "\u1E52": "O\u0304\u0301",
          "\u1E50": "O\u0304\u0300",
          "\u014E": "O\u0306",
          "\u01D1": "O\u030C",
          "\xD4": "O\u0302",
          "\u1ED0": "O\u0302\u0301",
          "\u1ED2": "O\u0302\u0300",
          "\u1ED6": "O\u0302\u0303",
          "\u022E": "O\u0307",
          "\u0230": "O\u0307\u0304",
          "\u0150": "O\u030B",
          "\u1E54": "P\u0301",
          "\u1E56": "P\u0307",
          "\u0154": "R\u0301",
          "\u0158": "R\u030C",
          "\u1E58": "R\u0307",
          "\u0156": "R\u0327",
          "\u015A": "S\u0301",
          "\u1E64": "S\u0301\u0307",
          "\u0160": "S\u030C",
          "\u1E66": "S\u030C\u0307",
          "\u015C": "S\u0302",
          "\u1E60": "S\u0307",
          "\u015E": "S\u0327",
          "\u0164": "T\u030C",
          "\u1E6A": "T\u0307",
          "\u0162": "T\u0327",
          "\xDA": "U\u0301",
          "\xD9": "U\u0300",
          "\xDC": "U\u0308",
          "\u01D7": "U\u0308\u0301",
          "\u01DB": "U\u0308\u0300",
          "\u01D5": "U\u0308\u0304",
          "\u01D9": "U\u0308\u030C",
          "\u0168": "U\u0303",
          "\u1E78": "U\u0303\u0301",
          "\u016A": "U\u0304",
          "\u1E7A": "U\u0304\u0308",
          "\u016C": "U\u0306",
          "\u01D3": "U\u030C",
          "\xDB": "U\u0302",
          "\u016E": "U\u030A",
          "\u0170": "U\u030B",
          "\u1E7C": "V\u0303",
          "\u1E82": "W\u0301",
          "\u1E80": "W\u0300",
          "\u1E84": "W\u0308",
          "\u0174": "W\u0302",
          "\u1E86": "W\u0307",
          "\u1E8C": "X\u0308",
          "\u1E8A": "X\u0307",
          "\xDD": "Y\u0301",
          "\u1EF2": "Y\u0300",
          "\u0178": "Y\u0308",
          "\u1EF8": "Y\u0303",
          "\u0232": "Y\u0304",
          "\u0176": "Y\u0302",
          "\u1E8E": "Y\u0307",
          "\u0179": "Z\u0301",
          "\u017D": "Z\u030C",
          "\u1E90": "Z\u0302",
          "\u017B": "Z\u0307",
          "\u03AC": "\u03B1\u0301",
          "\u1F70": "\u03B1\u0300",
          "\u1FB1": "\u03B1\u0304",
          "\u1FB0": "\u03B1\u0306",
          "\u03AD": "\u03B5\u0301",
          "\u1F72": "\u03B5\u0300",
          "\u03AE": "\u03B7\u0301",
          "\u1F74": "\u03B7\u0300",
          "\u03AF": "\u03B9\u0301",
          "\u1F76": "\u03B9\u0300",
          "\u03CA": "\u03B9\u0308",
          "\u0390": "\u03B9\u0308\u0301",
          "\u1FD2": "\u03B9\u0308\u0300",
          "\u1FD1": "\u03B9\u0304",
          "\u1FD0": "\u03B9\u0306",
          "\u03CC": "\u03BF\u0301",
          "\u1F78": "\u03BF\u0300",
          "\u03CD": "\u03C5\u0301",
          "\u1F7A": "\u03C5\u0300",
          "\u03CB": "\u03C5\u0308",
          "\u03B0": "\u03C5\u0308\u0301",
          "\u1FE2": "\u03C5\u0308\u0300",
          "\u1FE1": "\u03C5\u0304",
          "\u1FE0": "\u03C5\u0306",
          "\u03CE": "\u03C9\u0301",
          "\u1F7C": "\u03C9\u0300",
          "\u038E": "\u03A5\u0301",
          "\u1FEA": "\u03A5\u0300",
          "\u03AB": "\u03A5\u0308",
          "\u1FE9": "\u03A5\u0304",
          "\u1FE8": "\u03A5\u0306",
          "\u038F": "\u03A9\u0301",
          "\u1FFA": "\u03A9\u0300"
        };
        class Parser {
          constructor(input, settings) {
            this.mode = void 0;
            this.gullet = void 0;
            this.settings = void 0;
            this.leftrightDepth = void 0;
            this.nextToken = void 0;
            this.mode = "math";
            this.gullet = new MacroExpander(input, settings, this.mode);
            this.settings = settings;
            this.leftrightDepth = 0;
          }
          expect(text, consume) {
            if (consume === void 0) {
              consume = true;
            }
            if (this.fetch().text !== text) {
              throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
            }
            if (consume) {
              this.consume();
            }
          }
          consume() {
            this.nextToken = null;
          }
          fetch() {
            if (this.nextToken == null) {
              this.nextToken = this.gullet.expandNextToken();
            }
            return this.nextToken;
          }
          switchMode(newMode) {
            this.mode = newMode;
            this.gullet.switchMode(newMode);
          }
          parse() {
            if (!this.settings.globalGroup) {
              this.gullet.beginGroup();
            }
            if (this.settings.colorIsTextColor) {
              this.gullet.macros.set("\\color", "\\textcolor");
            }
            try {
              const parse = this.parseExpression(false);
              this.expect("EOF");
              if (!this.settings.globalGroup) {
                this.gullet.endGroup();
              }
              return parse;
            } finally {
              this.gullet.endGroups();
            }
          }
          subparse(tokens) {
            const oldToken = this.nextToken;
            this.consume();
            this.gullet.pushToken(new Token2("}"));
            this.gullet.pushTokens(tokens);
            const parse = this.parseExpression(false);
            this.expect("}");
            this.nextToken = oldToken;
            return parse;
          }
          parseExpression(breakOnInfix, breakOnTokenText) {
            const body = [];
            while (true) {
              if (this.mode === "math") {
                this.consumeSpaces();
              }
              const lex = this.fetch();
              if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
                break;
              }
              if (breakOnTokenText && lex.text === breakOnTokenText) {
                break;
              }
              if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                break;
              }
              const atom = this.parseAtom(breakOnTokenText);
              if (!atom) {
                break;
              } else if (atom.type === "internal") {
                continue;
              }
              body.push(atom);
            }
            if (this.mode === "text") {
              this.formLigatures(body);
            }
            return this.handleInfixNodes(body);
          }
          handleInfixNodes(body) {
            let overIndex = -1;
            let funcName;
            for (let i = 0; i < body.length; i++) {
              if (body[i].type === "infix") {
                if (overIndex !== -1) {
                  throw new src_ParseError("only one infix operator per group", body[i].token);
                }
                overIndex = i;
                funcName = body[i].replaceWith;
              }
            }
            if (overIndex !== -1 && funcName) {
              let numerNode;
              let denomNode;
              const numerBody = body.slice(0, overIndex);
              const denomBody = body.slice(overIndex + 1);
              if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                numerNode = numerBody[0];
              } else {
                numerNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: numerBody
                };
              }
              if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                denomNode = denomBody[0];
              } else {
                denomNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: denomBody
                };
              }
              let node;
              if (funcName === "\\\\abovefrac") {
                node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
              } else {
                node = this.callFunction(funcName, [numerNode, denomNode], []);
              }
              return [node];
            } else {
              return body;
            }
          }
          handleSupSubscript(name) {
            const symbolToken = this.fetch();
            const symbol = symbolToken.text;
            this.consume();
            this.consumeSpaces();
            let group;
            do {
              var _group;
              group = this.parseGroup(name);
            } while (((_group = group) == null ? void 0 : _group.type) === "internal");
            if (!group) {
              throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
            }
            return group;
          }
          formatUnsupportedCmd(text) {
            const textordArray = [];
            for (let i = 0; i < text.length; i++) {
              textordArray.push({
                type: "textord",
                mode: "text",
                text: text[i]
              });
            }
            const textNode = {
              type: "text",
              mode: this.mode,
              body: textordArray
            };
            const colorNode = {
              type: "color",
              mode: this.mode,
              color: this.settings.errorColor,
              body: [textNode]
            };
            return colorNode;
          }
          parseAtom(breakOnTokenText) {
            const base = this.parseGroup("atom", breakOnTokenText);
            if ((base == null ? void 0 : base.type) === "internal") {
              return base;
            }
            if (this.mode === "text") {
              return base;
            }
            let superscript;
            let subscript;
            while (true) {
              this.consumeSpaces();
              const lex = this.fetch();
              if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                if (base && base.type === "op") {
                  const limits = lex.text === "\\limits";
                  base.limits = limits;
                  base.alwaysHandleSupSub = true;
                } else if (base && base.type === "operatorname") {
                  if (base.alwaysHandleSupSub) {
                    base.limits = lex.text === "\\limits";
                  }
                } else {
                  throw new src_ParseError("Limit controls must follow a math operator", lex);
                }
                this.consume();
              } else if (lex.text === "^") {
                if (superscript) {
                  throw new src_ParseError("Double superscript", lex);
                }
                superscript = this.handleSupSubscript("superscript");
              } else if (lex.text === "_") {
                if (subscript) {
                  throw new src_ParseError("Double subscript", lex);
                }
                subscript = this.handleSupSubscript("subscript");
              } else if (lex.text === "'") {
                if (superscript) {
                  throw new src_ParseError("Double superscript", lex);
                }
                const prime = {
                  type: "textord",
                  mode: this.mode,
                  text: "\\prime"
                };
                const primes = [prime];
                this.consume();
                while (this.fetch().text === "'") {
                  primes.push(prime);
                  this.consume();
                }
                if (this.fetch().text === "^") {
                  primes.push(this.handleSupSubscript("superscript"));
                }
                superscript = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: primes
                };
              } else if (uSubsAndSups[lex.text]) {
                const isSub = unicodeSubRegEx.test(lex.text);
                const subsupTokens = [];
                subsupTokens.push(new Token2(uSubsAndSups[lex.text]));
                this.consume();
                while (true) {
                  const token = this.fetch().text;
                  if (!uSubsAndSups[token]) {
                    break;
                  }
                  if (unicodeSubRegEx.test(token) !== isSub) {
                    break;
                  }
                  subsupTokens.unshift(new Token2(uSubsAndSups[token]));
                  this.consume();
                }
                const body = this.subparse(subsupTokens);
                if (isSub) {
                  subscript = {
                    type: "ordgroup",
                    mode: "math",
                    body
                  };
                } else {
                  superscript = {
                    type: "ordgroup",
                    mode: "math",
                    body
                  };
                }
              } else {
                break;
              }
            }
            if (superscript || subscript) {
              return {
                type: "supsub",
                mode: this.mode,
                base,
                sup: superscript,
                sub: subscript
              };
            } else {
              return base;
            }
          }
          parseFunction(breakOnTokenText, name) {
            const token = this.fetch();
            const func = token.text;
            const funcData = src_functions[func];
            if (!funcData) {
              return null;
            }
            this.consume();
            if (name && name !== "atom" && !funcData.allowedInArgument) {
              throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
            } else if (this.mode === "text" && !funcData.allowedInText) {
              throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
            } else if (this.mode === "math" && funcData.allowedInMath === false) {
              throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
            }
            const {
              args,
              optArgs
            } = this.parseArguments(func, funcData);
            return this.callFunction(func, args, optArgs, token, breakOnTokenText);
          }
          callFunction(name, args, optArgs, token, breakOnTokenText) {
            const context = {
              funcName: name,
              parser: this,
              token,
              breakOnTokenText
            };
            const func = src_functions[name];
            if (func && func.handler) {
              return func.handler(context, args, optArgs);
            } else {
              throw new src_ParseError("No function handler for " + name);
            }
          }
          parseArguments(func, funcData) {
            const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
            if (totalArgs === 0) {
              return {
                args: [],
                optArgs: []
              };
            }
            const args = [];
            const optArgs = [];
            for (let i = 0; i < totalArgs; i++) {
              let argType = funcData.argTypes && funcData.argTypes[i];
              const isOptional = i < funcData.numOptionalArgs;
              if (funcData.primitive && argType == null || funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
                argType = "primitive";
              }
              const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
              if (isOptional) {
                optArgs.push(arg);
              } else if (arg != null) {
                args.push(arg);
              } else {
                throw new src_ParseError("Null argument, please report this as a bug");
              }
            }
            return {
              args,
              optArgs
            };
          }
          parseGroupOfType(name, type, optional) {
            switch (type) {
              case "color":
                return this.parseColorGroup(optional);
              case "size":
                return this.parseSizeGroup(optional);
              case "url":
                return this.parseUrlGroup(optional);
              case "math":
              case "text":
                return this.parseArgumentGroup(optional, type);
              case "hbox": {
                const group = this.parseArgumentGroup(optional, "text");
                return group != null ? {
                  type: "styling",
                  mode: group.mode,
                  body: [group],
                  style: "text"
                } : null;
              }
              case "raw": {
                const token = this.parseStringGroup("raw", optional);
                return token != null ? {
                  type: "raw",
                  mode: "text",
                  string: token.text
                } : null;
              }
              case "primitive": {
                if (optional) {
                  throw new src_ParseError("A primitive argument cannot be optional");
                }
                const group = this.parseGroup(name);
                if (group == null) {
                  throw new src_ParseError("Expected group as " + name, this.fetch());
                }
                return group;
              }
              case "original":
              case null:
              case void 0:
                return this.parseArgumentGroup(optional);
              default:
                throw new src_ParseError("Unknown group type as " + name, this.fetch());
            }
          }
          consumeSpaces() {
            while (this.fetch().text === " ") {
              this.consume();
            }
          }
          parseStringGroup(modeName, optional) {
            const argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            let str = "";
            let nextToken;
            while ((nextToken = this.fetch()).text !== "EOF") {
              str += nextToken.text;
              this.consume();
            }
            this.consume();
            argToken.text = str;
            return argToken;
          }
          parseRegexGroup(regex, modeName) {
            const firstToken = this.fetch();
            let lastToken = firstToken;
            let str = "";
            let nextToken;
            while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
              lastToken = nextToken;
              str += lastToken.text;
              this.consume();
            }
            if (str === "") {
              throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
            }
            return firstToken.range(lastToken, str);
          }
          parseColorGroup(optional) {
            const res = this.parseStringGroup("color", optional);
            if (res == null) {
              return null;
            }
            const match = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
            if (!match) {
              throw new src_ParseError("Invalid color: '" + res.text + "'", res);
            }
            let color = match[0];
            if (/^[0-9a-f]{6}$/i.test(color)) {
              color = "#" + color;
            }
            return {
              type: "color-token",
              mode: this.mode,
              color
            };
          }
          parseSizeGroup(optional) {
            let res;
            let isBlank = false;
            this.gullet.consumeSpaces();
            if (!optional && this.gullet.future().text !== "{") {
              res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
            } else {
              res = this.parseStringGroup("size", optional);
            }
            if (!res) {
              return null;
            }
            if (!optional && res.text.length === 0) {
              res.text = "0pt";
              isBlank = true;
            }
            const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
            if (!match) {
              throw new src_ParseError("Invalid size: '" + res.text + "'", res);
            }
            const data = {
              number: +(match[1] + match[2]),
              unit: match[3]
            };
            if (!validUnit(data)) {
              throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
            }
            return {
              type: "size",
              mode: this.mode,
              value: data,
              isBlank
            };
          }
          parseUrlGroup(optional) {
            this.gullet.lexer.setCatcode("%", 13);
            this.gullet.lexer.setCatcode("~", 12);
            const res = this.parseStringGroup("url", optional);
            this.gullet.lexer.setCatcode("%", 14);
            this.gullet.lexer.setCatcode("~", 13);
            if (res == null) {
              return null;
            }
            const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
            return {
              type: "url",
              mode: this.mode,
              url
            };
          }
          parseArgumentGroup(optional, mode) {
            const argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            const outerMode = this.mode;
            if (mode) {
              this.switchMode(mode);
            }
            this.gullet.beginGroup();
            const expression = this.parseExpression(false, "EOF");
            this.expect("EOF");
            this.gullet.endGroup();
            const result = {
              type: "ordgroup",
              mode: this.mode,
              loc: argToken.loc,
              body: expression
            };
            if (mode) {
              this.switchMode(outerMode);
            }
            return result;
          }
          parseGroup(name, breakOnTokenText) {
            const firstToken = this.fetch();
            const text = firstToken.text;
            let result;
            if (text === "{" || text === "\\begingroup") {
              this.consume();
              const groupEnd = text === "{" ? "}" : "\\endgroup";
              this.gullet.beginGroup();
              const expression = this.parseExpression(false, groupEnd);
              const lastToken = this.fetch();
              this.expect(groupEnd);
              this.gullet.endGroup();
              result = {
                type: "ordgroup",
                mode: this.mode,
                loc: SourceLocation.range(firstToken, lastToken),
                body: expression,
                semisimple: text === "\\begingroup" || void 0
              };
            } else {
              result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
              if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
                if (this.settings.throwOnError) {
                  throw new src_ParseError("Undefined control sequence: " + text, firstToken);
                }
                result = this.formatUnsupportedCmd(text);
                this.consume();
              }
            }
            return result;
          }
          formLigatures(group) {
            let n = group.length - 1;
            for (let i = 0; i < n; ++i) {
              const a = group[i];
              const v = a.text;
              if (v === "-" && group[i + 1].text === "-") {
                if (i + 1 < n && group[i + 2].text === "-") {
                  group.splice(i, 3, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i + 2]),
                    text: "---"
                  });
                  n -= 2;
                } else {
                  group.splice(i, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i + 1]),
                    text: "--"
                  });
                  n -= 1;
                }
              }
              if ((v === "'" || v === "`") && group[i + 1].text === v) {
                group.splice(i, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 1]),
                  text: v + v
                });
                n -= 1;
              }
            }
          }
          parseSymbol() {
            const nucleus = this.fetch();
            let text = nucleus.text;
            if (/^\\verb[^a-zA-Z]/.test(text)) {
              this.consume();
              let arg = text.slice(5);
              const star = arg.charAt(0) === "*";
              if (star) {
                arg = arg.slice(1);
              }
              if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
              }
              arg = arg.slice(1, -1);
              return {
                type: "verb",
                mode: "text",
                body: arg,
                star
              };
            }
            if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
              if (this.settings.strict && this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in math mode', nucleus);
              }
              text = unicodeSymbols[text[0]] + text.slice(1);
            }
            const match = combiningDiacriticalMarksEndRegex.exec(text);
            if (match) {
              text = text.substring(0, match.index);
              if (text === "i") {
                text = "\u0131";
              } else if (text === "j") {
                text = "\u0237";
              }
            }
            let symbol;
            if (src_symbols[this.mode][text]) {
              if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text) >= 0) {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in math mode', nucleus);
              }
              const group = src_symbols[this.mode][text].group;
              const loc = SourceLocation.range(nucleus);
              let s;
              if (ATOMS.hasOwnProperty(group)) {
                const family = group;
                s = {
                  type: "atom",
                  mode: this.mode,
                  family,
                  loc,
                  text
                };
              } else {
                s = {
                  type: group,
                  mode: this.mode,
                  loc,
                  text
                };
              }
              symbol = s;
            } else if (text.charCodeAt(0) >= 128) {
              if (this.settings.strict) {
                if (!supportedCodepoint(text.charCodeAt(0))) {
                  this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '"' + (" (" + text.charCodeAt(0) + ")"), nucleus);
                } else if (this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus);
                }
              }
              symbol = {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(nucleus),
                text
              };
            } else {
              return null;
            }
            this.consume();
            if (match) {
              for (let i = 0; i < match[0].length; i++) {
                const accent2 = match[0][i];
                if (!unicodeAccents[accent2]) {
                  throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
                }
                const command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
                if (!command) {
                  throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
                }
                symbol = {
                  type: "accent",
                  mode: this.mode,
                  loc: SourceLocation.range(nucleus),
                  label: command,
                  isStretchy: false,
                  isShifty: true,
                  base: symbol
                };
              }
            }
            return symbol;
          }
        }
        Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
        ;
        const parseTree = function(toParse, settings) {
          if (!(typeof toParse === "string" || toParse instanceof String)) {
            throw new TypeError("KaTeX can only parse string typed expression");
          }
          const parser = new Parser(toParse, settings);
          delete parser.gullet.macros.current["\\df@tag"];
          let tree = parser.parse();
          delete parser.gullet.macros.current["\\current@color"];
          delete parser.gullet.macros.current["\\color"];
          if (parser.gullet.macros.get("\\df@tag")) {
            if (!settings.displayMode) {
              throw new src_ParseError("\\tag works only in display equations");
            }
            tree = [{
              type: "tag",
              mode: "text",
              body: tree,
              tag: parser.subparse([new Token2("\\df@tag")])
            }];
          }
          return tree;
        };
        var src_parseTree = parseTree;
        ;
        let render = function(expression, baseNode, options) {
          baseNode.textContent = "";
          const node = renderToDomTree(expression, options).toNode();
          baseNode.appendChild(node);
        };
        if (typeof document !== "undefined") {
          if (document.compatMode !== "CSS1Compat") {
            typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
            render = function() {
              throw new src_ParseError("KaTeX doesn't work in quirks mode.");
            };
          }
        }
        const renderToString = function(expression, options) {
          const markup = renderToDomTree(expression, options).toMarkup();
          return markup;
        };
        const generateParseTree = function(expression, options) {
          const settings = new Settings(options);
          return src_parseTree(expression, settings);
        };
        const renderError = function(error, expression, options) {
          if (options.throwOnError || !(error instanceof src_ParseError)) {
            throw error;
          }
          const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
          node.setAttribute("title", error.toString());
          node.setAttribute("style", "color:" + options.errorColor);
          return node;
        };
        const renderToDomTree = function(expression, options) {
          const settings = new Settings(options);
          try {
            const tree = src_parseTree(expression, settings);
            return buildTree(tree, expression, settings);
          } catch (error) {
            return renderError(error, expression, settings);
          }
        };
        const renderToHTMLTree = function(expression, options) {
          const settings = new Settings(options);
          try {
            const tree = src_parseTree(expression, settings);
            return buildHTMLTree(tree, expression, settings);
          } catch (error) {
            return renderError(error, expression, settings);
          }
        };
        const version = "0.16.27";
        const __domTree = {
          Span,
          Anchor,
          SymbolNode,
          SvgNode,
          PathNode,
          LineNode
        };
        var katex = {
          version,
          render,
          renderToString,
          ParseError: src_ParseError,
          SETTINGS_SCHEMA,
          __parse: generateParseTree,
          __renderToDomTree: renderToDomTree,
          __renderToHTMLTree: renderToHTMLTree,
          __setFontMetrics: setFontMetrics,
          __defineSymbol: defineSymbol,
          __defineFunction: defineFunction,
          __defineMacro: defineMacro,
          __domTree
        };
        ;
        var katex_webpack = katex;
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      }();
    });
  }
});

// ../../packages/core/dist/plugins/markdown-it-math.js
var require_markdown_it_math = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-math.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var katex_1 = __importDefault(require_katex());
    var escapeHtml = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    var escapeAttribute = (str) => escapeHtml(str).replace(/'/g, "&#39;");
    var renderMathJax = (latex, display) => {
      if (typeof window === "undefined")
        return null;
      const mathJax = window.MathJax;
      if (!mathJax || typeof mathJax.tex2svg !== "function")
        return null;
      try {
        if (typeof mathJax.texReset === "function") {
          mathJax.texReset();
        }
        const container = mathJax.tex2svg(latex, { display });
        const svg = container.querySelector("svg");
        if (!svg)
          return null;
        const width = svg.getAttribute("width") || svg.style.minWidth;
        svg.removeAttribute("width");
        svg.style.display = "initial";
        svg.style.setProperty("max-width", "300vw", "important");
        svg.style.flexShrink = "0";
        if (width) {
          svg.style.width = width;
        }
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        return svg.outerHTML;
      } catch (error) {
        console.error("MathJax render error:", error);
        return null;
      }
    };
    function isValidDelim(state, pos) {
      var prevChar, nextChar, max = state.posMax, can_open = true, can_close = true;
      prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
      nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
      if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) {
        can_close = false;
      }
      if (nextChar === 32 || nextChar === 9) {
        can_open = false;
      }
      return {
        can_open,
        can_close
      };
    }
    function math_inline(state, silent) {
      var start, match, token, res, pos;
      if (state.src[state.pos] !== "$") {
        return false;
      }
      res = isValidDelim(state, state.pos);
      if (!res.can_open) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos += 1;
        return true;
      }
      start = state.pos + 1;
      match = start;
      while ((match = state.src.indexOf("$", match)) !== -1) {
        pos = match - 1;
        while (state.src[pos] === "\\") {
          pos -= 1;
        }
        if ((match - pos) % 2 == 1) {
          break;
        }
        match += 1;
      }
      if (match === -1) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (match - start === 0) {
        if (!silent) {
          state.pending += "$$";
        }
        state.pos = start + 1;
        return true;
      }
      res = isValidDelim(state, match);
      if (!res.can_close) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (!silent) {
        token = state.push("math_inline", "math", 0);
        token.markup = "$";
        token.content = state.src.slice(start, match);
      }
      state.pos = match + 1;
      return true;
    }
    function math_block(state, start, end, silent) {
      var firstLine, lastLine, next, lastPos, found = false, token, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start];
      if (pos + 2 > max) {
        return false;
      }
      if (state.src.slice(pos, pos + 2) !== "$$") {
        return false;
      }
      pos += 2;
      firstLine = state.src.slice(pos, max);
      if (silent) {
        return true;
      }
      if (firstLine.trim().slice(-2) === "$$") {
        firstLine = firstLine.trim().slice(0, -2);
        found = true;
      }
      for (next = start; !found; ) {
        next++;
        if (next >= end) {
          break;
        }
        pos = state.bMarks[next] + state.tShift[next];
        max = state.eMarks[next];
        if (pos < max && state.tShift[next] < state.blkIndent) {
          break;
        }
        if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
          lastPos = state.src.slice(0, max).lastIndexOf("$$");
          lastLine = state.src.slice(pos, lastPos);
          found = true;
        }
      }
      state.line = next + 1;
      token = state.push("math_block", "math", 0);
      token.block = true;
      token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
      token.map = [start, state.line];
      token.markup = "$$";
      return true;
    }
    exports.default = (md, options) => {
      options = options || {};
      var katexInline = function(latex) {
        options.displayMode = false;
        const mathJaxContent = renderMathJax(latex, false);
        if (mathJaxContent) {
          return `<span class="inline-equation">${mathJaxContent}</span>`;
        }
        try {
          const rendered = katex_1.default.renderToString(latex, {
            displayMode: false,
            throwOnError: false
          });
          return `<span class="inline-equation" data-latex="${escapeAttribute(latex)}">${rendered}</span>`;
        } catch (error) {
          if (options.throwOnError) {
            throw error;
          }
          return `<span class="inline-equation" data-latex="${escapeAttribute(latex)}">${escapeHtml(latex)}</span>`;
        }
      };
      var inlineRenderer = function(tokens, idx) {
        return katexInline(tokens[idx].content);
      };
      var katexBlock = function(latex) {
        options.displayMode = true;
        const mathJaxContent = renderMathJax(latex, true);
        if (mathJaxContent) {
          return `<section class="block-equation">${mathJaxContent}</section>`;
        }
        try {
          const rendered = katex_1.default.renderToString(latex, {
            displayMode: true,
            throwOnError: false
          });
          return `<section class="block-equation" data-latex="${escapeAttribute(latex)}">${rendered}</section>`;
        } catch (error) {
          if (options.throwOnError) {
            throw error;
          }
          return `<section class="block-equation" data-latex="${escapeAttribute(latex)}">${escapeHtml(latex)}</section>`;
        }
      };
      var blockRenderer = function(tokens, idx) {
        return katexBlock(tokens[idx].content) + "\n";
      };
      md.inline.ruler.after("escape", "math_inline", math_inline);
      md.block.ruler.after("blockquote", "math_block", math_block, {
        alt: ["paragraph", "reference", "blockquote", "list"]
      });
      md.renderer.rules.math_inline = inlineRenderer;
      md.renderer.rules.math_block = blockRenderer;
    };
  }
});

// ../../packages/core/dist/plugins/markdown-it-span.js
var require_markdown_it_span = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-span.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function slugify(s, md) {
      const spaceRegex = new RegExp(md.utils.lib.ucmicro.Z.source, "g");
      return encodeURIComponent(s.replace(spaceRegex, ""));
    }
    function makeRule(md, options) {
      return function addHeadingAnchors(state) {
        for (let i = 0; i < state.tokens.length - 1; i++) {
          if (state.tokens[i].type !== "heading_open" || state.tokens[i + 1].type !== "inline") {
            continue;
          }
          const headingInlineToken = state.tokens[i + 1];
          if (!headingInlineToken.content || !headingInlineToken.children) {
            continue;
          }
          if (options.addHeadingSpan) {
            const spanTokenPre = new state.Token("html_inline", "", 0);
            spanTokenPre.content = `<span class="prefix"></span><span class="content">`;
            headingInlineToken.children.unshift(spanTokenPre);
            const spanTokenPost = new state.Token("html_inline", "", 0);
            spanTokenPost.content = `</span><span class="suffix"></span>`;
            headingInlineToken.children.push(spanTokenPost);
          }
          i += 2;
        }
      };
    }
    exports.default = (md, opts) => {
      const defaults = {
        anchorClass: "markdown-it-headingspan",
        addHeadingSpan: true,
        slugify
      };
      const options = md.utils.assign(defaults, opts);
      md.core.ruler.push("heading_span", makeRule(md, options));
    };
  }
});

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/token.mjs
var token_exports = {};
__export(token_exports, {
  default: () => token_default
});
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
var token_default;
var init_token = __esm({
  "../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/token.mjs"() {
    Token.prototype.attrIndex = function attrIndex(name) {
      if (!this.attrs) {
        return -1;
      }
      const attrs = this.attrs;
      for (let i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      const idx = this.attrIndex(name);
      const attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      const idx = this.attrIndex(name);
      let value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      const idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    token_default = Token;
  }
});

// ../../packages/core/dist/plugins/markdown-it-table-container.js
var require_markdown_it_table_container = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-table-container.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var token_1 = __importDefault((init_token(), __toCommonJS(token_exports)));
    function makeRule() {
      return function addTableContainer(state) {
        const arr = [];
        for (let i = 0; i < state.tokens.length; i++) {
          const curToken = state.tokens[i];
          if (curToken.type === "table_open") {
            const tableContainerStart = new token_1.default("html_inline", "", 0);
            tableContainerStart.content = `<section class="table-container">`;
            arr.push(tableContainerStart);
            arr.push(curToken);
          } else if (curToken.type === "table_close") {
            const tableContainerClose = new token_1.default("html_inline", "", 0);
            tableContainerClose.content = `</section>`;
            arr.push(curToken);
            arr.push(tableContainerClose);
          } else {
            arr.push(curToken);
          }
        }
        state.tokens = arr;
      };
    }
    exports.default = (md) => {
      md.core.ruler.push("table-container", makeRule());
    };
  }
});

// ../../packages/core/dist/plugins/markdown-it-linkfoot.js
var require_markdown_it_linkfoot = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-linkfoot.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var token_1 = __importDefault((init_token(), __toCommonJS(token_exports)));
    function renderFootnoteAnchorName(tokens, idx, options, env) {
      const n = Number(tokens[idx].meta.id + 1).toString();
      let prefix = "";
      if (typeof env.docId === "string") {
        prefix = "-" + env.docId + "-";
      }
      return prefix + n;
    }
    function renderFootnoteCaption(tokens, idx) {
      let n = Number(tokens[idx].meta.id + 1).toString();
      if (tokens[idx].meta.subId > 0) {
        n += ":" + tokens[idx].meta.subId;
      }
      return "[" + n + "]";
    }
    function renderFootnoteWord(tokens, idx, options, env, slf) {
      return '<span class="footnote-word">' + tokens[idx].content + "</span>";
    }
    function renderFootnoteRef(tokens, idx, options, env, slf) {
      const caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);
      return '<sup class="footnote-ref">' + caption + "</sup>";
    }
    function renderFootnoteBlockOpen(tokens, idx, options) {
      return '<h3 class="footnotes-sep"></h3>\n<section class="footnotes">\n';
    }
    function renderFootnoteBlockClose() {
      return "</section>\n";
    }
    function renderFootnoteOpen(tokens, idx, options, env, slf) {
      let id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);
      if (tokens[idx].meta.subId > 0) {
        id += ":" + tokens[idx].meta.subId;
      }
      return '<span id="fn' + id + '" class="footnote-item"><span class="footnote-num">[' + id + "] </span>";
    }
    function renderFootnoteClose() {
      return "</span>\n";
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
        default:
      }
      return false;
    }
    function normalizeReference(str) {
      return str.trim().replace(/\s+/g, " ").toUpperCase();
    }
    function linkFoot(state, silent) {
      let attrs, code, label, pos, res, ref, title, token, href = "", start = state.pos, footnoteContent, parseReference = true;
      const oldPos = state.pos;
      const max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      const labelStart = state.pos + 1;
      const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          footnoteContent = res.str;
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        if (title) {
          state.pos = labelStart;
          state.posMax = labelEnd;
          let tokens;
          if (!state.env.footnotes) {
            state.env.footnotes = {};
          }
          if (!state.env.footnotes.list) {
            state.env.footnotes.list = [];
          }
          const footnoteId = state.env.footnotes.list.length;
          state.md.inline.parse(`${title}: *${footnoteContent}*`, state.md, state.env, tokens = []);
          token = state.push("footnote_word", "", 0);
          token.content = state.src.slice(labelStart, labelEnd);
          token = state.push("footnote_ref", "", 0);
          token.meta = { id: footnoteId };
          state.env.footnotes.list[footnoteId] = { tokens };
        } else {
          state.pos = labelStart;
          state.posMax = labelEnd;
          token = state.push("link_open", "a", 1);
          attrs = [["href", href]];
          token.attrs = attrs;
          if (title) {
            attrs.push(["title", title]);
          }
          state.md.inline.tokenize(state);
          token = state.push("link_close", "a", -1);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    }
    function footnoteTail(state) {
      let i, l, lastParagraph, token, tokens, current = [], currentLabel = "", insideRef = false;
      const refTokens = {};
      if (!state.env.footnotes) {
        return;
      }
      state.tokens = state.tokens.filter((tok) => {
        if (tok.type === "footnote_reference_open") {
          insideRef = true;
          current = [];
          currentLabel = tok.meta.label;
          return false;
        }
        if (tok.type === "footnote_reference_close") {
          insideRef = false;
          refTokens[":" + currentLabel] = current;
          return false;
        }
        if (insideRef) {
          current.push(tok);
        }
        return !insideRef;
      });
      if (!state.env.footnotes.list) {
        return;
      }
      const list = state.env.footnotes.list;
      token = new token_1.default("footnote_block_open", "", 1);
      state.tokens.push(token);
      for (i = 0, l = list.length; i < l; i++) {
        token = new token_1.default("footnote_open", "", 1);
        token.meta = { id: i, label: list[i].label };
        state.tokens.push(token);
        if (list[i].tokens) {
          tokens = [];
          token = new token_1.default("paragraph_open", "p", 1);
          token.block = true;
          tokens.push(token);
          token = new token_1.default("inline", "", 0);
          token.children = list[i].tokens;
          token.content = "";
          tokens.push(token);
          token = new token_1.default("paragraph_close", "p", -1);
          token.block = true;
          tokens.push(token);
        } else if (list[i].label) {
          tokens = refTokens[":" + list[i].label];
        }
        if (tokens) {
          state.tokens = state.tokens.concat(tokens);
        }
        if (state.tokens[state.tokens.length - 1].type === "paragraph_close") {
          lastParagraph = state.tokens.pop();
        } else {
          lastParagraph = null;
        }
        if (lastParagraph) {
          state.tokens.push(lastParagraph);
        }
        token = new token_1.default("footnote_close", "", -1);
        state.tokens.push(token);
      }
      token = new token_1.default("footnote_block_close", "", -1);
      state.tokens.push(token);
    }
    exports.default = (md) => {
      md.renderer.rules.footnote_ref = renderFootnoteRef;
      md.renderer.rules.footnote_word = renderFootnoteWord;
      md.renderer.rules.footnote_block_open = renderFootnoteBlockOpen;
      md.renderer.rules.footnote_block_close = renderFootnoteBlockClose;
      md.renderer.rules.footnote_open = renderFootnoteOpen;
      md.renderer.rules.footnote_close = renderFootnoteClose;
      md.renderer.rules.footnote_caption = renderFootnoteCaption;
      md.renderer.rules.footnote_anchor_name = renderFootnoteAnchorName;
      md.inline.ruler.at("link", linkFoot);
      md.core.ruler.after("inline", "footnote_tail", footnoteTail);
    };
  }
});

// ../../packages/core/dist/plugins/markdown-it-imageflow.js
var require_markdown_it_imageflow = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-imageflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOption = {
      limitless: false,
      limit: 10
    };
    var imageFlowPlugin = (md, opt) => {
      const options = opt || defaultOption;
      const tokenize = (state, start) => {
        let token;
        const matchReg = /^<((!\[[^[\]]*\]\([^()]+\)(,?\s*(?=>)|,\s*(?!>)))+)>/;
        const srcLine = state.src.slice(state.bMarks[start], state.eMarks[start]);
        if (srcLine.charCodeAt(0) !== 60) {
          return false;
        }
        const match = matchReg.exec(srcLine);
        if (match) {
          const images = match[1].match(/\[[^\]]*\]\([^)]+\)/g);
          if (images && !options.limitless && images.length <= options.limit) {
            token = state.push("imageFlow", "", 0);
            token.meta = images;
            token.block = true;
            state.line++;
            return true;
          }
        }
        return false;
      };
      md.renderer.rules.imageFlow = (tokens, idx) => {
        const start = `<section class="imageflow-layer1"><section class="imageflow-layer2">`;
        const end = `</section></section><p class="imageflow-caption"><<< \u5DE6\u53F3\u6ED1\u52A8\u89C1\u66F4\u591A >>></p>`;
        const contents = tokens[idx].meta;
        let wrappedContent = "";
        let alt;
        let src;
        contents.forEach((content) => {
          const altMatch = content.match(/\[([^[\]]*)\]/);
          alt = altMatch ? altMatch[1] : "";
          const srcMatch = content.match(/[^[]*\(([^()]*)\)[^\]]*/);
          src = srcMatch ? srcMatch[1] : "";
          wrappedContent += `<section class="imageflow-layer3"><img alt="${alt}" src="${src}" class="imageflow-img" /></section>`;
        });
        return start + wrappedContent + end;
      };
      md.block.ruler.before("paragraph", "imageFlow", tokenize);
    };
    exports.default = imageFlowPlugin;
  }
});

// ../../packages/core/dist/plugins/markdown-it-multiquote.js
var require_markdown_it_multiquote = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-multiquote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeRule() {
      return function addTableContainer(state) {
        let count = 0;
        let outerQuoteToekn;
        for (let i = 0; i < state.tokens.length; i++) {
          const curToken = state.tokens[i];
          if (curToken.type === "blockquote_open") {
            if (count === 0) {
              outerQuoteToekn = curToken;
            }
            count++;
            continue;
          }
          if (count > 0 && outerQuoteToekn) {
            outerQuoteToekn.attrs = [["class", "multiquote-" + count]];
            count = 0;
          }
        }
      };
    }
    exports.default = (md) => {
      md.core.ruler.push("blockquote-class", makeRule());
    };
  }
});

// ../../packages/core/dist/plugins/markdown-it-li.js
var require_markdown_it_li = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-li.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeRule(md) {
      return function replaceListItem() {
        md.renderer.rules.list_item_open = function replaceOpen() {
          return "<li><section>";
        };
        md.renderer.rules.list_item_close = function replaceClose() {
          return "</section></li>";
        };
      };
    }
    exports.default = (md) => {
      md.core.ruler.push("replace-li", makeRule(md));
    };
  }
});

// ../../packages/core/dist/plugins/markdown-it-github-alert.js
var require_markdown_it_github_alert = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-github-alert.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = markdownItGitHubAlert;
    var token_1 = __importDefault((init_token(), __toCommonJS(token_exports)));
    var ALERT_CONFIGS = [
      { type: "NOTE", label: "\u5907\u6CE8", icon: "\u2139\uFE0F", cssClass: "note" },
      { type: "TIP", label: "\u63D0\u793A", icon: "\u{1F4A1}", cssClass: "tip" },
      { type: "IMPORTANT", label: "\u91CD\u8981", icon: "\u{1F4CC}", cssClass: "important" },
      { type: "WARNING", label: "\u8B66\u544A", icon: "\u26A0\uFE0F", cssClass: "warning" },
      { type: "CAUTION", label: "\u5371\u9669", icon: "\u{1F6A8}", cssClass: "caution" }
    ];
    var ALERT_PATTERN = /^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\s*/i;
    function findAlertType(text) {
      const match = text.match(ALERT_PATTERN);
      if (!match)
        return null;
      const type = match[1].toUpperCase();
      const config = ALERT_CONFIGS.find((c) => c.type === type);
      if (!config)
        return null;
      const restContent = text.slice(match[0].length);
      return { config, restContent };
    }
    function markdownItGitHubAlert(md) {
      md.core.ruler.push("github-alert", (state) => {
        const tokens = state.tokens;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (token.type !== "blockquote_open")
            continue;
          let closeIdx = -1;
          let depth = 1;
          for (let j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "blockquote_open")
              depth++;
            if (tokens[j].type === "blockquote_close") {
              depth--;
              if (depth === 0) {
                closeIdx = j;
                break;
              }
            }
          }
          if (closeIdx === -1)
            continue;
          let firstInlineIdx = -1;
          for (let j = i + 1; j < closeIdx; j++) {
            if (tokens[j].type === "inline" && tokens[j].content) {
              firstInlineIdx = j;
              break;
            }
          }
          if (firstInlineIdx === -1)
            continue;
          const firstInline = tokens[firstInlineIdx];
          const content = firstInline.content;
          const alertResult = findAlertType(content);
          if (!alertResult)
            continue;
          const { config: alertConfig, restContent } = alertResult;
          token.type = "callout_open";
          token.tag = "section";
          token.attrSet("class", `callout callout-${alertConfig.cssClass}`);
          tokens[closeIdx].type = "callout_close";
          tokens[closeIdx].tag = "section";
          firstInline.content = restContent;
          if (firstInline.children && firstInline.children.length > 0) {
            const firstChild = firstInline.children[0];
            if (firstChild.type === "text") {
              const childResult = findAlertType(firstChild.content);
              if (childResult) {
                firstChild.content = childResult.restContent;
              }
            }
          }
          for (let j = i + 1; j < closeIdx; j++) {
            if (tokens[j].type === "paragraph_open") {
              const titleOpen = new token_1.default("callout_title_open", "div", 1);
              titleOpen.attrSet("class", "callout-title");
              const titleContent = new token_1.default("html_inline", "", 0);
              titleContent.content = `<span class="callout-icon">${alertConfig.icon}</span><span>${alertConfig.label}</span>`;
              const titleClose = new token_1.default("callout_title_close", "div", -1);
              tokens.splice(j, 0, titleOpen, titleContent, titleClose);
              break;
            }
          }
        }
      });
      md.renderer.rules.callout_open = (tokens, idx) => {
        const token = tokens[idx];
        const classAttr = token.attrGet("class") || "callout";
        return `<section class="${classAttr}">
`;
      };
      md.renderer.rules.callout_close = () => "</section>\n";
      md.renderer.rules.callout_title_open = (tokens, idx) => {
        const token = tokens[idx];
        const classAttr = token.attrGet("class") || "callout-title";
        return `<div class="${classAttr}">`;
      };
      md.renderer.rules.callout_title_close = () => "</div>\n";
    }
  }
});

// ../../node_modules/.pnpm/markdown-it-task-lists@2.1.1/node_modules/markdown-it-task-lists/index.js
var require_markdown_it_task_lists = __commonJS({
  "../../node_modules/.pnpm/markdown-it-task-lists@2.1.1/node_modules/markdown-it-task-lists/index.js"(exports, module2) {
    var disableCheckboxes = true;
    var useLabelWrapper = false;
    var useLabelAfter = false;
    module2.exports = function(md, options) {
      if (options) {
        disableCheckboxes = !options.enabled;
        useLabelWrapper = !!options.label;
        useLabelAfter = !!options.labelAfter;
      }
      md.core.ruler.after("inline", "github-task-lists", function(state) {
        var tokens = state.tokens;
        for (var i = 2; i < tokens.length; i++) {
          if (isTodoItem(tokens, i)) {
            todoify(tokens[i], state.Token);
            attrSet2(tokens[i - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
            attrSet2(tokens[parentToken(tokens, i - 2)], "class", "contains-task-list");
          }
        }
      });
    };
    function attrSet2(token, name, value) {
      var index = token.attrIndex(name);
      var attr = [name, value];
      if (index < 0) {
        token.attrPush(attr);
      } else {
        token.attrs[index] = attr;
      }
    }
    function parentToken(tokens, index) {
      var targetLevel = tokens[index].level - 1;
      for (var i = index - 1; i >= 0; i--) {
        if (tokens[i].level === targetLevel) {
          return i;
        }
      }
      return -1;
    }
    function isTodoItem(tokens, index) {
      return isInline(tokens[index]) && isParagraph(tokens[index - 1]) && isListItem(tokens[index - 2]) && startsWithTodoMarkdown(tokens[index]);
    }
    function todoify(token, TokenConstructor) {
      token.children.unshift(makeCheckbox(token, TokenConstructor));
      token.children[1].content = token.children[1].content.slice(3);
      token.content = token.content.slice(3);
      if (useLabelWrapper) {
        if (useLabelAfter) {
          token.children.pop();
          var id = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
          token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id + '">';
          token.children.push(afterLabel(token.content, id, TokenConstructor));
        } else {
          token.children.unshift(beginLabel(TokenConstructor));
          token.children.push(endLabel(TokenConstructor));
        }
      }
    }
    function makeCheckbox(token, TokenConstructor) {
      var checkbox = new TokenConstructor("html_inline", "", 0);
      var disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
      if (token.content.indexOf("[ ] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
      } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
      }
      return checkbox;
    }
    function beginLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "<label>";
      return token;
    }
    function endLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "</label>";
      return token;
    }
    function afterLabel(content, id, TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = '<label class="task-list-item-label" for="' + id + '">' + content + "</label>";
      token.attrs = [{ for: id }];
      return token;
    }
    function isInline(token) {
      return token.type === "inline";
    }
    function isParagraph(token) {
      return token.type === "paragraph_open";
    }
    function isListItem(token) {
      return token.type === "list_item_open";
    }
    function startsWithTodoMarkdown(token) {
      return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
    }
  }
});

// ../../packages/core/dist/plugins/markdown-it-checkbox-emoji.js
var require_markdown_it_checkbox_emoji = __commonJS({
  "../../packages/core/dist/plugins/markdown-it-checkbox-emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = markdownItCheckboxEmoji;
    function markdownItCheckboxEmoji(md) {
      const defaultRender = md.renderer.rules.html_inline;
      md.renderer.rules.html_inline = (tokens, idx, options, env, self2) => {
        const token = tokens[idx];
        const content = token.content;
        if (content.includes('type="checkbox"') || content.includes("type='checkbox'")) {
          if (content.includes("checked")) {
            return '<span style="font-size:1em;margin-right:4px">\u2705</span>';
          }
          return '<span style="font-size:1em;margin-right:4px">\u2B1C</span>';
        }
        if (defaultRender) {
          return defaultRender(tokens, idx, options, env, self2);
        }
        return content;
      };
    }
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/core.js"(exports, module2) {
    function deepFreeze(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach((name) => {
        const prop = obj[name];
        const type = typeof prop;
        if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
          deepFreeze(prop);
        }
      });
      return obj;
    }
    var Response = class {
      constructor(mode) {
        if (mode.data === void 0)
          mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    function escapeHTML(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit$1(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return result;
    }
    var SPAN_CLOSE = "</span>";
    var emitsWrappingTags = (node) => {
      return !!node.scope;
    };
    var scopeToCSSClass = (name, { prefix }) => {
      if (name.startsWith("language:")) {
        return name.replace("language:", "language-");
      }
      if (name.includes(".")) {
        const pieces = name.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name}`;
    };
    var HTMLRenderer = class {
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }
      addText(text) {
        this.buffer += escapeHTML(text);
      }
      openNode(node) {
        if (!emitsWrappingTags(node))
          return;
        const className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
        this.span(className);
      }
      closeNode(node) {
        if (!emitsWrappingTags(node))
          return;
        this.buffer += SPAN_CLOSE;
      }
      value() {
        return this.buffer;
      }
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    var newNode = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    var TokenTree = class {
      constructor() {
        this.rootNode = newNode();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      add(node) {
        this.top.children.push(node);
      }
      openNode(scope) {
        const node = newNode({ scope });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode())
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      walk(builder) {
        return this.constructor._walk(builder, this.rootNode);
      }
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }
      static _collapse(node) {
        if (typeof node === "string")
          return;
        if (!node.children)
          return;
        if (node.children.every((el) => typeof el === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            TokenTree._collapse(child);
          });
        }
      }
    };
    var TokenTreeEmitter = class extends TokenTree {
      constructor(options) {
        super();
        this.options = options;
      }
      addText(text) {
        if (text === "") {
          return;
        }
        this.add(text);
      }
      startScope(scope) {
        this.openNode(scope);
      }
      endScope() {
        this.closeNode();
      }
      __addSublanguage(emitter, name) {
        const node = emitter.root;
        if (name)
          node.scope = `language:${name}`;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }
      finalize() {
        this.closeAllNodes();
        return true;
      }
    };
    function source(re) {
      if (!re)
        return null;
      if (typeof re === "string")
        return re;
      return re.source;
    }
    function lookahead(re) {
      return concat("(?=", re, ")");
    }
    function anyNumberOfTimes(re) {
      return concat("(?:", re, ")*");
    }
    function optional(re) {
      return concat("(?:", re, ")?");
    }
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
      return joined;
    }
    function countMatchGroups(re) {
      return new RegExp(re.toString() + "|").exec("").length - 1;
    }
    function startsWith(re, lexeme) {
      const match = re && re.exec(lexeme);
      return match && match.index === 0;
    }
    var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences(regexps, { joinWith }) {
      let numCaptures = 0;
      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source(regex);
        let out = "";
        while (re.length > 0) {
          const match = BACKREF_RE.exec(re);
          if (!match) {
            out += re;
            break;
          }
          out += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] === "\\" && match[1]) {
            out += "\\" + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re) => `(${re})`).join(joinWith);
    }
    var MATCH_NOTHING_RE = /\b\B/;
    var IDENT_RE = "[a-zA-Z]\\w*";
    var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    var BINARY_NUMBER_RE = "\\b(0b[01]+)";
    var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    var SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
      }
      return inherit$1({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        "on:begin": (m, resp) => {
          if (m.index !== 0)
            resp.ignoreMatch();
        }
      }, opts);
    };
    var BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    var APOS_STRING_MODE = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var QUOTE_STRING_MODE = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    var COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1({
        scope: "comment",
        begin,
        end,
        contains: []
      }, modeOptions);
      mode.contains.push({
        scope: "doctag",
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
      mode.contains.push({
        begin: concat(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}")
      });
      return mode;
    };
    var C_LINE_COMMENT_MODE = COMMENT("//", "$");
    var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    var HASH_COMMENT_MODE = COMMENT("#", "$");
    var NUMBER_MODE = {
      scope: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    var C_NUMBER_MODE = {
      scope: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    var BINARY_NUMBER_MODE = {
      scope: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    var REGEXP_MODE = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    };
    var TITLE_MODE = {
      scope: "title",
      begin: IDENT_RE,
      relevance: 0
    };
    var UNDERSCORE_TITLE_MODE = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var METHOD_GUARD = {
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(mode, {
        "on:begin": (m, resp) => {
          resp.data._beginMatch = m[1];
        },
        "on:end": (m, resp) => {
          if (resp.data._beginMatch !== m[1])
            resp.ignoreMatch();
        }
      });
    };
    var MODES = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE,
      BACKSLASH_ESCAPE,
      BINARY_NUMBER_MODE,
      BINARY_NUMBER_RE,
      COMMENT,
      C_BLOCK_COMMENT_MODE,
      C_LINE_COMMENT_MODE,
      C_NUMBER_MODE,
      C_NUMBER_RE,
      END_SAME_AS_BEGIN,
      HASH_COMMENT_MODE,
      IDENT_RE,
      MATCH_NOTHING_RE,
      METHOD_GUARD,
      NUMBER_MODE,
      NUMBER_RE,
      PHRASAL_WORDS_MODE,
      QUOTE_STRING_MODE,
      REGEXP_MODE,
      RE_STARTERS_RE,
      SHEBANG,
      TITLE_MODE,
      UNDERSCORE_IDENT_RE,
      UNDERSCORE_TITLE_MODE
    });
    function skipIfHasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function scopeClassName(mode, _parent) {
      if (mode.className !== void 0) {
        mode.scope = mode.className;
        delete mode.className;
      }
    }
    function beginKeywords(mode, parent) {
      if (!parent)
        return;
      if (!mode.beginKeywords)
        return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfHasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0)
        mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal))
        return;
      mode.illegal = either(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
      if (!mode.match)
        return;
      if (mode.begin || mode.end)
        throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance(mode, _parent) {
      if (mode.relevance === void 0)
        mode.relevance = 1;
    }
    var beforeMatchExt = (mode, parent) => {
      if (!mode.beforeMatch)
        return;
      if (mode.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key) => {
        delete mode[key];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    var COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      "list",
      "value"
    ];
    var DEFAULT_KEYWORD_SCOPE = "keyword";
    function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
      const compiledKeywords = /* @__PURE__ */ Object.create(null);
      if (typeof rawKeywords === "string") {
        compileList(scopeName, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(scopeName, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(scopeName2) {
          Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
        });
      }
      return compiledKeywords;
      function compileList(scopeName2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x) => x.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split("|");
          compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }
    function scoreForKeyword(keyword, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword(keyword) ? 0 : 1;
    }
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }
    var seenDeprecations = {};
    var error = (message) => {
      console.error(message);
    };
    var warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    var deprecated = (version2, message) => {
      if (seenDeprecations[`${version2}/${message}`])
        return;
      console.log(`Deprecated as of ${version2}. ${message}`);
      seenDeprecations[`${version2}/${message}`] = true;
    };
    var MultiClassError = new Error();
    function remapScopeNames(mode, regexes, { key }) {
      let offset = 0;
      const scopeNames = mode[key];
      const emit = {};
      const positions = {};
      for (let i = 1; i <= regexes.length; i++) {
        positions[i + offset] = scopeNames[i];
        emit[i + offset] = true;
        offset += countMatchGroups(regexes[i - 1]);
      }
      mode[key] = positions;
      mode[key]._emit = emit;
      mode[key]._multi = true;
    }
    function beginMultiClass(mode) {
      if (!Array.isArray(mode.begin))
        return;
      if (mode.skip || mode.excludeBegin || mode.returnBegin) {
        error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
        error("beginScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.begin, { key: "beginScope" });
      mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
    }
    function endMultiClass(mode) {
      if (!Array.isArray(mode.end))
        return;
      if (mode.skip || mode.excludeEnd || mode.returnEnd) {
        error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.endScope !== "object" || mode.endScope === null) {
        error("endScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.end, { key: "endScope" });
      mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
    }
    function scopeSugar(mode) {
      if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
        mode.beginScope = mode.scope;
        delete mode.scope;
      }
    }
    function MultiClass(mode) {
      scopeSugar(mode);
      if (typeof mode.beginScope === "string") {
        mode.beginScope = { _wrap: mode.beginScope };
      }
      if (typeof mode.endScope === "string") {
        mode.endScope = { _wrap: mode.endScope };
      }
      beginMultiClass(mode);
      endMultiClass(mode);
    }
    function compileLanguage(language) {
      function langRe(value, global2) {
        return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : ""));
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        addRule(re, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el) => el[1]);
          this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
          this.lastIndex = 0;
        }
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) {
            return null;
          }
          const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
          const matchData = this.matchIndexes[i];
          match.splice(0, i);
          return Object.assign(match, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        getMatcher(index) {
          if (this.multiRegexes[index])
            return this.multiRegexes[index];
          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin")
            this.count++;
        }
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex)
              ;
            else {
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = mode;
        if (mode.isCompiled)
          return cmode;
        [
          scopeClassName,
          compileMatch,
          MultiClass,
          beforeMatchExt
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords,
          compileIllegal,
          compileRelevance
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
          mode.keywords = Object.assign({}, mode.keywords);
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        keywordPattern = keywordPattern || /\w+/;
        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin)
            mode.begin = /\B|\b/;
          cmode.beginRe = langRe(cmode.begin);
          if (!mode.end && !mode.endsWithParent)
            mode.end = /\B|\b/;
          if (mode.end)
            cmode.endRe = langRe(cmode.end);
          cmode.terminatorEnd = source(cmode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal)
          cmode.illegalRe = langRe(mode.illegal);
        if (!mode.contains)
          mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === "self" ? mode : c);
        }));
        mode.contains.forEach(function(c) {
          compileMode(c, cmode);
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions)
        language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit$1(language.classNameAliases || {});
      return compileMode(language);
    }
    function dependencyOnParent(mode) {
      if (!mode)
        return false;
      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$1(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent(mode)) {
        return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit$1(mode);
      }
      return mode;
    }
    var version = "11.11.1";
    var HTMLInjectionError = class extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    };
    var escape = escapeHTML;
    var inherit = inherit$1;
    var NO_MATCH = Symbol("nomatch");
    var MAX_KEYWORD_HITS = 7;
    var HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }
      function blockLanguage(block) {
        let classes = block.className + " ";
        classes += block.parentNode ? block.parentNode.className : "";
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }
      function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top, word);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS)
                relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "")
            return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.__addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitKeyword(keyword, scope) {
          if (keyword === "")
            return;
          emitter.startScope(scope);
          emitter.addText(keyword);
          emitter.endScope();
        }
        function emitMultiClass(scope, match) {
          let i = 1;
          const max = match.length - 1;
          while (i <= max) {
            if (!scope._emit[i]) {
              i++;
              continue;
            }
            const klass = language.classNameAliases[scope[i]] || scope[i];
            const text = match[i];
            if (klass) {
              emitKeyword(text, klass);
            } else {
              modeBuffer = text;
              processKeywords();
              modeBuffer = "";
            }
            i++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored)
                matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb)
              continue;
            cb(match, resp);
            if (resp.isMatchIgnored)
              return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin = top;
          if (top.endScope && top.endScope._wrap) {
            processBuffer();
            emitKeyword(lexeme, top.endScope._wrap);
          } else if (top.endScope && top.endScope._multi) {
            processBuffer();
            emitMultiClass(top.endScope, match);
          } else if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.scope) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.scope) {
              list.unshift(current.scope);
            }
          }
          list.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            modeBuffer += "\n";
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language);
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          if (!language.__emitTokens) {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index;
              const match = top.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index));
          } else {
            language.__emitTokens(codeToHighlight, emitter);
          }
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code) {
        const result = {
          value: escape(code),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options.__emitter(options)
        };
        result._emitter.addText(code);
        return result;
      }
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
        results.unshift(plaintext);
        const sorted = results.sort((a, b) => {
          if (a.relevance !== b.relevance)
            return b.relevance - a.relevance;
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language))
          return;
        fire("before:highlightElement", { el: element, language });
        if (element.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
          return;
        }
        if (element.children.length > 0) {
          if (!options.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options.throwUnescapedHTML) {
            const err = new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element.innerHTML);
            throw err;
          }
        }
        node = element;
        const text = node.textContent;
        const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
        element.innerHTML = result.value;
        element.dataset.highlighted = "yes";
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text });
      }
      function configure(userOptions) {
        options = inherit(options, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        function boot() {
          highlightAll();
        }
        if (document.readyState === "loading") {
          if (!wantsHighlight) {
            window.addEventListener("DOMContentLoaded", boot, false);
          }
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options.cssSelector);
        blocks.forEach(highlightElement);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name)
          lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name) {
        name = (name || "").toLowerCase();
        return languages[name] || languages[aliases[name]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name) {
        const lang = getLanguage(name);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }
      function removePlugin(plugin) {
        const index = plugins.indexOf(plugin);
        if (index !== -1) {
          plugins.splice(index, 1);
        }
      }
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        highlightElement,
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit,
        addPlugin,
        removePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version;
      hljs.regex = {
        concat,
        lookahead,
        either,
        optional,
        anyNumberOfTimes
      };
      for (const key in MODES) {
        if (typeof MODES[key] === "object") {
          deepFreeze(MODES[key]);
        }
      }
      Object.assign(hljs, MODES);
      return hljs;
    };
    var highlight = HLJS({});
    highlight.newInstance = () => HLJS({});
    module2.exports = highlight;
    highlight.HighlightJS = highlight;
    highlight.default = highlight;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/bash.js
var require_bash = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/bash.js"(exports, module2) {
    function bash(hljs) {
      const regex = hljs.regex;
      const VAR = {};
      const BRACED_VAR = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [VAR]
          }
        ]
      };
      Object.assign(VAR, {
        className: "variable",
        variants: [
          { begin: regex.concat(/\$[\w\d#@][\w\d_]*/, `(?![\\w\\d])(?![$])`) },
          BRACED_VAR
        ]
      });
      const SUBST = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [hljs.BACKSLASH_ESCAPE]
      };
      const COMMENT = hljs.inherit(hljs.COMMENT(), {
        match: [
          /(^|\s)/,
          /#.*$/
        ],
        scope: {
          2: "comment"
        }
      });
      const HERE_DOC = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      };
      const QUOTE_STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VAR,
          SUBST
        ]
      };
      SUBST.contains.push(QUOTE_STRING);
      const ESCAPED_QUOTE = {
        match: /\\"/
      };
      const APOS_STRING = {
        className: "string",
        begin: /'/,
        end: /'/
      };
      const ESCAPED_APOS = {
        match: /\\'/
      };
      const ARITHMETIC = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          hljs.NUMBER_MODE,
          VAR
        ]
      };
      const SH_LIKE_SHELLS = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ];
      const KNOWN_SHEBANG = hljs.SHEBANG({
        binary: `(${SH_LIKE_SHELLS.join("|")})`,
        relevance: 10
      });
      const FUNCTION = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      };
      const KEYWORDS = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ];
      const LITERALS = [
        "true",
        "false"
      ];
      const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
      const SHELL_BUILT_INS = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ];
      const BASH_BUILT_INS = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ];
      const ZSH_BUILT_INS = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ];
      const GNU_CORE_UTILS = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: [
            ...SHELL_BUILT_INS,
            ...BASH_BUILT_INS,
            "set",
            "shopt",
            ...ZSH_BUILT_INS,
            ...GNU_CORE_UTILS
          ]
        },
        contains: [
          KNOWN_SHEBANG,
          hljs.SHEBANG(),
          FUNCTION,
          ARITHMETIC,
          COMMENT,
          HERE_DOC,
          PATH_MODE,
          QUOTE_STRING,
          ESCAPED_QUOTE,
          APOS_STRING,
          ESCAPED_APOS,
          VAR
        ]
      };
    }
    module2.exports = bash;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/clojure.js
var require_clojure = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/clojure.js"(exports, module2) {
    function clojure(hljs) {
      const SYMBOLSTART = "a-zA-Z_\\-!.?+*=<>&'";
      const SYMBOL_RE = "[#]?[" + SYMBOLSTART + "][" + SYMBOLSTART + "0-9/;:$#]*";
      const globals = "def defonce defprotocol defstruct defmulti defmethod defn- defn defmacro deftype defrecord";
      const keywords = {
        $pattern: SYMBOL_RE,
        built_in: globals + " cond apply if-not if-let if not not= =|0 <|0 >|0 <=|0 >=|0 ==|0 +|0 /|0 *|0 -|0 rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy first rest cons cast coll last butlast sigs reify second ffirst fnext nfirst nnext meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"
      };
      const SYMBOL = {
        begin: SYMBOL_RE,
        relevance: 0
      };
      const NUMBER = {
        scope: "number",
        relevance: 0,
        variants: [
          { match: /[-+]?0[xX][0-9a-fA-F]+N?/ },
          { match: /[-+]?0[0-7]+N?/ },
          { match: /[-+]?[1-9][0-9]?[rR][0-9a-zA-Z]+N?/ },
          { match: /[-+]?[0-9]+\/[0-9]+N?/ },
          { match: /[-+]?[0-9]+((\.[0-9]*([eE][+-]?[0-9]+)?M?)|([eE][+-]?[0-9]+M?|M))/ },
          { match: /[-+]?([1-9][0-9]*|0)N?/ }
        ]
      };
      const CHARACTER = {
        scope: "character",
        variants: [
          { match: /\\o[0-3]?[0-7]{1,2}/ },
          { match: /\\u[0-9a-fA-F]{4}/ },
          { match: /\\(newline|space|tab|formfeed|backspace|return)/ },
          {
            match: /\\\S/,
            relevance: 0
          }
        ]
      };
      const REGEX = {
        scope: "regex",
        begin: /#"/,
        end: /"/,
        contains: [hljs.BACKSLASH_ESCAPE]
      };
      const STRING = hljs.inherit(hljs.QUOTE_STRING_MODE, { illegal: null });
      const COMMA = {
        scope: "punctuation",
        match: /,/,
        relevance: 0
      };
      const COMMENT = hljs.COMMENT(";", "$", { relevance: 0 });
      const LITERAL = {
        className: "literal",
        begin: /\b(true|false|nil)\b/
      };
      const COLLECTION = {
        begin: "\\[|(#::?" + SYMBOL_RE + ")?\\{",
        end: "[\\]\\}]",
        relevance: 0
      };
      const KEY = {
        className: "symbol",
        begin: "[:]{1,2}" + SYMBOL_RE
      };
      const LIST = {
        begin: "\\(",
        end: "\\)"
      };
      const BODY = {
        endsWithParent: true,
        relevance: 0
      };
      const NAME = {
        keywords,
        className: "name",
        begin: SYMBOL_RE,
        relevance: 0,
        starts: BODY
      };
      const DEFAULT_CONTAINS = [
        COMMA,
        LIST,
        CHARACTER,
        REGEX,
        STRING,
        COMMENT,
        KEY,
        COLLECTION,
        NUMBER,
        LITERAL,
        SYMBOL
      ];
      const GLOBAL = {
        beginKeywords: globals,
        keywords: {
          $pattern: SYMBOL_RE,
          keyword: globals
        },
        end: '(\\[|#|\\d|"|:|\\{|\\)|\\(|$)',
        contains: [
          {
            className: "title",
            begin: SYMBOL_RE,
            relevance: 0,
            excludeEnd: true,
            endsParent: true
          }
        ].concat(DEFAULT_CONTAINS)
      };
      LIST.contains = [
        GLOBAL,
        NAME,
        BODY
      ];
      BODY.contains = DEFAULT_CONTAINS;
      COLLECTION.contains = DEFAULT_CONTAINS;
      return {
        name: "Clojure",
        aliases: [
          "clj",
          "edn"
        ],
        illegal: /\S/,
        contains: [
          COMMA,
          LIST,
          CHARACTER,
          REGEX,
          STRING,
          COMMENT,
          KEY,
          COLLECTION,
          NUMBER,
          LITERAL
        ]
      };
    }
    module2.exports = clojure;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/cpp.js
var require_cpp = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/cpp.js"(exports, module2) {
    function cpp(hljs) {
      const regex = hljs.regex;
      const C_LINE_COMMENT_MODE = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
      const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
      const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
      const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
      const FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
      const CPP_PRIMITIVE_TYPES = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      };
      const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
      const STRINGS = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
            end: "'",
            illegal: "."
          },
          hljs.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      };
      const NUMBERS = {
        className: "number",
        variants: [
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
          }
        ],
        relevance: 0
      };
      const PREPROCESSOR = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          hljs.inherit(STRINGS, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      };
      const TITLE_MODE = {
        className: "title",
        begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE,
        relevance: 0
      };
      const FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
      const RESERVED_KEYWORDS = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ];
      const RESERVED_TYPES = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ];
      const TYPE_HINTS = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ];
      const FUNCTION_HINTS = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ];
      const LITERALS = [
        "NULL",
        "false",
        "nullopt",
        "nullptr",
        "true"
      ];
      const BUILT_IN = ["_Pragma"];
      const CPP_KEYWORDS = {
        type: RESERVED_TYPES,
        keyword: RESERVED_KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_IN,
        _type_hints: TYPE_HINTS
      };
      const FUNCTION_DISPATCH = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          _hint: FUNCTION_HINTS
        },
        begin: regex.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex.lookahead(/(<[^<>]+>|)\s*\(/))
      };
      const EXPRESSION_CONTAINS = [
        FUNCTION_DISPATCH,
        PREPROCESSOR,
        CPP_PRIMITIVE_TYPES,
        C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        NUMBERS,
        STRINGS
      ];
      const EXPRESSION_CONTEXT = {
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            contains: EXPRESSION_CONTAINS.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      };
      const FUNCTION_DECLARATION = {
        className: "function",
        begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: CPP_KEYWORDS,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            begin: DECLTYPE_AUTO_RE,
            keywords: CPP_KEYWORDS,
            relevance: 0
          },
          {
            begin: FUNCTION_TITLE,
            returnBegin: true,
            contains: [TITLE_MODE],
            relevance: 0
          },
          {
            begin: /::/,
            relevance: 0
          },
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              STRINGS,
              NUMBERS
            ]
          },
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES,
              {
                begin: /\(/,
                end: /\)/,
                keywords: CPP_KEYWORDS,
                relevance: 0,
                contains: [
                  "self",
                  C_LINE_COMMENT_MODE,
                  hljs.C_BLOCK_COMMENT_MODE,
                  STRINGS,
                  NUMBERS,
                  CPP_PRIMITIVE_TYPES
                ]
              }
            ]
          },
          CPP_PRIMITIVE_TYPES,
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          PREPROCESSOR
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: CPP_KEYWORDS,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [
          PREPROCESSOR,
          {
            begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
            end: ">",
            keywords: CPP_KEYWORDS,
            contains: [
              "self",
              CPP_PRIMITIVE_TYPES
            ]
          },
          {
            begin: hljs.IDENT_RE + "::",
            keywords: CPP_KEYWORDS
          },
          {
            match: [
              /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
              /\s+/,
              /\w+/
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          }
        ])
      };
    }
    module2.exports = cpp;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/csharp.js
var require_csharp = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/csharp.js"(exports, module2) {
    function csharp(hljs) {
      const BUILT_IN_KEYWORDS = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ];
      const FUNCTION_MODIFIERS = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ];
      const LITERAL_KEYWORDS = [
        "default",
        "false",
        "null",
        "true"
      ];
      const NORMAL_KEYWORDS = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ];
      const CONTEXTUAL_KEYWORDS = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ];
      const KEYWORDS = {
        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
        built_in: BUILT_IN_KEYWORDS,
        literal: LITERAL_KEYWORDS
      };
      const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" });
      const NUMBERS = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      };
      const RAW_STRING = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      };
      const VERBATIM_STRING = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      };
      const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, { illegal: /\n/ });
      const SUBST = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS
      };
      const SUBST_NO_LF = hljs.inherit(SUBST, { illegal: /\n/ });
      const INTERPOLATED_STRING = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          hljs.BACKSLASH_ESCAPE,
          SUBST_NO_LF
        ]
      };
      const INTERPOLATED_VERBATIM_STRING = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          SUBST
        ]
      };
      const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          SUBST_NO_LF
        ]
      });
      SUBST.contains = [
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      SUBST_NO_LF.contains = [
        INTERPOLATED_VERBATIM_STRING_NO_LF,
        INTERPOLATED_STRING,
        VERBATIM_STRING_NO_LF,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const STRING = { variants: [
        RAW_STRING,
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ] };
      const GENERIC_MODIFIER = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          TITLE_MODE
        ]
      };
      const TYPE_IDENT_RE = hljs.IDENT_RE + "(<" + hljs.IDENT_RE + "(\\s*,\\s*" + hljs.IDENT_RE + ")*>)?(\\[\\])?";
      const AT_IDENTIFIER = {
        begin: "@" + hljs.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: KEYWORDS,
        illegal: /::/,
        contains: [
          hljs.COMMENT("///", "$", {
            returnBegin: true,
            contains: [
              {
                className: "doctag",
                variants: [
                  {
                    begin: "///",
                    relevance: 0
                  },
                  { begin: "<!--|-->" },
                  {
                    begin: "</?",
                    end: ">"
                  }
                ]
              }
            ]
          }),
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          STRING,
          NUMBERS,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + TYPE_IDENT_RE + "\\s+)+" + hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              {
                beginKeywords: FUNCTION_MODIFIERS.join(" "),
                relevance: 0
              },
              {
                begin: hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  hljs.TITLE_MODE,
                  GENERIC_MODIFIER
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  STRING,
                  NUMBERS,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          AT_IDENTIFIER
        ]
      };
    }
    module2.exports = csharp;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/css.js
var require_css = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/css.js"(exports, module2) {
    var MODES = (hljs) => {
      return {
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: {
          className: "attr",
          begin: /--[A-Za-z_][A-Za-z0-9_-]*/
        }
      };
    };
    var HTML_TAGS = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ];
    var SVG_TAGS = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ];
    var TAGS = [
      ...HTML_TAGS,
      ...SVG_TAGS
    ];
    var MEDIA_FEATURES = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse();
    var PSEUDO_CLASSES = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      "host",
      "host-context",
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      "lang",
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      "nth-child",
      "nth-col",
      "nth-last-child",
      "nth-last-col",
      "nth-last-of-type",
      "nth-of-type",
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
    ].sort().reverse();
    var PSEUDO_ELEMENTS = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse();
    var ATTRIBUTES = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function css(hljs) {
      const regex = hljs.regex;
      const modes = MODES(hljs);
      const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
      const AT_MODIFIERS = "and or not only";
      const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
      const IDENT_RE = "[a-zA-Z-][a-zA-Z0-9_-]*";
      const STRINGS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          keyframePosition: "selector-tag"
        },
        contains: [
          modes.BLOCK_COMMENT,
          VENDOR_PREFIX,
          modes.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + IDENT_RE,
            relevance: 0
          },
          modes.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + PSEUDO_CLASSES.join("|") + ")" },
              { begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")" }
            ]
          },
          modes.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
          },
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              modes.BLOCK_COMMENT,
              modes.HEXCOLOR,
              modes.IMPORTANT,
              modes.CSS_NUMBER_MODE,
              ...STRINGS,
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...STRINGS,
                  {
                    className: "string",
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              modes.FUNCTION_DISPATCH
            ]
          },
          {
            begin: regex.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            contains: [
              {
                className: "keyword",
                begin: AT_PROPERTY_RE
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: AT_MODIFIERS,
                  attribute: MEDIA_FEATURES.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...STRINGS,
                  modes.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + TAGS.join("|") + ")\\b"
          }
        ]
      };
    }
    module2.exports = css;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/dart.js
var require_dart = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/dart.js"(exports, module2) {
    function dart(hljs) {
      const SUBST = {
        className: "subst",
        variants: [{ begin: "\\$[A-Za-z0-9_]+" }]
      };
      const BRACED_SUBST = {
        className: "subst",
        variants: [
          {
            begin: /\$\{/,
            end: /\}/
          }
        ],
        keywords: "true false null this is new super"
      };
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          { match: /\b[0-9][0-9_]*(\.[0-9][0-9_]*)?([eE][+-]?[0-9][0-9_]*)?\b/ },
          { match: /\b0[xX][0-9A-Fa-f][0-9A-Fa-f_]*\b/ }
        ]
      };
      const STRING = {
        className: "string",
        variants: [
          {
            begin: "r'''",
            end: "'''"
          },
          {
            begin: 'r"""',
            end: '"""'
          },
          {
            begin: "r'",
            end: "'",
            illegal: "\\n"
          },
          {
            begin: 'r"',
            end: '"',
            illegal: "\\n"
          },
          {
            begin: "'''",
            end: "'''",
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST,
              BRACED_SUBST
            ]
          },
          {
            begin: '"""',
            end: '"""',
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST,
              BRACED_SUBST
            ]
          },
          {
            begin: "'",
            end: "'",
            illegal: "\\n",
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST,
              BRACED_SUBST
            ]
          },
          {
            begin: '"',
            end: '"',
            illegal: "\\n",
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST,
              BRACED_SUBST
            ]
          }
        ]
      };
      BRACED_SUBST.contains = [
        NUMBER,
        STRING
      ];
      const BUILT_IN_TYPES = [
        "Comparable",
        "DateTime",
        "Duration",
        "Function",
        "Iterable",
        "Iterator",
        "List",
        "Map",
        "Match",
        "Object",
        "Pattern",
        "RegExp",
        "Set",
        "Stopwatch",
        "String",
        "StringBuffer",
        "StringSink",
        "Symbol",
        "Type",
        "Uri",
        "bool",
        "double",
        "int",
        "num",
        "Element",
        "ElementList"
      ];
      const NULLABLE_BUILT_IN_TYPES = BUILT_IN_TYPES.map((e) => `${e}?`);
      const BASIC_KEYWORDS = [
        "abstract",
        "as",
        "assert",
        "async",
        "await",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "covariant",
        "default",
        "deferred",
        "do",
        "dynamic",
        "else",
        "enum",
        "export",
        "extends",
        "extension",
        "external",
        "factory",
        "false",
        "final",
        "finally",
        "for",
        "Function",
        "get",
        "hide",
        "if",
        "implements",
        "import",
        "in",
        "interface",
        "is",
        "late",
        "library",
        "mixin",
        "new",
        "null",
        "on",
        "operator",
        "part",
        "required",
        "rethrow",
        "return",
        "sealed",
        "set",
        "show",
        "static",
        "super",
        "switch",
        "sync",
        "this",
        "throw",
        "true",
        "try",
        "typedef",
        "var",
        "void",
        "when",
        "while",
        "with",
        "yield"
      ];
      const KEYWORDS = {
        keyword: BASIC_KEYWORDS,
        built_in: BUILT_IN_TYPES.concat(NULLABLE_BUILT_IN_TYPES).concat([
          "Never",
          "Null",
          "dynamic",
          "print",
          "document",
          "querySelector",
          "querySelectorAll",
          "window"
        ]),
        $pattern: /[A-Za-z][A-Za-z0-9_]*\??/
      };
      return {
        name: "Dart",
        keywords: KEYWORDS,
        contains: [
          STRING,
          hljs.COMMENT(/\/\*\*(?!\/)/, /\*\//, {
            subLanguage: "markdown",
            relevance: 0
          }),
          hljs.COMMENT(/\/{3,} ?/, /$/, { contains: [
            {
              subLanguage: "markdown",
              begin: ".",
              end: "$",
              relevance: 0
            }
          ] }),
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: "class",
            beginKeywords: "class interface",
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          NUMBER,
          {
            className: "meta",
            begin: "@[A-Za-z]+"
          },
          {
            begin: "=>"
          }
        ]
      };
    }
    module2.exports = dart;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/dockerfile.js
var require_dockerfile = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/dockerfile.js"(exports, module2) {
    function dockerfile(hljs) {
      const KEYWORDS = [
        "from",
        "maintainer",
        "expose",
        "env",
        "arg",
        "user",
        "onbuild",
        "stopsignal"
      ];
      return {
        name: "Dockerfile",
        aliases: ["docker"],
        case_insensitive: true,
        keywords: KEYWORDS,
        contains: [
          hljs.HASH_COMMENT_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          {
            beginKeywords: "run cmd entrypoint volume add copy workdir label healthcheck shell",
            starts: {
              end: /[^\\]$/,
              subLanguage: "bash"
            }
          }
        ],
        illegal: "</"
      };
    }
    module2.exports = dockerfile;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/erlang.js
var require_erlang = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/erlang.js"(exports, module2) {
    function erlang(hljs) {
      const BASIC_ATOM_RE = "[a-z'][a-zA-Z0-9_']*";
      const FUNCTION_NAME_RE = "(" + BASIC_ATOM_RE + ":" + BASIC_ATOM_RE + "|" + BASIC_ATOM_RE + ")";
      const ERLANG_RESERVED = {
        keyword: "after and andalso|10 band begin bnot bor bsl bzr bxor case catch cond div end fun if let not of orelse|10 query receive rem try when xor maybe else",
        literal: "false true"
      };
      const COMMENT = hljs.COMMENT("%", "$");
      const NUMBER = {
        className: "number",
        begin: "\\b(\\d+(_\\d+)*#[a-fA-F0-9]+(_[a-fA-F0-9]+)*|\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?([eE][-+]?\\d+)?)",
        relevance: 0
      };
      const NAMED_FUN = { begin: "fun\\s+" + BASIC_ATOM_RE + "/\\d+" };
      const FUNCTION_CALL = {
        begin: FUNCTION_NAME_RE + "\\(",
        end: "\\)",
        returnBegin: true,
        relevance: 0,
        contains: [
          {
            begin: FUNCTION_NAME_RE,
            relevance: 0
          },
          {
            begin: "\\(",
            end: "\\)",
            endsWithParent: true,
            returnEnd: true,
            relevance: 0
          }
        ]
      };
      const TUPLE = {
        begin: /\{/,
        end: /\}/,
        relevance: 0
      };
      const VAR1 = {
        begin: "\\b_([A-Z][A-Za-z0-9_]*)?",
        relevance: 0
      };
      const VAR2 = {
        begin: "[A-Z][a-zA-Z0-9_]*",
        relevance: 0
      };
      const RECORD_ACCESS = {
        begin: "#" + hljs.UNDERSCORE_IDENT_RE,
        relevance: 0,
        returnBegin: true,
        contains: [
          {
            begin: "#" + hljs.UNDERSCORE_IDENT_RE,
            relevance: 0
          },
          {
            begin: /\{/,
            end: /\}/,
            relevance: 0
          }
        ]
      };
      const CHAR_LITERAL = {
        scope: "string",
        match: /\$(\\([^0-9]|[0-9]{1,3}|)|.)/
      };
      const TRIPLE_QUOTE = {
        scope: "string",
        match: /"""("*)(?!")[\s\S]*?"""\1/
      };
      const SIGIL = {
        scope: "string",
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          { match: /~\w?"""("*)(?!")[\s\S]*?"""\1/ },
          { begin: /~\w?\(/, end: /\)/ },
          { begin: /~\w?\[/, end: /\]/ },
          { begin: /~\w?{/, end: /}/ },
          { begin: /~\w?</, end: />/ },
          { begin: /~\w?\//, end: /\// },
          { begin: /~\w?\|/, end: /\|/ },
          { begin: /~\w?'/, end: /'/ },
          { begin: /~\w?"/, end: /"/ },
          { begin: /~\w?`/, end: /`/ },
          { begin: /~\w?#/, end: /#/ }
        ]
      };
      const BLOCK_STATEMENTS = {
        beginKeywords: "fun receive if try case maybe",
        end: "end",
        keywords: ERLANG_RESERVED
      };
      BLOCK_STATEMENTS.contains = [
        COMMENT,
        NAMED_FUN,
        hljs.inherit(hljs.APOS_STRING_MODE, { className: "" }),
        BLOCK_STATEMENTS,
        FUNCTION_CALL,
        SIGIL,
        TRIPLE_QUOTE,
        hljs.QUOTE_STRING_MODE,
        NUMBER,
        TUPLE,
        VAR1,
        VAR2,
        RECORD_ACCESS,
        CHAR_LITERAL
      ];
      const BASIC_MODES = [
        COMMENT,
        NAMED_FUN,
        BLOCK_STATEMENTS,
        FUNCTION_CALL,
        SIGIL,
        TRIPLE_QUOTE,
        hljs.QUOTE_STRING_MODE,
        NUMBER,
        TUPLE,
        VAR1,
        VAR2,
        RECORD_ACCESS,
        CHAR_LITERAL
      ];
      FUNCTION_CALL.contains[1].contains = BASIC_MODES;
      TUPLE.contains = BASIC_MODES;
      RECORD_ACCESS.contains[1].contains = BASIC_MODES;
      const DIRECTIVES = [
        "-module",
        "-record",
        "-undef",
        "-export",
        "-ifdef",
        "-ifndef",
        "-author",
        "-copyright",
        "-doc",
        "-moduledoc",
        "-vsn",
        "-import",
        "-include",
        "-include_lib",
        "-compile",
        "-define",
        "-else",
        "-endif",
        "-file",
        "-behaviour",
        "-behavior",
        "-spec",
        "-on_load",
        "-nifs"
      ];
      const PARAMS = {
        className: "params",
        begin: "\\(",
        end: "\\)",
        contains: BASIC_MODES
      };
      return {
        name: "Erlang",
        aliases: ["erl"],
        keywords: ERLANG_RESERVED,
        illegal: "(</|\\*=|\\+=|-=|/\\*|\\*/|\\(\\*|\\*\\))",
        contains: [
          {
            className: "function",
            begin: "^" + BASIC_ATOM_RE + "\\s*\\(",
            end: "->",
            returnBegin: true,
            illegal: "\\(|#|//|/\\*|\\\\|:|;",
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: BASIC_ATOM_RE })
            ],
            starts: {
              end: ";|\\.",
              keywords: ERLANG_RESERVED,
              contains: BASIC_MODES
            }
          },
          COMMENT,
          {
            begin: "^-",
            end: "\\.",
            relevance: 0,
            excludeEnd: true,
            returnBegin: true,
            keywords: {
              $pattern: "-" + hljs.IDENT_RE,
              keyword: DIRECTIVES.map((x) => `${x}|1.5`).join(" ")
            },
            contains: [
              PARAMS,
              SIGIL,
              TRIPLE_QUOTE,
              hljs.QUOTE_STRING_MODE
            ]
          },
          NUMBER,
          SIGIL,
          TRIPLE_QUOTE,
          hljs.QUOTE_STRING_MODE,
          RECORD_ACCESS,
          VAR1,
          VAR2,
          TUPLE,
          CHAR_LITERAL,
          { begin: /\.$/ }
        ]
      };
    }
    module2.exports = erlang;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/go.js
var require_go = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/go.js"(exports, module2) {
    function go(hljs) {
      const LITERALS = [
        "true",
        "false",
        "iota",
        "nil"
      ];
      const BUILT_INS = [
        "append",
        "cap",
        "close",
        "complex",
        "copy",
        "imag",
        "len",
        "make",
        "new",
        "panic",
        "print",
        "println",
        "real",
        "recover",
        "delete"
      ];
      const TYPES = [
        "bool",
        "byte",
        "complex64",
        "complex128",
        "error",
        "float32",
        "float64",
        "int8",
        "int16",
        "int32",
        "int64",
        "string",
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "int",
        "uint",
        "uintptr",
        "rune"
      ];
      const KWS = [
        "break",
        "case",
        "chan",
        "const",
        "continue",
        "default",
        "defer",
        "else",
        "fallthrough",
        "for",
        "func",
        "go",
        "goto",
        "if",
        "import",
        "interface",
        "map",
        "package",
        "range",
        "return",
        "select",
        "struct",
        "switch",
        "type",
        "var"
      ];
      const KEYWORDS = {
        keyword: KWS,
        type: TYPES,
        literal: LITERALS,
        built_in: BUILT_INS
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: KEYWORDS,
        illegal: "</",
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              hljs.QUOTE_STRING_MODE,
              hljs.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              hljs.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    module2.exports = go;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/gradle.js
var require_gradle = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/gradle.js"(exports, module2) {
    function gradle(hljs) {
      const KEYWORDS = [
        "task",
        "project",
        "allprojects",
        "subprojects",
        "artifacts",
        "buildscript",
        "configurations",
        "dependencies",
        "repositories",
        "sourceSets",
        "description",
        "delete",
        "from",
        "into",
        "include",
        "exclude",
        "source",
        "classpath",
        "destinationDir",
        "includes",
        "options",
        "sourceCompatibility",
        "targetCompatibility",
        "group",
        "flatDir",
        "doLast",
        "doFirst",
        "flatten",
        "todir",
        "fromdir",
        "ant",
        "def",
        "abstract",
        "break",
        "case",
        "catch",
        "continue",
        "default",
        "do",
        "else",
        "extends",
        "final",
        "finally",
        "for",
        "if",
        "implements",
        "instanceof",
        "native",
        "new",
        "private",
        "protected",
        "public",
        "return",
        "static",
        "switch",
        "synchronized",
        "throw",
        "throws",
        "transient",
        "try",
        "volatile",
        "while",
        "strictfp",
        "package",
        "import",
        "false",
        "null",
        "super",
        "this",
        "true",
        "antlrtask",
        "checkstyle",
        "codenarc",
        "copy",
        "boolean",
        "byte",
        "char",
        "class",
        "double",
        "float",
        "int",
        "interface",
        "long",
        "short",
        "void",
        "compile",
        "runTime",
        "file",
        "fileTree",
        "abs",
        "any",
        "append",
        "asList",
        "asWritable",
        "call",
        "collect",
        "compareTo",
        "count",
        "div",
        "dump",
        "each",
        "eachByte",
        "eachFile",
        "eachLine",
        "every",
        "find",
        "findAll",
        "flatten",
        "getAt",
        "getErr",
        "getIn",
        "getOut",
        "getText",
        "grep",
        "immutable",
        "inject",
        "inspect",
        "intersect",
        "invokeMethods",
        "isCase",
        "join",
        "leftShift",
        "minus",
        "multiply",
        "newInputStream",
        "newOutputStream",
        "newPrintWriter",
        "newReader",
        "newWriter",
        "next",
        "plus",
        "pop",
        "power",
        "previous",
        "print",
        "println",
        "push",
        "putAt",
        "read",
        "readBytes",
        "readLines",
        "reverse",
        "reverseEach",
        "round",
        "size",
        "sort",
        "splitEachLine",
        "step",
        "subMap",
        "times",
        "toInteger",
        "toList",
        "tokenize",
        "upto",
        "waitForOrKill",
        "withPrintWriter",
        "withReader",
        "withStream",
        "withWriter",
        "withWriterAppend",
        "write",
        "writeLine"
      ];
      return {
        name: "Gradle",
        case_insensitive: true,
        keywords: KEYWORDS,
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          hljs.REGEXP_MODE
        ]
      };
    }
    module2.exports = gradle;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/groovy.js
var require_groovy = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/groovy.js"(exports, module2) {
    function variants(variants2, obj = {}) {
      obj.variants = variants2;
      return obj;
    }
    function groovy(hljs) {
      const regex = hljs.regex;
      const IDENT_RE = "[A-Za-z0-9_$]+";
      const COMMENT = variants([
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.COMMENT("/\\*\\*", "\\*/", {
          relevance: 0,
          contains: [
            {
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        })
      ]);
      const REGEXP = {
        className: "regexp",
        begin: /~?\/[^\/\n]+\//,
        contains: [hljs.BACKSLASH_ESCAPE]
      };
      const NUMBER = variants([
        hljs.BINARY_NUMBER_MODE,
        hljs.C_NUMBER_MODE
      ]);
      const STRING = variants([
        {
          begin: /"""/,
          end: /"""/
        },
        {
          begin: /'''/,
          end: /'''/
        },
        {
          begin: "\\$/",
          end: "/\\$",
          relevance: 10
        },
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ], { className: "string" });
      const CLASS_DEFINITION = {
        match: [
          /(class|interface|trait|enum|record|extends|implements)/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      };
      const TYPES = [
        "byte",
        "short",
        "char",
        "int",
        "long",
        "boolean",
        "float",
        "double",
        "void"
      ];
      const KEYWORDS = [
        "def",
        "as",
        "in",
        "assert",
        "trait",
        "abstract",
        "static",
        "volatile",
        "transient",
        "public",
        "private",
        "protected",
        "synchronized",
        "final",
        "class",
        "interface",
        "enum",
        "if",
        "else",
        "for",
        "while",
        "switch",
        "case",
        "break",
        "default",
        "continue",
        "throw",
        "throws",
        "try",
        "catch",
        "finally",
        "implements",
        "extends",
        "new",
        "import",
        "package",
        "return",
        "instanceof",
        "var"
      ];
      return {
        name: "Groovy",
        keywords: {
          "variable.language": "this super",
          literal: "true false null",
          type: TYPES,
          keyword: KEYWORDS
        },
        contains: [
          hljs.SHEBANG({
            binary: "groovy",
            relevance: 10
          }),
          COMMENT,
          STRING,
          REGEXP,
          NUMBER,
          CLASS_DEFINITION,
          {
            className: "meta",
            begin: "@[A-Za-z]+",
            relevance: 0
          },
          {
            className: "attr",
            begin: IDENT_RE + "[ 	]*:",
            relevance: 0
          },
          {
            begin: /\?/,
            end: /:/,
            relevance: 0,
            contains: [
              COMMENT,
              STRING,
              REGEXP,
              NUMBER,
              "self"
            ]
          },
          {
            className: "symbol",
            begin: "^[ 	]*" + regex.lookahead(IDENT_RE + ":"),
            excludeBegin: true,
            end: IDENT_RE + ":",
            relevance: 0
          }
        ],
        illegal: /#|<\//
      };
    }
    module2.exports = groovy;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/haskell.js
var require_haskell = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/haskell.js"(exports, module2) {
    function haskell(hljs) {
      const decimalDigits = "([0-9]_*)+";
      const hexDigits = "([0-9a-fA-F]_*)+";
      const binaryDigits = "([01]_*)+";
      const octalDigits = "([0-7]_*)+";
      const ascSymbol = "[!#$%&*+.\\/<=>?@\\\\^~-]";
      const uniSymbol = "(\\p{S}|\\p{P})";
      const special = "[(),;\\[\\]`|{}]";
      const symbol = `(${ascSymbol}|(?!(${special}|[_:"']))${uniSymbol})`;
      const COMMENT = { variants: [
        hljs.COMMENT("--+", "$"),
        hljs.COMMENT(/\{-/, /-\}/, { contains: ["self"] })
      ] };
      const PRAGMA = {
        className: "meta",
        begin: /\{-#/,
        end: /#-\}/
      };
      const PREPROCESSOR = {
        className: "meta",
        begin: "^#",
        end: "$"
      };
      const CONSTRUCTOR = {
        className: "type",
        begin: "\\b[A-Z][\\w']*",
        relevance: 0
      };
      const LIST = {
        begin: "\\(",
        end: "\\)",
        illegal: '"',
        contains: [
          PRAGMA,
          PREPROCESSOR,
          {
            className: "type",
            begin: "\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?"
          },
          hljs.inherit(hljs.TITLE_MODE, { begin: "[_a-z][\\w']*" }),
          COMMENT
        ]
      };
      const RECORD = {
        begin: /\{/,
        end: /\}/,
        contains: LIST.contains
      };
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          { match: `\\b(${decimalDigits})(\\.(${decimalDigits}))?([eE][+-]?(${decimalDigits}))?\\b` },
          { match: `\\b0[xX]_*(${hexDigits})(\\.(${hexDigits}))?([pP][+-]?(${decimalDigits}))?\\b` },
          { match: `\\b0[oO](${octalDigits})\\b` },
          { match: `\\b0[bB](${binaryDigits})\\b` }
        ]
      };
      return {
        name: "Haskell",
        aliases: ["hs"],
        keywords: "let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",
        unicodeRegex: true,
        contains: [
          {
            beginKeywords: "module",
            end: "where",
            keywords: "module where",
            contains: [
              LIST,
              COMMENT
            ],
            illegal: "\\W\\.|;"
          },
          {
            begin: "\\bimport\\b",
            end: "$",
            keywords: "import qualified as hiding",
            contains: [
              LIST,
              COMMENT
            ],
            illegal: "\\W\\.|;"
          },
          {
            className: "class",
            begin: "^(\\s*)?(class|instance)\\b",
            end: "where",
            keywords: "class family instance where",
            contains: [
              CONSTRUCTOR,
              LIST,
              COMMENT
            ]
          },
          {
            className: "class",
            begin: "\\b(data|(new)?type)\\b",
            end: "$",
            keywords: "data family type newtype deriving",
            contains: [
              PRAGMA,
              CONSTRUCTOR,
              LIST,
              RECORD,
              COMMENT
            ]
          },
          {
            beginKeywords: "default",
            end: "$",
            contains: [
              CONSTRUCTOR,
              LIST,
              COMMENT
            ]
          },
          {
            beginKeywords: "infix infixl infixr",
            end: "$",
            contains: [
              hljs.C_NUMBER_MODE,
              COMMENT
            ]
          },
          {
            begin: "\\bforeign\\b",
            end: "$",
            keywords: "foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",
            contains: [
              CONSTRUCTOR,
              hljs.QUOTE_STRING_MODE,
              COMMENT
            ]
          },
          {
            className: "meta",
            begin: "#!\\/usr\\/bin\\/env runhaskell",
            end: "$"
          },
          PRAGMA,
          PREPROCESSOR,
          {
            scope: "string",
            begin: /'(?=\\?.')/,
            end: /'/,
            contains: [
              {
                scope: "char.escape",
                match: /\\./
              }
            ]
          },
          hljs.QUOTE_STRING_MODE,
          NUMBER,
          CONSTRUCTOR,
          hljs.inherit(hljs.TITLE_MODE, { begin: "^[_a-z][\\w']*" }),
          { begin: `(?!-)${symbol}--+|--+(?!-)${symbol}` },
          COMMENT,
          {
            begin: "->|<-"
          }
        ]
      };
    }
    module2.exports = haskell;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/java.js
var require_java = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/java.js"(exports, module2) {
    var decimalDigits = "[0-9](_*[0-9])*";
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
    var NUMERIC = {
      className: "number",
      variants: [
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function recurRegex(re, substitution, depth) {
      if (depth === -1)
        return "";
      return re.replace(substitution, (_) => {
        return recurRegex(re, substitution, depth - 1);
      });
    }
    function java(hljs) {
      const regex = hljs.regex;
      const JAVA_IDENT_RE = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*";
      const GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*" + JAVA_IDENT_RE + "~~~)*>)?", /~~~/g, 2);
      const MAIN_KEYWORDS = [
        "synchronized",
        "abstract",
        "private",
        "var",
        "static",
        "if",
        "const ",
        "for",
        "while",
        "strictfp",
        "finally",
        "protected",
        "import",
        "native",
        "final",
        "void",
        "enum",
        "else",
        "break",
        "transient",
        "catch",
        "instanceof",
        "volatile",
        "case",
        "assert",
        "package",
        "default",
        "public",
        "try",
        "switch",
        "continue",
        "throws",
        "protected",
        "public",
        "private",
        "module",
        "requires",
        "exports",
        "do",
        "sealed",
        "yield",
        "permits",
        "goto",
        "when"
      ];
      const BUILT_INS = [
        "super",
        "this"
      ];
      const LITERALS = [
        "false",
        "true",
        "null"
      ];
      const TYPES = [
        "char",
        "boolean",
        "long",
        "float",
        "int",
        "byte",
        "short",
        "double"
      ];
      const KEYWORDS = {
        keyword: MAIN_KEYWORDS,
        literal: LITERALS,
        type: TYPES,
        built_in: BUILT_INS
      };
      const ANNOTATION = {
        className: "meta",
        begin: "@" + JAVA_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
          }
        ]
      };
      const PARAMS = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        relevance: 0,
        contains: [hljs.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: KEYWORDS,
        illegal: /<\/|#/,
        contains: [
          hljs.COMMENT("/\\*\\*", "\\*/", {
            relevance: 0,
            contains: [
              {
                begin: /\w+@/,
                relevance: 0
              },
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              }
            ]
          }),
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              JAVA_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              regex.concat(/(?!else)/, JAVA_IDENT_RE),
              /\s+/,
              JAVA_IDENT_RE,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              JAVA_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              PARAMS,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + GENERIC_IDENT_RE + "\\s+)",
              hljs.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: KEYWORDS,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  ANNOTATION,
                  hljs.APOS_STRING_MODE,
                  hljs.QUOTE_STRING_MODE,
                  NUMERIC,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          NUMERIC,
          ANNOTATION
        ]
      };
    }
    module2.exports = java;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/javascript.js
var require_javascript = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/javascript.js"(exports, module2) {
    var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    var KEYWORDS = [
      "as",
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      "using"
    ];
    var LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    var TYPES = [
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      "Math",
      "Date",
      "Number",
      "BigInt",
      "String",
      "RegExp",
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      "Reflect",
      "Proxy",
      "Intl",
      "WebAssembly"
    ];
    var ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    var BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    var BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
    ];
    var BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
    function javascript(hljs) {
      const regex = hljs.regex;
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };
      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: "<>",
        end: "</>"
      };
      const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          if (nextChar === "<" || nextChar === ",") {
            response.ignoreMatch();
            return;
          }
          if (nextChar === ">") {
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
          let m;
          const afterMatch = match.input.substring(afterMatchIndex);
          if (m = afterMatch.match(/^\s*=/)) {
            response.ignoreMatch();
            return;
          }
          if (m = afterMatch.match(/^\s+extends\s+/)) {
            if (m.index === 0) {
              response.ignoreMatch();
              return;
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS,
        "variable.language": BUILT_IN_VARIABLES
      };
      const decimalDigits = "[0-9](_?[0-9])*";
      const frac = `\\.(${decimalDigits})`;
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: "number",
        variants: [
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      };
      const SUBST = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: KEYWORDS$1,
        contains: []
      };
      const HTML_TEMPLATE = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "xml"
        }
      };
      const CSS_TEMPLATE = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "css"
        }
      };
      const GRAPHQL_TEMPLATE = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "graphql"
        }
      };
      const TEMPLATE_STRING = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
        relevance: 0,
        contains: [
          {
            begin: "(?=@[A-Za-z]+)",
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              },
              {
                className: "type",
                begin: "\\{",
                end: "\\}",
                excludeEnd: true,
                excludeBegin: true,
                relevance: 0
              },
              {
                className: "variable",
                begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              },
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      });
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        { match: /\$\d+/ },
        NUMBER
      ];
      SUBST.contains = SUBST_INTERNALS.concat({
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: "params",
        begin: /(\s*)\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };
      const CLASS_OR_EXTENDS = {
        variants: [
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1,
              /\s+/,
              /extends/,
              /\s+/,
              regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: regex.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
        className: "title.class",
        keywords: {
          _: [
            ...TYPES,
            ...ERROR_TYPES
          ]
        }
      };
      const USE_STRICT = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      };
      const FUNCTION_DEFINITION = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              IDENT_RE$1,
              /(?=\s*\()/
            ]
          },
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [PARAMS],
        illegal: /%/
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function noneOf(list) {
        return regex.concat("(?!", list.join("|"), ")");
      }
      const FUNCTION_CALL = {
        match: regex.concat(/\b/, noneOf([
          ...BUILT_IN_GLOBALS,
          "super",
          "import"
        ].map((x) => `${x}\\s*\\(`)), IDENT_RE$1, regex.lookahead(/\s*\(/)),
        className: "title.function",
        relevance: 0
      };
      const PROPERTY_ACCESS = {
        begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),
        end: IDENT_RE$1,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      };
      const GETTER_OR_SETTER = {
        match: [
          /get|set/,
          /\s+/,
          IDENT_RE$1,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            begin: /\(\)/
          },
          PARAMS
        ]
      };
      const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
      const FUNCTION_VARIABLE = {
        match: [
          /const|var|let/,
          /\s+/,
          IDENT_RE$1,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          regex.lookahead(FUNC_LEAD_IN_RE)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: KEYWORDS$1,
        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          USE_STRICT,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          GRAPHQL_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          { match: /\$\d+/ },
          NUMBER,
          CLASS_REFERENCE,
          {
            scope: "attr",
            match: IDENT_RE$1 + regex.lookahead(":"),
            relevance: 0
          },
          FUNCTION_VARIABLE,
          {
            begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: "function",
                begin: FUNC_LEAD_IN_RE,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              {
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  { match: XML_SELF_CLOSING },
                  {
                    begin: XML_TAG.begin,
                    "on:begin": XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          FUNCTION_DEFINITION,
          {
            beginKeywords: "while if switch catch for"
          },
          {
            begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            returnBegin: true,
            label: "func.def",
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
            ]
          },
          {
            match: /\.\.\./,
            relevance: 0
          },
          PROPERTY_ACCESS,
          {
            match: "\\$" + IDENT_RE$1,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [PARAMS]
          },
          FUNCTION_CALL,
          UPPER_CASE_CONSTANT,
          CLASS_OR_EXTENDS,
          GETTER_OR_SETTER,
          {
            match: /\$[(.]/
          }
        ]
      };
    }
    module2.exports = javascript;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/json.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/json.js"(exports, module2) {
    function json(hljs) {
      const ATTRIBUTE = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      };
      const PUNCTUATION = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      };
      const LITERALS = [
        "true",
        "false",
        "null"
      ];
      const LITERALS_MODE = {
        scope: "literal",
        beginKeywords: LITERALS.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: LITERALS
        },
        contains: [
          ATTRIBUTE,
          PUNCTUATION,
          hljs.QUOTE_STRING_MODE,
          LITERALS_MODE,
          hljs.C_NUMBER_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    module2.exports = json;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/julia.js
var require_julia = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/julia.js"(exports, module2) {
    function julia(hljs) {
      const VARIABLE_NAME_RE = "[A-Za-z_\\u00A1-\\uFFFF][A-Za-z_0-9\\u00A1-\\uFFFF]*";
      const KEYWORD_LIST = [
        "baremodule",
        "begin",
        "break",
        "catch",
        "ccall",
        "const",
        "continue",
        "do",
        "else",
        "elseif",
        "end",
        "export",
        "false",
        "finally",
        "for",
        "function",
        "global",
        "if",
        "import",
        "in",
        "isa",
        "let",
        "local",
        "macro",
        "module",
        "quote",
        "return",
        "true",
        "try",
        "using",
        "where",
        "while"
      ];
      const LITERAL_LIST = [
        "ARGS",
        "C_NULL",
        "DEPOT_PATH",
        "ENDIAN_BOM",
        "ENV",
        "Inf",
        "Inf16",
        "Inf32",
        "Inf64",
        "InsertionSort",
        "LOAD_PATH",
        "MergeSort",
        "NaN",
        "NaN16",
        "NaN32",
        "NaN64",
        "PROGRAM_FILE",
        "QuickSort",
        "RoundDown",
        "RoundFromZero",
        "RoundNearest",
        "RoundNearestTiesAway",
        "RoundNearestTiesUp",
        "RoundToZero",
        "RoundUp",
        "VERSION|0",
        "devnull",
        "false",
        "im",
        "missing",
        "nothing",
        "pi",
        "stderr",
        "stdin",
        "stdout",
        "true",
        "undef",
        "\u03C0",
        "\u212F"
      ];
      const BUILT_IN_LIST = [
        "AbstractArray",
        "AbstractChannel",
        "AbstractChar",
        "AbstractDict",
        "AbstractDisplay",
        "AbstractFloat",
        "AbstractIrrational",
        "AbstractMatrix",
        "AbstractRange",
        "AbstractSet",
        "AbstractString",
        "AbstractUnitRange",
        "AbstractVecOrMat",
        "AbstractVector",
        "Any",
        "ArgumentError",
        "Array",
        "AssertionError",
        "BigFloat",
        "BigInt",
        "BitArray",
        "BitMatrix",
        "BitSet",
        "BitVector",
        "Bool",
        "BoundsError",
        "CapturedException",
        "CartesianIndex",
        "CartesianIndices",
        "Cchar",
        "Cdouble",
        "Cfloat",
        "Channel",
        "Char",
        "Cint",
        "Cintmax_t",
        "Clong",
        "Clonglong",
        "Cmd",
        "Colon",
        "Complex",
        "ComplexF16",
        "ComplexF32",
        "ComplexF64",
        "CompositeException",
        "Condition",
        "Cptrdiff_t",
        "Cshort",
        "Csize_t",
        "Cssize_t",
        "Cstring",
        "Cuchar",
        "Cuint",
        "Cuintmax_t",
        "Culong",
        "Culonglong",
        "Cushort",
        "Cvoid",
        "Cwchar_t",
        "Cwstring",
        "DataType",
        "DenseArray",
        "DenseMatrix",
        "DenseVecOrMat",
        "DenseVector",
        "Dict",
        "DimensionMismatch",
        "Dims",
        "DivideError",
        "DomainError",
        "EOFError",
        "Enum",
        "ErrorException",
        "Exception",
        "ExponentialBackOff",
        "Expr",
        "Float16",
        "Float32",
        "Float64",
        "Function",
        "GlobalRef",
        "HTML",
        "IO",
        "IOBuffer",
        "IOContext",
        "IOStream",
        "IdDict",
        "IndexCartesian",
        "IndexLinear",
        "IndexStyle",
        "InexactError",
        "InitError",
        "Int",
        "Int128",
        "Int16",
        "Int32",
        "Int64",
        "Int8",
        "Integer",
        "InterruptException",
        "InvalidStateException",
        "Irrational",
        "KeyError",
        "LinRange",
        "LineNumberNode",
        "LinearIndices",
        "LoadError",
        "MIME",
        "Matrix",
        "Method",
        "MethodError",
        "Missing",
        "MissingException",
        "Module",
        "NTuple",
        "NamedTuple",
        "Nothing",
        "Number",
        "OrdinalRange",
        "OutOfMemoryError",
        "OverflowError",
        "Pair",
        "PartialQuickSort",
        "PermutedDimsArray",
        "Pipe",
        "ProcessFailedException",
        "Ptr",
        "QuoteNode",
        "Rational",
        "RawFD",
        "ReadOnlyMemoryError",
        "Real",
        "ReentrantLock",
        "Ref",
        "Regex",
        "RegexMatch",
        "RoundingMode",
        "SegmentationFault",
        "Set",
        "Signed",
        "Some",
        "StackOverflowError",
        "StepRange",
        "StepRangeLen",
        "StridedArray",
        "StridedMatrix",
        "StridedVecOrMat",
        "StridedVector",
        "String",
        "StringIndexError",
        "SubArray",
        "SubString",
        "SubstitutionString",
        "Symbol",
        "SystemError",
        "Task",
        "TaskFailedException",
        "Text",
        "TextDisplay",
        "Timer",
        "Tuple",
        "Type",
        "TypeError",
        "TypeVar",
        "UInt",
        "UInt128",
        "UInt16",
        "UInt32",
        "UInt64",
        "UInt8",
        "UndefInitializer",
        "UndefKeywordError",
        "UndefRefError",
        "UndefVarError",
        "Union",
        "UnionAll",
        "UnitRange",
        "Unsigned",
        "Val",
        "Vararg",
        "VecElement",
        "VecOrMat",
        "Vector",
        "VersionNumber",
        "WeakKeyDict",
        "WeakRef"
      ];
      const KEYWORDS = {
        $pattern: VARIABLE_NAME_RE,
        keyword: KEYWORD_LIST,
        literal: LITERAL_LIST,
        built_in: BUILT_IN_LIST
      };
      const DEFAULT = {
        keywords: KEYWORDS,
        illegal: /<\//
      };
      const NUMBER = {
        className: "number",
        begin: /(\b0x[\d_]*(\.[\d_]*)?|0x\.\d[\d_]*)p[-+]?\d+|\b0[box][a-fA-F0-9][a-fA-F0-9_]*|(\b\d[\d_]*(\.[\d_]*)?|\.\d[\d_]*)([eEfF][-+]?\d+)?/,
        relevance: 0
      };
      const CHAR = {
        className: "string",
        begin: /'(.|\\[xXuU][a-zA-Z0-9]+)'/
      };
      const INTERPOLATION = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        keywords: KEYWORDS
      };
      const INTERPOLATED_VARIABLE = {
        className: "variable",
        begin: "\\$" + VARIABLE_NAME_RE
      };
      const STRING = {
        className: "string",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          INTERPOLATION,
          INTERPOLATED_VARIABLE
        ],
        variants: [
          {
            begin: /\w*"""/,
            end: /"""\w*/,
            relevance: 10
          },
          {
            begin: /\w*"/,
            end: /"\w*/
          }
        ]
      };
      const COMMAND = {
        className: "string",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          INTERPOLATION,
          INTERPOLATED_VARIABLE
        ],
        begin: "`",
        end: "`"
      };
      const MACROCALL = {
        className: "meta",
        begin: "@" + VARIABLE_NAME_RE
      };
      const COMMENT = {
        className: "comment",
        variants: [
          {
            begin: "#=",
            end: "=#",
            relevance: 10
          },
          {
            begin: "#",
            end: "$"
          }
        ]
      };
      DEFAULT.name = "Julia";
      DEFAULT.contains = [
        NUMBER,
        CHAR,
        STRING,
        COMMAND,
        MACROCALL,
        COMMENT,
        hljs.HASH_COMMENT_MODE,
        {
          className: "keyword",
          begin: "\\b(((abstract|primitive)\\s+)type|(mutable\\s+)?struct)\\b"
        },
        { begin: /<:/ }
      ];
      INTERPOLATION.contains = DEFAULT.contains;
      return DEFAULT;
    }
    module2.exports = julia;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/kotlin.js
var require_kotlin = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/kotlin.js"(exports, module2) {
    var decimalDigits = "[0-9](_*[0-9])*";
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
    var NUMERIC = {
      className: "number",
      variants: [
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function kotlin(hljs) {
      const KEYWORDS = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      };
      const KEYWORDS_WITH_LABEL = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      };
      const LABEL = {
        className: "symbol",
        begin: hljs.UNDERSCORE_IDENT_RE + "@"
      };
      const SUBST = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [hljs.C_NUMBER_MODE]
      };
      const VARIABLE = {
        className: "variable",
        begin: "\\$" + hljs.UNDERSCORE_IDENT_RE
      };
      const STRING = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              VARIABLE,
              SUBST
            ]
          },
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              VARIABLE,
              SUBST
            ]
          }
        ]
      };
      SUBST.contains.push(STRING);
      const ANNOTATION_USE_SITE = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + hljs.UNDERSCORE_IDENT_RE + ")?"
      };
      const ANNOTATION = {
        className: "meta",
        begin: "@" + hljs.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              hljs.inherit(STRING, { className: "string" }),
              "self"
            ]
          }
        ]
      };
      const KOTLIN_NUMBER_MODE = NUMERIC;
      const KOTLIN_NESTED_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: [hljs.C_BLOCK_COMMENT_MODE] });
      const KOTLIN_PAREN_TYPE = { variants: [
        {
          className: "type",
          begin: hljs.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
        }
      ] };
      const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
      KOTLIN_PAREN_TYPE2.variants[1].contains = [KOTLIN_PAREN_TYPE];
      KOTLIN_PAREN_TYPE.variants[1].contains = [KOTLIN_PAREN_TYPE2];
      return {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: KEYWORDS,
        contains: [
          hljs.COMMENT("/\\*\\*", "\\*/", {
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              }
            ]
          }),
          hljs.C_LINE_COMMENT_MODE,
          KOTLIN_NESTED_COMMENT,
          KEYWORDS_WITH_LABEL,
          LABEL,
          ANNOTATION_USE_SITE,
          ANNOTATION,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            relevance: 5,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      KOTLIN_PAREN_TYPE,
                      hljs.C_LINE_COMMENT_MODE,
                      KOTLIN_NESTED_COMMENT
                    ],
                    relevance: 0
                  },
                  hljs.C_LINE_COMMENT_MODE,
                  KOTLIN_NESTED_COMMENT,
                  ANNOTATION_USE_SITE,
                  ANNOTATION,
                  STRING,
                  hljs.C_NUMBER_MODE
                ]
              },
              KOTLIN_NESTED_COMMENT
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              hljs.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              ANNOTATION_USE_SITE,
              ANNOTATION
            ]
          },
          STRING,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: "\n"
          },
          KOTLIN_NUMBER_MODE
        ]
      };
    }
    module2.exports = kotlin;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/lisp.js
var require_lisp = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/lisp.js"(exports, module2) {
    function lisp(hljs) {
      const LISP_IDENT_RE = "[a-zA-Z_\\-+\\*\\/<=>&#][a-zA-Z0-9_\\-+*\\/<=>&#!]*";
      const MEC_RE = "\\|[^]*?\\|";
      const LISP_SIMPLE_NUMBER_RE = "(-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s|D|E|F|L|S)(\\+|-)?\\d+)?";
      const LITERAL = {
        className: "literal",
        begin: "\\b(t{1}|nil)\\b"
      };
      const NUMBER = {
        className: "number",
        variants: [
          {
            begin: LISP_SIMPLE_NUMBER_RE,
            relevance: 0
          },
          { begin: "#(b|B)[0-1]+(/[0-1]+)?" },
          { begin: "#(o|O)[0-7]+(/[0-7]+)?" },
          { begin: "#(x|X)[0-9a-fA-F]+(/[0-9a-fA-F]+)?" },
          {
            begin: "#(c|C)\\(" + LISP_SIMPLE_NUMBER_RE + " +" + LISP_SIMPLE_NUMBER_RE,
            end: "\\)"
          }
        ]
      };
      const STRING = hljs.inherit(hljs.QUOTE_STRING_MODE, { illegal: null });
      const COMMENT = hljs.COMMENT(";", "$", { relevance: 0 });
      const VARIABLE = {
        begin: "\\*",
        end: "\\*"
      };
      const KEYWORD = {
        className: "symbol",
        begin: "[:&]" + LISP_IDENT_RE
      };
      const IDENT = {
        begin: LISP_IDENT_RE,
        relevance: 0
      };
      const MEC = { begin: MEC_RE };
      const QUOTED_LIST = {
        begin: "\\(",
        end: "\\)",
        contains: [
          "self",
          LITERAL,
          STRING,
          NUMBER,
          IDENT
        ]
      };
      const QUOTED = {
        contains: [
          NUMBER,
          STRING,
          VARIABLE,
          KEYWORD,
          QUOTED_LIST,
          IDENT
        ],
        variants: [
          {
            begin: "['`]\\(",
            end: "\\)"
          },
          {
            begin: "\\(quote ",
            end: "\\)",
            keywords: { name: "quote" }
          },
          { begin: "'" + MEC_RE }
        ]
      };
      const QUOTED_ATOM = { variants: [
        { begin: "'" + LISP_IDENT_RE },
        { begin: "#'" + LISP_IDENT_RE + "(::" + LISP_IDENT_RE + ")*" }
      ] };
      const LIST = {
        begin: "\\(\\s*",
        end: "\\)"
      };
      const BODY = {
        endsWithParent: true,
        relevance: 0
      };
      LIST.contains = [
        {
          className: "name",
          variants: [
            {
              begin: LISP_IDENT_RE,
              relevance: 0
            },
            { begin: MEC_RE }
          ]
        },
        BODY
      ];
      BODY.contains = [
        QUOTED,
        QUOTED_ATOM,
        LIST,
        LITERAL,
        NUMBER,
        STRING,
        COMMENT,
        VARIABLE,
        KEYWORD,
        MEC,
        IDENT
      ];
      return {
        name: "Lisp",
        illegal: /\S/,
        contains: [
          NUMBER,
          hljs.SHEBANG(),
          LITERAL,
          STRING,
          COMMENT,
          QUOTED,
          QUOTED_ATOM,
          LIST,
          IDENT
        ]
      };
    }
    module2.exports = lisp;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/lua.js
var require_lua = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/lua.js"(exports, module2) {
    function lua(hljs) {
      const OPENING_LONG_BRACKET = "\\[=*\\[";
      const CLOSING_LONG_BRACKET = "\\]=*\\]";
      const LONG_BRACKETS = {
        begin: OPENING_LONG_BRACKET,
        end: CLOSING_LONG_BRACKET,
        contains: ["self"]
      };
      const COMMENTS = [
        hljs.COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"),
        hljs.COMMENT("--" + OPENING_LONG_BRACKET, CLOSING_LONG_BRACKET, {
          contains: [LONG_BRACKETS],
          relevance: 10
        })
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: hljs.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
        },
        contains: COMMENTS.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: COMMENTS
              }
            ].concat(COMMENTS)
          },
          hljs.C_NUMBER_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: OPENING_LONG_BRACKET,
            end: CLOSING_LONG_BRACKET,
            contains: [LONG_BRACKETS],
            relevance: 5
          }
        ])
      };
    }
    module2.exports = lua;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/makefile.js
var require_makefile = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/makefile.js"(exports, module2) {
    function makefile(hljs) {
      const VARIABLE = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + hljs.UNDERSCORE_IDENT_RE + "\\)",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      };
      const QUOTE_STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VARIABLE
        ]
      };
      const FUNC = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          VARIABLE,
          QUOTE_STRING
        ]
      };
      const ASSIGNMENT = { begin: "^" + hljs.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" };
      const META = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      };
      const TARGET = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [VARIABLE]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          hljs.HASH_COMMENT_MODE,
          VARIABLE,
          QUOTE_STRING,
          FUNC,
          ASSIGNMENT,
          META,
          TARGET
        ]
      };
    }
    module2.exports = makefile;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/markdown.js
var require_markdown = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/markdown.js"(exports, module2) {
    function markdown(hljs) {
      const regex = hljs.regex;
      const INLINE_HTML = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      };
      const HORIZONTAL_RULE = {
        begin: "^[-\\*]{3,}",
        end: "$"
      };
      const CODE = {
        className: "code",
        variants: [
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      };
      const LIST = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      };
      const LINK_REFERENCE = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      };
      const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
      const LINK = {
        variants: [
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: regex.concat(/\[.+?\]\(/, URL_SCHEME, /:\/\/.*?\)/),
            relevance: 2
          },
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      };
      const BOLD = {
        className: "strong",
        contains: [],
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      };
      const ITALIC = {
        className: "emphasis",
        contains: [],
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      };
      const BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] });
      const ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
      BOLD.contains.push(ITALIC_WITHOUT_BOLD);
      ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
      let CONTAINABLE = [
        INLINE_HTML,
        LINK
      ];
      [
        BOLD,
        ITALIC,
        BOLD_WITHOUT_ITALIC,
        ITALIC_WITHOUT_BOLD
      ].forEach((m) => {
        m.contains = m.contains.concat(CONTAINABLE);
      });
      CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
      const HEADER = {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: CONTAINABLE
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: CONTAINABLE
              }
            ]
          }
        ]
      };
      const BLOCKQUOTE = {
        className: "quote",
        begin: "^>\\s+",
        contains: CONTAINABLE,
        end: "$"
      };
      const ENTITY = {
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      };
      return {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          HEADER,
          INLINE_HTML,
          LIST,
          BOLD,
          ITALIC,
          BLOCKQUOTE,
          CODE,
          HORIZONTAL_RULE,
          LINK,
          LINK_REFERENCE,
          ENTITY
        ]
      };
    }
    module2.exports = markdown;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/matlab.js
var require_matlab = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/matlab.js"(exports, module2) {
    function matlab(hljs) {
      const TRANSPOSE_RE = "('|\\.')+";
      const TRANSPOSE = {
        relevance: 0,
        contains: [{ begin: TRANSPOSE_RE }]
      };
      return {
        name: "Matlab",
        keywords: {
          keyword: "arguments break case catch classdef continue else elseif end enumeration events for function global if methods otherwise parfor persistent properties return spmd switch try while",
          built_in: "sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i|0 inf nan isnan isinf isfinite j|0 why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson max min nanmax nanmin mean nanmean type table readtable writetable sortrows sort figure plot plot3 scatter scatter3 cellfun legend intersect ismember procrustes hold num2cell "
        },
        illegal: '(//|"|#|/\\*|\\s+/\\w+)',
        contains: [
          {
            className: "function",
            beginKeywords: "function",
            end: "$",
            contains: [
              hljs.UNDERSCORE_TITLE_MODE,
              {
                className: "params",
                variants: [
                  {
                    begin: "\\(",
                    end: "\\)"
                  },
                  {
                    begin: "\\[",
                    end: "\\]"
                  }
                ]
              }
            ]
          },
          {
            className: "built_in",
            begin: /true|false/,
            relevance: 0,
            starts: TRANSPOSE
          },
          {
            begin: "[a-zA-Z][a-zA-Z_0-9]*" + TRANSPOSE_RE,
            relevance: 0
          },
          {
            className: "number",
            begin: hljs.C_NUMBER_RE,
            relevance: 0,
            starts: TRANSPOSE
          },
          {
            className: "string",
            begin: "'",
            end: "'",
            contains: [{ begin: "''" }]
          },
          {
            begin: /\]|\}|\)/,
            relevance: 0,
            starts: TRANSPOSE
          },
          {
            className: "string",
            begin: '"',
            end: '"',
            contains: [{ begin: '""' }],
            starts: TRANSPOSE
          },
          hljs.COMMENT("^\\s*%\\{\\s*$", "^\\s*%\\}\\s*$"),
          hljs.COMMENT("%", "$")
        ]
      };
    }
    module2.exports = matlab;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/objectivec.js
var require_objectivec = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/objectivec.js"(exports, module2) {
    function objectivec(hljs) {
      const API_CLASS = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      };
      const IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
      const TYPES = [
        "int",
        "float",
        "char",
        "unsigned",
        "signed",
        "short",
        "long",
        "double",
        "wchar_t",
        "unichar",
        "void",
        "bool",
        "BOOL",
        "id|0",
        "_Bool"
      ];
      const KWS = [
        "while",
        "export",
        "sizeof",
        "typedef",
        "const",
        "struct",
        "for",
        "union",
        "volatile",
        "static",
        "mutable",
        "if",
        "do",
        "return",
        "goto",
        "enum",
        "else",
        "break",
        "extern",
        "asm",
        "case",
        "default",
        "register",
        "explicit",
        "typename",
        "switch",
        "continue",
        "inline",
        "readonly",
        "assign",
        "readwrite",
        "self",
        "@synchronized",
        "id",
        "typeof",
        "nonatomic",
        "IBOutlet",
        "IBAction",
        "strong",
        "weak",
        "copy",
        "in",
        "out",
        "inout",
        "bycopy",
        "byref",
        "oneway",
        "__strong",
        "__weak",
        "__block",
        "__autoreleasing",
        "@private",
        "@protected",
        "@public",
        "@try",
        "@property",
        "@end",
        "@throw",
        "@catch",
        "@finally",
        "@autoreleasepool",
        "@synthesize",
        "@dynamic",
        "@selector",
        "@optional",
        "@required",
        "@encode",
        "@package",
        "@import",
        "@defs",
        "@compatibility_alias",
        "__bridge",
        "__bridge_transfer",
        "__bridge_retained",
        "__bridge_retain",
        "__covariant",
        "__contravariant",
        "__kindof",
        "_Nonnull",
        "_Nullable",
        "_Null_unspecified",
        "__FUNCTION__",
        "__PRETTY_FUNCTION__",
        "__attribute__",
        "getter",
        "setter",
        "retain",
        "unsafe_unretained",
        "nonnull",
        "nullable",
        "null_unspecified",
        "null_resettable",
        "class",
        "instancetype",
        "NS_DESIGNATED_INITIALIZER",
        "NS_UNAVAILABLE",
        "NS_REQUIRES_SUPER",
        "NS_RETURNS_INNER_POINTER",
        "NS_INLINE",
        "NS_AVAILABLE",
        "NS_DEPRECATED",
        "NS_ENUM",
        "NS_OPTIONS",
        "NS_SWIFT_UNAVAILABLE",
        "NS_ASSUME_NONNULL_BEGIN",
        "NS_ASSUME_NONNULL_END",
        "NS_REFINED_FOR_SWIFT",
        "NS_SWIFT_NAME",
        "NS_SWIFT_NOTHROW",
        "NS_DURING",
        "NS_HANDLER",
        "NS_ENDHANDLER",
        "NS_VALUERETURN",
        "NS_VOIDRETURN"
      ];
      const LITERALS = [
        "false",
        "true",
        "FALSE",
        "TRUE",
        "nil",
        "YES",
        "NO",
        "NULL"
      ];
      const BUILT_INS = [
        "dispatch_once_t",
        "dispatch_queue_t",
        "dispatch_sync",
        "dispatch_async",
        "dispatch_once"
      ];
      const KEYWORDS = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: IDENTIFIER_RE,
        keyword: KWS,
        literal: LITERALS,
        built_in: BUILT_INS,
        type: TYPES
      };
      const CLASS_KEYWORDS = {
        $pattern: IDENTIFIER_RE,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: KEYWORDS,
        illegal: "</",
        contains: [
          API_CLASS,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_NUMBER_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [hljs.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: CLASS_KEYWORDS,
            contains: [hljs.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + hljs.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    module2.exports = objectivec;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/perl.js
var require_perl = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/perl.js"(exports, module2) {
    function perl(hljs) {
      const regex = hljs.regex;
      const KEYWORDS = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ];
      const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
      const PERL_KEYWORDS = {
        $pattern: /[\w.]+/,
        keyword: KEYWORDS.join(" ")
      };
      const SUBST = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: PERL_KEYWORDS
      };
      const METHOD = {
        begin: /->\{/,
        end: /\}/
      };
      const ATTR = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      };
      const VAR = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: regex.concat(/[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, `(?![A-Za-z])(?![@$%])`)
          },
          {
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [ATTR]
      };
      const NUMBER = {
        className: "number",
        variants: [
          { match: /0?\.[0-9][0-9_]+\b/ },
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      };
      const STRING_CONTAINS = [
        hljs.BACKSLASH_ESCAPE,
        SUBST,
        VAR
      ];
      const REGEX_DELIMS = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        /#/
      ];
      const PAIRED_DOUBLE_RE = (prefix, open, close = "\\1") => {
        const middle = close === "\\1" ? close : regex.concat(close, open);
        return regex.concat(regex.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, middle, /(?:\\.|[^\\\/])*?/, close, REGEX_MODIFIERS);
      };
      const PAIRED_RE = (prefix, open, close) => {
        return regex.concat(regex.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, close, REGEX_MODIFIERS);
      };
      const PERL_DEFAULT_CONTAINS = [
        VAR,
        hljs.HASH_COMMENT_MODE,
        hljs.COMMENT(/^=\w/, /=cut/, { endsWithParent: true }),
        METHOD,
        {
          className: "string",
          contains: STRING_CONTAINS,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [hljs.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [hljs.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        NUMBER,
        {
          begin: "(\\/\\/|" + hljs.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            hljs.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                { begin: PAIRED_DOUBLE_RE("s|tr|y", regex.either(...REGEX_DELIMS, { capture: true })) },
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
                { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//) },
                { begin: PAIRED_RE("m|qr", regex.either(...REGEX_DELIMS, { capture: true }), /\1/) },
                { begin: PAIRED_RE("m|qr", /\(/, /\)/) },
                { begin: PAIRED_RE("m|qr", /\[/, /\]/) },
                { begin: PAIRED_RE("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [hljs.TITLE_MODE, ATTR]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [hljs.TITLE_MODE, ATTR, NUMBER]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      SUBST.contains = PERL_DEFAULT_CONTAINS;
      METHOD.contains = PERL_DEFAULT_CONTAINS;
      return {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: PERL_KEYWORDS,
        contains: PERL_DEFAULT_CONTAINS
      };
    }
    module2.exports = perl;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/php.js
var require_php = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/php.js"(exports, module2) {
    function php(hljs) {
      const regex = hljs.regex;
      const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
      const IDENT_RE = regex.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, NOT_PERL_ETC);
      const PASCAL_CASE_CLASS_NAME_RE = regex.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, NOT_PERL_ETC);
      const UPCASE_NAME_RE = regex.concat(/[A-Z]+/, NOT_PERL_ETC);
      const VARIABLE = {
        scope: "variable",
        match: "\\$+" + IDENT_RE
      };
      const PREPROCESSOR = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          { begin: /<\?=/ },
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
        ]
      };
      const SUBST = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      };
      const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
      const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
        illegal: null,
        contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
      });
      const HEREDOC = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
        "on:begin": (m, resp) => {
          resp.data._beginMatch = m[1] || m[2];
        },
        "on:end": (m, resp) => {
          if (resp.data._beginMatch !== m[1])
            resp.ignoreMatch();
        }
      };
      const NOWDOC = hljs.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      });
      const WHITESPACE = "[ 	\n]";
      const STRING = {
        scope: "string",
        variants: [
          DOUBLE_QUOTED,
          SINGLE_QUOTED,
          HEREDOC,
          NOWDOC
        ]
      };
      const NUMBER = {
        scope: "number",
        variants: [
          { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
          { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
          { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
          { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
        ],
        relevance: 0
      };
      const LITERALS = [
        "false",
        "null",
        "true"
      ];
      const KWS = [
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ];
      const BUILT_INS = [
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ];
      const dualCase = (items) => {
        const result = [];
        items.forEach((item) => {
          result.push(item);
          if (item.toLowerCase() === item) {
            result.push(item.toUpperCase());
          } else {
            result.push(item.toLowerCase());
          }
        });
        return result;
      };
      const KEYWORDS = {
        keyword: KWS,
        literal: dualCase(LITERALS),
        built_in: BUILT_INS
      };
      const normalizeKeywords = (items) => {
        return items.map((item) => {
          return item.replace(/\|\d+$/, "");
        });
      };
      const CONSTRUCTOR_CALL = { variants: [
        {
          match: [
            /new/,
            regex.concat(WHITESPACE, "+"),
            regex.concat("(?!", normalizeKeywords(BUILT_INS).join("\\b|"), "\\b)"),
            PASCAL_CASE_CLASS_NAME_RE
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] };
      const CONSTANT_REFERENCE = regex.concat(IDENT_RE, "\\b(?!\\()");
      const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
        {
          match: [
            regex.concat(/::/, regex.lookahead(/(?!class\b)/)),
            CONSTANT_REFERENCE
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            regex.concat(/::/, regex.lookahead(/(?!class\b)/)),
            CONSTANT_REFERENCE
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            regex.concat("::", regex.lookahead(/(?!class\b)/))
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            PASCAL_CASE_CLASS_NAME_RE,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] };
      const NAMED_ARGUMENT = {
        scope: "attr",
        match: regex.concat(IDENT_RE, regex.lookahead(":"), regex.lookahead(/(?!::)/))
      };
      const PARAMS_MODE = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        contains: [
          NAMED_ARGUMENT,
          VARIABLE,
          LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
          hljs.C_BLOCK_COMMENT_MODE,
          STRING,
          NUMBER,
          CONSTRUCTOR_CALL
        ]
      };
      const FUNCTION_INVOKE = {
        relevance: 0,
        match: [
          /\b/,
          regex.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS).join("\\b|"), "\\b)"),
          IDENT_RE,
          regex.concat(WHITESPACE, "*"),
          regex.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [PARAMS_MODE]
      };
      PARAMS_MODE.contains.push(FUNCTION_INVOKE);
      const ATTRIBUTE_CONTAINS = [
        NAMED_ARGUMENT,
        LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
        hljs.C_BLOCK_COMMENT_MODE,
        STRING,
        NUMBER,
        CONSTRUCTOR_CALL
      ];
      const ATTRIBUTES = {
        begin: regex.concat(/#\[\s*\\?/, regex.either(PASCAL_CASE_CLASS_NAME_RE, UPCASE_NAME_RE)),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: LITERALS,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: LITERALS,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...ATTRIBUTE_CONTAINS
            ]
          },
          ...ATTRIBUTE_CONTAINS,
          {
            scope: "meta",
            variants: [
              { match: PASCAL_CASE_CLASS_NAME_RE },
              { match: UPCASE_NAME_RE }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: KEYWORDS,
        contains: [
          ATTRIBUTES,
          hljs.HASH_COMMENT_MODE,
          hljs.COMMENT("//", "$"),
          hljs.COMMENT("/\\*", "\\*/", { contains: [
            {
              scope: "doctag",
              match: "@[A-Za-z]+"
            }
          ] }),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: hljs.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          PREPROCESSOR,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          VARIABLE,
          FUNCTION_INVOKE,
          LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
          {
            match: [
              /const/,
              /\s/,
              IDENT_RE
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          CONSTRUCTOR_CALL,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                contains: [
                  "self",
                  ATTRIBUTES,
                  VARIABLE,
                  LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                  hljs.C_BLOCK_COMMENT_MODE,
                  STRING,
                  NUMBER
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          STRING,
          NUMBER
        ]
      };
    }
    module2.exports = php;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/python.js
var require_python = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/python.js"(exports, module2) {
    function python(hljs) {
      const regex = hljs.regex;
      const IDENT_RE = /[\p{XID_Start}_]\p{XID_Continue}*/u;
      const RESERVED_WORDS = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ];
      const BUILT_INS = [
        "__import__",
        "abs",
        "all",
        "any",
        "ascii",
        "bin",
        "bool",
        "breakpoint",
        "bytearray",
        "bytes",
        "callable",
        "chr",
        "classmethod",
        "compile",
        "complex",
        "delattr",
        "dict",
        "dir",
        "divmod",
        "enumerate",
        "eval",
        "exec",
        "filter",
        "float",
        "format",
        "frozenset",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "int",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "list",
        "locals",
        "map",
        "max",
        "memoryview",
        "min",
        "next",
        "object",
        "oct",
        "open",
        "ord",
        "pow",
        "print",
        "property",
        "range",
        "repr",
        "reversed",
        "round",
        "set",
        "setattr",
        "slice",
        "sorted",
        "staticmethod",
        "str",
        "sum",
        "super",
        "tuple",
        "type",
        "vars",
        "zip"
      ];
      const LITERALS = [
        "__debug__",
        "Ellipsis",
        "False",
        "None",
        "NotImplemented",
        "True"
      ];
      const TYPES = [
        "Any",
        "Callable",
        "Coroutine",
        "Dict",
        "List",
        "Literal",
        "Generic",
        "Optional",
        "Sequence",
        "Set",
        "Tuple",
        "Type",
        "Union"
      ];
      const KEYWORDS = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: RESERVED_WORDS,
        built_in: BUILT_INS,
        literal: LITERALS,
        type: TYPES
      };
      const PROMPT = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      };
      const SUBST = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS,
        illegal: /#/
      };
      const LITERAL_BRACKET = {
        begin: /\{\{/,
        relevance: 0
      };
      const STRING = {
        className: "string",
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              PROMPT,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              LITERAL_BRACKET,
              SUBST
            ]
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      };
      const digitpart = "[0-9](_?[0-9])*";
      const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
      const lookahead = `\\b|${RESERVED_WORDS.join("|")}`;
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          {
            begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead})`
          },
          {
            begin: `(${pointfloat})[jJ]?`
          },
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead})`
          },
          {
            begin: `\\b(${digitpart})[jJ](?=${lookahead})`
          }
        ]
      };
      const COMMENT_TYPE = {
        className: "comment",
        begin: regex.lookahead(/# type:/),
        end: /$/,
        keywords: KEYWORDS,
        contains: [
          {
            begin: /# type:/
          },
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      };
      const PARAMS = {
        className: "params",
        variants: [
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              "self",
              PROMPT,
              NUMBER,
              STRING,
              hljs.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      SUBST.contains = [
        STRING,
        NUMBER,
        PROMPT
      ];
      return {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: KEYWORDS,
        illegal: /(<\/|\?)|=>/,
        contains: [
          PROMPT,
          NUMBER,
          {
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          STRING,
          COMMENT_TYPE,
          hljs.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              IDENT_RE
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [PARAMS]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  IDENT_RE,
                  /\s*/,
                  /\(\s*/,
                  IDENT_RE,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  IDENT_RE
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              NUMBER,
              PARAMS,
              STRING
            ]
          }
        ]
      };
    }
    module2.exports = python;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/r.js
var require_r = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/r.js"(exports, module2) {
    function r(hljs) {
      const regex = hljs.regex;
      const IDENT_RE = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
      const NUMBER_TYPES_RE = regex.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/);
      const OPERATORS_RE = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/;
      const PUNCTUATION_RE = regex.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
      return {
        name: "R",
        keywords: {
          $pattern: IDENT_RE,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
        },
        contains: [
          hljs.COMMENT(/#'/, /$/, { contains: [
            {
              scope: "doctag",
              match: /@examples/,
              starts: {
                end: regex.lookahead(regex.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
                endsParent: true
              }
            },
            {
              scope: "doctag",
              begin: "@param",
              end: /$/,
              contains: [
                {
                  scope: "variable",
                  variants: [
                    { match: IDENT_RE },
                    { match: /`(?:\\.|[^`\\])+`/ }
                  ],
                  endsParent: true
                }
              ]
            },
            {
              scope: "doctag",
              match: /@[a-zA-Z]+/
            },
            {
              scope: "keyword",
              match: /\\[a-zA-Z]+/
            }
          ] }),
          hljs.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [hljs.BACKSLASH_ESCAPE],
            variants: [
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              hljs.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  OPERATORS_RE,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  PUNCTUATION_RE,
                  NUMBER_TYPES_RE
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  NUMBER_TYPES_RE
                ]
              }
            ]
          },
          {
            scope: { 3: "operator" },
            match: [
              IDENT_RE,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: OPERATORS_RE },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: PUNCTUATION_RE
          },
          {
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    module2.exports = r;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/ruby.js
var require_ruby = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/ruby.js"(exports, module2) {
    function ruby(hljs) {
      const regex = hljs.regex;
      const RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
      const CLASS_NAME_RE = regex.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/);
      const CLASS_NAME_WITH_NAMESPACE_RE = regex.concat(CLASS_NAME_RE, /(::\w+)*/);
      const PSEUDO_KWS = [
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ];
      const RUBY_KEYWORDS = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...PSEUDO_KWS
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      };
      const YARDOCTAG = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      };
      const IRB_OBJECT = {
        begin: "#<",
        end: ">"
      };
      const COMMENT_MODES = [
        hljs.COMMENT("#", "$", { contains: [YARDOCTAG] }),
        hljs.COMMENT("^=begin", "^=end", {
          contains: [YARDOCTAG],
          relevance: 10
        }),
        hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)
      ];
      const SUBST = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: RUBY_KEYWORDS
      };
      const STRING = {
        className: "string",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          {
            begin: regex.concat(/<<[-~]?'?/, regex.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
            contains: [
              hljs.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  hljs.BACKSLASH_ESCAPE,
                  SUBST
                ]
              })
            ]
          }
        ]
      };
      const decimal = "[1-9](_?[0-9])*|0";
      const digits = "[0-9](_?[0-9])*";
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b` },
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      };
      const PARAMS = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: RUBY_KEYWORDS
          }
        ]
      };
      const INCLUDE_EXTEND = {
        match: [
          /(include|extend)\s+/,
          CLASS_NAME_WITH_NAMESPACE_RE
        ],
        scope: {
          2: "title.class"
        },
        keywords: RUBY_KEYWORDS
      };
      const CLASS_DEFINITION = {
        variants: [
          {
            match: [
              /class\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE,
              /\s+<\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE
            ]
          },
          {
            match: [
              /\b(class|module)\s+/,
              CLASS_NAME_WITH_NAMESPACE_RE
            ]
          }
        ],
        scope: {
          2: "title.class",
          4: "title.class.inherited"
        },
        keywords: RUBY_KEYWORDS
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      const METHOD_DEFINITION = {
        match: [
          /def/,
          /\s+/,
          RUBY_METHOD_RE
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      const OBJECT_CREATION = {
        relevance: 0,
        match: [
          CLASS_NAME_WITH_NAMESPACE_RE,
          /\.new[. (]/
        ],
        scope: {
          1: "title.class"
        }
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: CLASS_NAME_RE,
        scope: "title.class"
      };
      const RUBY_DEFAULT_CONTAINS = [
        STRING,
        CLASS_DEFINITION,
        INCLUDE_EXTEND,
        OBJECT_CREATION,
        UPPER_CASE_CONSTANT,
        CLASS_REFERENCE,
        METHOD_DEFINITION,
        {
          begin: hljs.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            STRING,
            { begin: RUBY_METHOD_RE }
          ],
          relevance: 0
        },
        NUMBER,
        {
          className: "variable",
          begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          keywords: RUBY_KEYWORDS
        },
        {
          begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                hljs.BACKSLASH_ESCAPE,
                SUBST
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(IRB_OBJECT, COMMENT_MODES),
          relevance: 0
        }
      ].concat(IRB_OBJECT, COMMENT_MODES);
      SUBST.contains = RUBY_DEFAULT_CONTAINS;
      PARAMS.contains = RUBY_DEFAULT_CONTAINS;
      const SIMPLE_PROMPT = "[>?]>";
      const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]";
      const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
      const IRB_DEFAULT = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: RUBY_DEFAULT_CONTAINS
          }
        },
        {
          className: "meta.prompt",
          begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])",
          starts: {
            end: "$",
            keywords: RUBY_KEYWORDS,
            contains: RUBY_DEFAULT_CONTAINS
          }
        }
      ];
      COMMENT_MODES.unshift(IRB_OBJECT);
      return {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: RUBY_KEYWORDS,
        illegal: /\/\*/,
        contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS)
      };
    }
    module2.exports = ruby;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/rust.js
var require_rust = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/rust.js"(exports, module2) {
    function rust(hljs) {
      const regex = hljs.regex;
      const RAW_IDENTIFIER = /(r#)?/;
      const UNDERSCORE_IDENT_RE = regex.concat(RAW_IDENTIFIER, hljs.UNDERSCORE_IDENT_RE);
      const IDENT_RE = regex.concat(RAW_IDENTIFIER, hljs.IDENT_RE);
      const FUNCTION_INVOKE = {
        className: "title.function.invoke",
        relevance: 0,
        begin: regex.concat(/\b/, /(?!let|for|while|if|else|match\b)/, IDENT_RE, regex.lookahead(/\s*\(/))
      };
      const NUMBER_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?";
      const KEYWORDS = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ];
      const LITERALS = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ];
      const BUILTINS = [
        "drop ",
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ];
      const TYPES = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: hljs.IDENT_RE + "!?",
          type: TYPES,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: BUILTINS
        },
        illegal: "</",
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          hljs.inherit(hljs.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + NUMBER_SUFFIX },
              { begin: "\\b0o([0-7_]+)" + NUMBER_SUFFIX },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + NUMBER_SUFFIX },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUMBER_SUFFIX }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  hljs.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          {
            begin: [
              /for/,
              /\s+/,
              UNDERSCORE_IDENT_RE,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              UNDERSCORE_IDENT_RE
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: hljs.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: BUILTINS,
              type: TYPES
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          FUNCTION_INVOKE
        ]
      };
    }
    module2.exports = rust;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/scala.js
var require_scala = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/scala.js"(exports, module2) {
    function scala(hljs) {
      const regex = hljs.regex;
      const ANNOTATION = {
        className: "meta",
        begin: "@[A-Za-z]+"
      };
      const SUBST = {
        className: "subst",
        variants: [
          { begin: "\\$[A-Za-z0-9_]+" },
          {
            begin: /\$\{/,
            end: /\}/
          }
        ]
      };
      const STRING = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""'
          },
          {
            begin: '"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            begin: '[a-z]+"',
            end: '"',
            illegal: "\\n",
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ]
          },
          {
            className: "string",
            begin: '[a-z]+"""',
            end: '"""',
            contains: [SUBST],
            relevance: 10
          }
        ]
      };
      const TYPE = {
        className: "type",
        begin: "\\b[A-Z][A-Za-z0-9_]*",
        relevance: 0
      };
      const NAME = {
        className: "title",
        begin: /[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,
        relevance: 0
      };
      const CLASS = {
        className: "class",
        beginKeywords: "class object trait type",
        end: /[:={\[\n;]/,
        excludeEnd: true,
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            beginKeywords: "extends with",
            relevance: 10
          },
          {
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [
              TYPE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [
              TYPE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          NAME
        ]
      };
      const METHOD = {
        className: "function",
        beginKeywords: "def",
        end: regex.lookahead(/[:={\[(\n;]/),
        contains: [NAME]
      };
      const EXTENSION = {
        begin: [
          /^\s*/,
          "extension",
          /\s+(?=[[(])/
        ],
        beginScope: { 2: "keyword" }
      };
      const END = {
        begin: [
          /^\s*/,
          /end/,
          /\s+/,
          /(extension\b)?/
        ],
        beginScope: {
          2: "keyword",
          4: "keyword"
        }
      };
      const INLINE_MODES = [
        { match: /\.inline\b/ },
        {
          begin: /\binline(?=\s)/,
          keywords: "inline"
        }
      ];
      const USING_PARAM_CLAUSE = {
        begin: [
          /\(\s*/,
          /using/,
          /\s+(?!\))/
        ],
        beginScope: { 2: "keyword" }
      };
      const DIRECTIVE_VALUE = {
        className: "string",
        begin: /\S+/
      };
      const USING_DIRECTIVE = {
        begin: [
          "//>",
          /\s+/,
          /using/,
          /\s+/,
          /\S+/
        ],
        beginScope: {
          1: "comment",
          3: "keyword",
          5: "type"
        },
        end: /$/,
        contains: [
          DIRECTIVE_VALUE
        ]
      };
      return {
        name: "Scala",
        keywords: {
          literal: "true false null",
          keyword: "type yield lazy override def with val var sealed abstract private trait object if then forSome for while do throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit export enum given transparent"
        },
        contains: [
          USING_DIRECTIVE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          STRING,
          TYPE,
          METHOD,
          CLASS,
          hljs.C_NUMBER_MODE,
          EXTENSION,
          END,
          ...INLINE_MODES,
          USING_PARAM_CLAUSE,
          ANNOTATION
        ]
      };
    }
    module2.exports = scala;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/shell.js
var require_shell = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/shell.js"(exports, module2) {
    function shell(hljs) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    module2.exports = shell;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/sql.js
var require_sql = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/sql.js"(exports, module2) {
    function sql(hljs) {
      const regex = hljs.regex;
      const COMMENT_MODE = hljs.COMMENT("--", "$");
      const STRING = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      };
      const QUOTED_IDENTIFIER = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      };
      const LITERALS = [
        "true",
        "false",
        "unknown"
      ];
      const MULTI_WORD_TYPES = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ];
      const TYPES = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        "varbinary"
      ];
      const NON_RESERVED_WORDS = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ];
      const RESERVED_WORDS = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ];
      const RESERVED_FUNCTIONS = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ];
      const POSSIBLE_WITHOUT_PARENS = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ];
      const COMBOS = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ];
      const FUNCTIONS = RESERVED_FUNCTIONS;
      const KEYWORDS = [
        ...RESERVED_WORDS,
        ...NON_RESERVED_WORDS
      ].filter((keyword) => {
        return !RESERVED_FUNCTIONS.includes(keyword);
      });
      const VARIABLE = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      };
      const OPERATOR = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      };
      const FUNCTION_CALL = {
        match: regex.concat(/\b/, regex.either(...FUNCTIONS), /\s*\(/),
        relevance: 0,
        keywords: { built_in: FUNCTIONS }
      };
      function kws_to_regex(list) {
        return regex.concat(/\b/, regex.either(...list.map((kw) => {
          return kw.replace(/\s+/, "\\s+");
        })), /\b/);
      }
      const MULTI_WORD_KEYWORDS = {
        scope: "keyword",
        match: kws_to_regex(COMBOS),
        relevance: 0
      };
      function reduceRelevancy(list, {
        exceptions,
        when
      } = {}) {
        const qualifyFn = when;
        exceptions = exceptions || [];
        return list.map((item) => {
          if (item.match(/\|\d+$/) || exceptions.includes(item)) {
            return item;
          } else if (qualifyFn(item)) {
            return `${item}|0`;
          } else {
            return item;
          }
        });
      }
      return {
        name: "SQL",
        case_insensitive: true,
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
          literal: LITERALS,
          type: TYPES,
          built_in: POSSIBLE_WITHOUT_PARENS
        },
        contains: [
          {
            scope: "type",
            match: kws_to_regex(MULTI_WORD_TYPES)
          },
          MULTI_WORD_KEYWORDS,
          FUNCTION_CALL,
          VARIABLE,
          STRING,
          QUOTED_IDENTIFIER,
          hljs.C_NUMBER_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          COMMENT_MODE,
          OPERATOR
        ]
      };
    }
    module2.exports = sql;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/swift.js
var require_swift = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/swift.js"(exports, module2) {
    function source(re) {
      if (!re)
        return null;
      if (typeof re === "string")
        return re;
      return re.source;
    }
    function lookahead(re) {
      return concat("(?=", re, ")");
    }
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
      return joined;
    }
    var keywordWrapper = (keyword) => concat(/\b/, keyword, /\w$/.test(keyword) ? /\b/ : /\B/);
    var dotKeywords = [
      "Protocol",
      "Type"
    ].map(keywordWrapper);
    var optionalDotKeywords = [
      "init",
      "self"
    ].map(keywordWrapper);
    var keywordTypes = [
      "Any",
      "Self"
    ];
    var keywords = [
      "actor",
      "any",
      "associatedtype",
      "async",
      "await",
      /as\?/,
      /as!/,
      "as",
      "borrowing",
      "break",
      "case",
      "catch",
      "class",
      "consume",
      "consuming",
      "continue",
      "convenience",
      "copy",
      "default",
      "defer",
      "deinit",
      "didSet",
      "distributed",
      "do",
      "dynamic",
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      "for",
      "func",
      "get",
      "guard",
      "if",
      "import",
      "indirect",
      "infix",
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      "isolated",
      "nonisolated",
      "lazy",
      "let",
      "macro",
      "mutating",
      "nonmutating",
      /open\(set\)/,
      "open",
      "operator",
      "optional",
      "override",
      "package",
      "postfix",
      "precedencegroup",
      "prefix",
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      "rethrows",
      "return",
      "set",
      "some",
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      /try!/,
      "try",
      "typealias",
      /unowned\(safe\)/,
      /unowned\(unsafe\)/,
      "unowned",
      "var",
      "weak",
      "where",
      "while",
      "willSet"
    ];
    var literals = [
      "false",
      "nil",
      "true"
    ];
    var precedencegroupKeywords = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ];
    var numberSignKeywords = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ];
    var builtIns = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ];
    var operatorHead = either(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/);
    var operatorCharacter = either(operatorHead, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/);
    var operator = concat(operatorHead, operatorCharacter, "*");
    var identifierHead = either(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/);
    var identifierCharacter = either(identifierHead, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/);
    var identifier = concat(identifierHead, identifierCharacter, "*");
    var typeIdentifier = concat(/[A-Z]/, identifierCharacter, "*");
    var keywordAttributes = [
      "attached",
      "autoclosure",
      concat(/convention\(/, either("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      concat(/objc\(/, identifier, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ];
    var availabilityKeywords = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function swift(hljs) {
      const WHITESPACE = {
        match: /\s+/,
        relevance: 0
      };
      const BLOCK_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] });
      const COMMENTS = [
        hljs.C_LINE_COMMENT_MODE,
        BLOCK_COMMENT
      ];
      const DOT_KEYWORD = {
        match: [
          /\./,
          either(...dotKeywords, ...optionalDotKeywords)
        ],
        className: { 2: "keyword" }
      };
      const KEYWORD_GUARD = {
        match: concat(/\./, either(...keywords)),
        relevance: 0
      };
      const PLAIN_KEYWORDS = keywords.filter((kw) => typeof kw === "string").concat(["_|0"]);
      const REGEX_KEYWORDS = keywords.filter((kw) => typeof kw !== "string").concat(keywordTypes).map(keywordWrapper);
      const KEYWORD = { variants: [
        {
          className: "keyword",
          match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)
        }
      ] };
      const KEYWORDS = {
        $pattern: either(/\b\w+/, /#\w+/),
        keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
        literal: literals
      };
      const KEYWORD_MODES = [
        DOT_KEYWORD,
        KEYWORD_GUARD,
        KEYWORD
      ];
      const BUILT_IN_GUARD = {
        match: concat(/\./, either(...builtIns)),
        relevance: 0
      };
      const BUILT_IN = {
        className: "built_in",
        match: concat(/\b/, either(...builtIns), /(?=\()/)
      };
      const BUILT_INS = [
        BUILT_IN_GUARD,
        BUILT_IN
      ];
      const OPERATOR_GUARD = {
        match: /->/,
        relevance: 0
      };
      const OPERATOR = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: operator },
          {
            match: `\\.(\\.|${operatorCharacter})+`
          }
        ]
      };
      const OPERATORS = [
        OPERATOR_GUARD,
        OPERATOR
      ];
      const decimalDigits = "([0-9]_*)+";
      const hexDigits = "([0-9a-fA-F]_*)+";
      const NUMBER = {
        className: "number",
        relevance: 0,
        variants: [
          { match: `\\b(${decimalDigits})(\\.(${decimalDigits}))?([eE][+-]?(${decimalDigits}))?\\b` },
          { match: `\\b0x(${hexDigits})(\\.(${hexDigits}))?([pP][+-]?(${decimalDigits}))?\\b` },
          { match: /\b0o([0-7]_*)+\b/ },
          { match: /\b0b([01]_*)+\b/ }
        ]
      };
      const ESCAPED_CHARACTER = (rawDelimiter = "") => ({
        className: "subst",
        variants: [
          { match: concat(/\\/, rawDelimiter, /[0\\tnr"']/) },
          { match: concat(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      });
      const ESCAPED_NEWLINE = (rawDelimiter = "") => ({
        className: "subst",
        match: concat(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
      });
      const INTERPOLATION = (rawDelimiter = "") => ({
        className: "subst",
        label: "interpol",
        begin: concat(/\\/, rawDelimiter, /\(/),
        end: /\)/
      });
      const MULTILINE_STRING = (rawDelimiter = "") => ({
        begin: concat(rawDelimiter, /"""/),
        end: concat(/"""/, rawDelimiter),
        contains: [
          ESCAPED_CHARACTER(rawDelimiter),
          ESCAPED_NEWLINE(rawDelimiter),
          INTERPOLATION(rawDelimiter)
        ]
      });
      const SINGLE_LINE_STRING = (rawDelimiter = "") => ({
        begin: concat(rawDelimiter, /"/),
        end: concat(/"/, rawDelimiter),
        contains: [
          ESCAPED_CHARACTER(rawDelimiter),
          INTERPOLATION(rawDelimiter)
        ]
      });
      const STRING = {
        className: "string",
        variants: [
          MULTILINE_STRING(),
          MULTILINE_STRING("#"),
          MULTILINE_STRING("##"),
          MULTILINE_STRING("###"),
          SINGLE_LINE_STRING(),
          SINGLE_LINE_STRING("#"),
          SINGLE_LINE_STRING("##"),
          SINGLE_LINE_STRING("###")
        ]
      };
      const REGEXP_CONTENTS = [
        hljs.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [hljs.BACKSLASH_ESCAPE]
        }
      ];
      const BARE_REGEXP_LITERAL = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: REGEXP_CONTENTS
      };
      const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {
        const begin = concat(rawDelimiter, /\//);
        const end = concat(/\//, rawDelimiter);
        return {
          begin,
          end,
          contains: [
            ...REGEXP_CONTENTS,
            {
              scope: "comment",
              begin: `#(?!.*${end})`,
              end: /$/
            }
          ]
        };
      };
      const REGEXP = {
        scope: "regexp",
        variants: [
          EXTENDED_REGEXP_LITERAL("###"),
          EXTENDED_REGEXP_LITERAL("##"),
          EXTENDED_REGEXP_LITERAL("#"),
          BARE_REGEXP_LITERAL
        ]
      };
      const QUOTED_IDENTIFIER = { match: concat(/`/, identifier, /`/) };
      const IMPLICIT_PARAMETER = {
        className: "variable",
        match: /\$\d+/
      };
      const PROPERTY_WRAPPER_PROJECTION = {
        className: "variable",
        match: `\\$${identifierCharacter}+`
      };
      const IDENTIFIERS = [
        QUOTED_IDENTIFIER,
        IMPLICIT_PARAMETER,
        PROPERTY_WRAPPER_PROJECTION
      ];
      const AVAILABLE_ATTRIBUTE = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: availabilityKeywords,
            contains: [
              ...OPERATORS,
              NUMBER,
              STRING
            ]
          }
        ] }
      };
      const KEYWORD_ATTRIBUTE = {
        scope: "keyword",
        match: concat(/@/, either(...keywordAttributes), lookahead(either(/\(/, /\s+/)))
      };
      const USER_DEFINED_ATTRIBUTE = {
        scope: "meta",
        match: concat(/@/, identifier)
      };
      const ATTRIBUTES = [
        AVAILABLE_ATTRIBUTE,
        KEYWORD_ATTRIBUTE,
        USER_DEFINED_ATTRIBUTE
      ];
      const TYPE = {
        match: lookahead(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            className: "type",
            match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, "+")
          },
          {
            className: "type",
            match: typeIdentifier,
            relevance: 0
          },
          {
            match: /[?!]+/,
            relevance: 0
          },
          {
            match: /\.\.\./,
            relevance: 0
          },
          {
            match: concat(/\s+&\s+/, lookahead(typeIdentifier)),
            relevance: 0
          }
        ]
      };
      const GENERIC_ARGUMENTS = {
        begin: /</,
        end: />/,
        keywords: KEYWORDS,
        contains: [
          ...COMMENTS,
          ...KEYWORD_MODES,
          ...ATTRIBUTES,
          OPERATOR_GUARD,
          TYPE
        ]
      };
      TYPE.contains.push(GENERIC_ARGUMENTS);
      const TUPLE_ELEMENT_NAME = {
        match: concat(identifier, /\s*:/),
        keywords: "_|0",
        relevance: 0
      };
      const TUPLE = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: KEYWORDS,
        contains: [
          "self",
          TUPLE_ELEMENT_NAME,
          ...COMMENTS,
          REGEXP,
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS,
          ...ATTRIBUTES,
          TYPE
        ]
      };
      const GENERIC_PARAMETERS = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...COMMENTS,
          TYPE
        ]
      };
      const FUNCTION_PARAMETER_NAME = {
        begin: either(lookahead(concat(identifier, /\s*:/)), lookahead(concat(identifier, /\s+/, identifier, /\s*:/))),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: identifier
          }
        ]
      };
      const FUNCTION_PARAMETERS = {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        contains: [
          FUNCTION_PARAMETER_NAME,
          ...COMMENTS,
          ...KEYWORD_MODES,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...ATTRIBUTES,
          TYPE,
          TUPLE
        ],
        endsParent: true,
        illegal: /["']/
      };
      const FUNCTION_OR_MACRO = {
        match: [
          /(func|macro)/,
          /\s+/,
          either(QUOTED_IDENTIFIER.match, identifier, operator)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          GENERIC_PARAMETERS,
          FUNCTION_PARAMETERS,
          WHITESPACE
        ],
        illegal: [
          /\[/,
          /%/
        ]
      };
      const INIT_SUBSCRIPT = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          GENERIC_PARAMETERS,
          FUNCTION_PARAMETERS,
          WHITESPACE
        ],
        illegal: /\[|%/
      };
      const OPERATOR_DECLARATION = {
        match: [
          /operator/,
          /\s+/,
          operator
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      };
      const PRECEDENCEGROUP = {
        begin: [
          /precedencegroup/,
          /\s+/,
          typeIdentifier
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [TYPE],
        keywords: [
          ...precedencegroupKeywords,
          ...literals
        ],
        end: /}/
      };
      const CLASS_FUNC_DECLARATION = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      };
      const CLASS_VAR_DECLARATION = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      };
      const TYPE_DECLARATION = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          identifier,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: KEYWORDS,
        contains: [
          GENERIC_PARAMETERS,
          ...KEYWORD_MODES,
          {
            begin: /:/,
            end: /\{/,
            keywords: KEYWORDS,
            contains: [
              {
                scope: "title.class.inherited",
                match: typeIdentifier
              },
              ...KEYWORD_MODES
            ],
            relevance: 0
          }
        ]
      };
      for (const variant of STRING.variants) {
        const interpolation = variant.contains.find((mode) => mode.label === "interpol");
        interpolation.keywords = KEYWORDS;
        const submodes = [
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS
        ];
        interpolation.contains = [
          ...submodes,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...submodes
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: KEYWORDS,
        contains: [
          ...COMMENTS,
          FUNCTION_OR_MACRO,
          INIT_SUBSCRIPT,
          CLASS_FUNC_DECLARATION,
          CLASS_VAR_DECLARATION,
          TYPE_DECLARATION,
          OPERATOR_DECLARATION,
          PRECEDENCEGROUP,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...COMMENTS],
            relevance: 0
          },
          REGEXP,
          ...KEYWORD_MODES,
          ...BUILT_INS,
          ...OPERATORS,
          NUMBER,
          STRING,
          ...IDENTIFIERS,
          ...ATTRIBUTES,
          TYPE,
          TUPLE
        ]
      };
    }
    module2.exports = swift;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/latex.js
var require_latex = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/latex.js"(exports, module2) {
    function latex(hljs) {
      const regex = hljs.regex;
      const KNOWN_CONTROL_WORDS = regex.either(...[
        "(?:NeedsTeXFormat|RequirePackage|GetIdInfo)",
        "Provides(?:Expl)?(?:Package|Class|File)",
        "(?:DeclareOption|ProcessOptions)",
        "(?:documentclass|usepackage|input|include)",
        "makeat(?:letter|other)",
        "ExplSyntax(?:On|Off)",
        "(?:new|renew|provide)?command",
        "(?:re)newenvironment",
        "(?:New|Renew|Provide|Declare)(?:Expandable)?DocumentCommand",
        "(?:New|Renew|Provide|Declare)DocumentEnvironment",
        "(?:(?:e|g|x)?def|let)",
        "(?:begin|end)",
        "(?:part|chapter|(?:sub){0,2}section|(?:sub)?paragraph)",
        "caption",
        "(?:label|(?:eq|page|name)?ref|(?:paren|foot|super)?cite)",
        "(?:alpha|beta|[Gg]amma|[Dd]elta|(?:var)?epsilon|zeta|eta|[Tt]heta|vartheta)",
        "(?:iota|(?:var)?kappa|[Ll]ambda|mu|nu|[Xx]i|[Pp]i|varpi|(?:var)rho)",
        "(?:[Ss]igma|varsigma|tau|[Uu]psilon|[Pp]hi|varphi|chi|[Pp]si|[Oo]mega)",
        "(?:frac|sum|prod|lim|infty|times|sqrt|leq|geq|left|right|middle|[bB]igg?)",
        "(?:[lr]angle|q?quad|[lcvdi]?dots|d?dot|hat|tilde|bar)"
      ].map((word) => word + "(?![a-zA-Z@:_])"));
      const L3_REGEX = new RegExp([
        "(?:__)?[a-zA-Z]{2,}_[a-zA-Z](?:_?[a-zA-Z])+:[a-zA-Z]*",
        "[lgc]__?[a-zA-Z](?:_?[a-zA-Z])*_[a-zA-Z]{2,}",
        "[qs]__?[a-zA-Z](?:_?[a-zA-Z])+",
        "use(?:_i)?:[a-zA-Z]*",
        "(?:else|fi|or):",
        "(?:if|cs|exp):w",
        "(?:hbox|vbox):n",
        "::[a-zA-Z]_unbraced",
        "::[a-zA-Z:]"
      ].map((pattern) => pattern + "(?![a-zA-Z:_])").join("|"));
      const L2_VARIANTS = [
        { begin: /[a-zA-Z@]+/ },
        { begin: /[^a-zA-Z@]?/ }
      ];
      const DOUBLE_CARET_VARIANTS = [
        { begin: /\^{6}[0-9a-f]{6}/ },
        { begin: /\^{5}[0-9a-f]{5}/ },
        { begin: /\^{4}[0-9a-f]{4}/ },
        { begin: /\^{3}[0-9a-f]{3}/ },
        { begin: /\^{2}[0-9a-f]{2}/ },
        { begin: /\^{2}[\u0000-\u007f]/ }
      ];
      const CONTROL_SEQUENCE = {
        className: "keyword",
        begin: /\\/,
        relevance: 0,
        contains: [
          {
            endsParent: true,
            begin: KNOWN_CONTROL_WORDS
          },
          {
            endsParent: true,
            begin: L3_REGEX
          },
          {
            endsParent: true,
            variants: DOUBLE_CARET_VARIANTS
          },
          {
            endsParent: true,
            relevance: 0,
            variants: L2_VARIANTS
          }
        ]
      };
      const MACRO_PARAM = {
        className: "params",
        relevance: 0,
        begin: /#+\d?/
      };
      const DOUBLE_CARET_CHAR = {
        variants: DOUBLE_CARET_VARIANTS
      };
      const SPECIAL_CATCODE = {
        className: "built_in",
        relevance: 0,
        begin: /[$&^_]/
      };
      const MAGIC_COMMENT = {
        className: "meta",
        begin: /% ?!(T[eE]X|tex|BIB|bib)/,
        end: "$",
        relevance: 10
      };
      const COMMENT = hljs.COMMENT("%", "$", { relevance: 0 });
      const EVERYTHING_BUT_VERBATIM = [
        CONTROL_SEQUENCE,
        MACRO_PARAM,
        DOUBLE_CARET_CHAR,
        SPECIAL_CATCODE,
        MAGIC_COMMENT,
        COMMENT
      ];
      const BRACE_GROUP_NO_VERBATIM = {
        begin: /\{/,
        end: /\}/,
        relevance: 0,
        contains: [
          "self",
          ...EVERYTHING_BUT_VERBATIM
        ]
      };
      const ARGUMENT_BRACES = hljs.inherit(BRACE_GROUP_NO_VERBATIM, {
        relevance: 0,
        endsParent: true,
        contains: [
          BRACE_GROUP_NO_VERBATIM,
          ...EVERYTHING_BUT_VERBATIM
        ]
      });
      const ARGUMENT_BRACKETS = {
        begin: /\[/,
        end: /\]/,
        endsParent: true,
        relevance: 0,
        contains: [
          BRACE_GROUP_NO_VERBATIM,
          ...EVERYTHING_BUT_VERBATIM
        ]
      };
      const SPACE_GOBBLER = {
        begin: /\s+/,
        relevance: 0
      };
      const ARGUMENT_M = [ARGUMENT_BRACES];
      const ARGUMENT_O = [ARGUMENT_BRACKETS];
      const ARGUMENT_AND_THEN = function(arg, starts_mode) {
        return {
          contains: [SPACE_GOBBLER],
          starts: {
            relevance: 0,
            contains: arg,
            starts: starts_mode
          }
        };
      };
      const CSNAME = function(csname, starts_mode) {
        return {
          begin: "\\\\" + csname + "(?![a-zA-Z@:_])",
          keywords: {
            $pattern: /\\[a-zA-Z]+/,
            keyword: "\\" + csname
          },
          relevance: 0,
          contains: [SPACE_GOBBLER],
          starts: starts_mode
        };
      };
      const BEGIN_ENV = function(envname, starts_mode) {
        return hljs.inherit({
          begin: "\\\\begin(?=[ 	]*(\\r?\\n[ 	]*)?\\{" + envname + "\\})",
          keywords: {
            $pattern: /\\[a-zA-Z]+/,
            keyword: "\\begin"
          },
          relevance: 0
        }, ARGUMENT_AND_THEN(ARGUMENT_M, starts_mode));
      };
      const VERBATIM_DELIMITED_EQUAL = (innerName = "string") => {
        return hljs.END_SAME_AS_BEGIN({
          className: innerName,
          begin: /(.|\r?\n)/,
          end: /(.|\r?\n)/,
          excludeBegin: true,
          excludeEnd: true,
          endsParent: true
        });
      };
      const VERBATIM_DELIMITED_ENV = function(envname) {
        return {
          className: "string",
          end: "(?=\\\\end\\{" + envname + "\\})"
        };
      };
      const VERBATIM_DELIMITED_BRACES = (innerName = "string") => {
        return {
          relevance: 0,
          begin: /\{/,
          starts: {
            endsParent: true,
            contains: [
              {
                className: innerName,
                end: /(?=\})/,
                endsParent: true,
                contains: [
                  {
                    begin: /\{/,
                    end: /\}/,
                    relevance: 0,
                    contains: ["self"]
                  }
                ]
              }
            ]
          }
        };
      };
      const VERBATIM = [
        ...[
          "verb",
          "lstinline"
        ].map((csname) => CSNAME(csname, { contains: [VERBATIM_DELIMITED_EQUAL()] })),
        CSNAME("mint", ARGUMENT_AND_THEN(ARGUMENT_M, { contains: [VERBATIM_DELIMITED_EQUAL()] })),
        CSNAME("mintinline", ARGUMENT_AND_THEN(ARGUMENT_M, { contains: [
          VERBATIM_DELIMITED_BRACES(),
          VERBATIM_DELIMITED_EQUAL()
        ] })),
        CSNAME("url", { contains: [
          VERBATIM_DELIMITED_BRACES("link"),
          VERBATIM_DELIMITED_BRACES("link")
        ] }),
        CSNAME("hyperref", { contains: [VERBATIM_DELIMITED_BRACES("link")] }),
        CSNAME("href", ARGUMENT_AND_THEN(ARGUMENT_O, { contains: [VERBATIM_DELIMITED_BRACES("link")] })),
        ...[].concat(...[
          "",
          "\\*"
        ].map((suffix) => [
          BEGIN_ENV("verbatim" + suffix, VERBATIM_DELIMITED_ENV("verbatim" + suffix)),
          BEGIN_ENV("filecontents" + suffix, ARGUMENT_AND_THEN(ARGUMENT_M, VERBATIM_DELIMITED_ENV("filecontents" + suffix))),
          ...[
            "",
            "B",
            "L"
          ].map((prefix) => BEGIN_ENV(prefix + "Verbatim" + suffix, ARGUMENT_AND_THEN(ARGUMENT_O, VERBATIM_DELIMITED_ENV(prefix + "Verbatim" + suffix))))
        ])),
        BEGIN_ENV("minted", ARGUMENT_AND_THEN(ARGUMENT_O, ARGUMENT_AND_THEN(ARGUMENT_M, VERBATIM_DELIMITED_ENV("minted"))))
      ];
      return {
        name: "LaTeX",
        aliases: ["tex"],
        contains: [
          ...VERBATIM,
          ...EVERYTHING_BUT_VERBATIM
        ]
      };
    }
    module2.exports = latex;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/typescript.js
var require_typescript = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/typescript.js"(exports, module2) {
    var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    var KEYWORDS = [
      "as",
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      "using"
    ];
    var LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    var TYPES = [
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      "Math",
      "Date",
      "Number",
      "BigInt",
      "String",
      "RegExp",
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      "Reflect",
      "Proxy",
      "Intl",
      "WebAssembly"
    ];
    var ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    var BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    var BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
    ];
    var BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
    function javascript(hljs) {
      const regex = hljs.regex;
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };
      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: "<>",
        end: "</>"
      };
      const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          if (nextChar === "<" || nextChar === ",") {
            response.ignoreMatch();
            return;
          }
          if (nextChar === ">") {
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
          let m;
          const afterMatch = match.input.substring(afterMatchIndex);
          if (m = afterMatch.match(/^\s*=/)) {
            response.ignoreMatch();
            return;
          }
          if (m = afterMatch.match(/^\s+extends\s+/)) {
            if (m.index === 0) {
              response.ignoreMatch();
              return;
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS,
        "variable.language": BUILT_IN_VARIABLES
      };
      const decimalDigits = "[0-9](_?[0-9])*";
      const frac = `\\.(${decimalDigits})`;
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: "number",
        variants: [
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      };
      const SUBST = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: KEYWORDS$1,
        contains: []
      };
      const HTML_TEMPLATE = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "xml"
        }
      };
      const CSS_TEMPLATE = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "css"
        }
      };
      const GRAPHQL_TEMPLATE = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "graphql"
        }
      };
      const TEMPLATE_STRING = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
        relevance: 0,
        contains: [
          {
            begin: "(?=@[A-Za-z]+)",
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              },
              {
                className: "type",
                begin: "\\{",
                end: "\\}",
                excludeEnd: true,
                excludeBegin: true,
                relevance: 0
              },
              {
                className: "variable",
                begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              },
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      });
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        { match: /\$\d+/ },
        NUMBER
      ];
      SUBST.contains = SUBST_INTERNALS.concat({
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: "params",
        begin: /(\s*)\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };
      const CLASS_OR_EXTENDS = {
        variants: [
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1,
              /\s+/,
              /extends/,
              /\s+/,
              regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          {
            match: [
              /class/,
              /\s+/,
              IDENT_RE$1
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      };
      const CLASS_REFERENCE = {
        relevance: 0,
        match: regex.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
        className: "title.class",
        keywords: {
          _: [
            ...TYPES,
            ...ERROR_TYPES
          ]
        }
      };
      const USE_STRICT = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      };
      const FUNCTION_DEFINITION = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              IDENT_RE$1,
              /(?=\s*\()/
            ]
          },
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [PARAMS],
        illegal: /%/
      };
      const UPPER_CASE_CONSTANT = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function noneOf(list) {
        return regex.concat("(?!", list.join("|"), ")");
      }
      const FUNCTION_CALL = {
        match: regex.concat(/\b/, noneOf([
          ...BUILT_IN_GLOBALS,
          "super",
          "import"
        ].map((x) => `${x}\\s*\\(`)), IDENT_RE$1, regex.lookahead(/\s*\(/)),
        className: "title.function",
        relevance: 0
      };
      const PROPERTY_ACCESS = {
        begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),
        end: IDENT_RE$1,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      };
      const GETTER_OR_SETTER = {
        match: [
          /get|set/,
          /\s+/,
          IDENT_RE$1,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            begin: /\(\)/
          },
          PARAMS
        ]
      };
      const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
      const FUNCTION_VARIABLE = {
        match: [
          /const|var|let/,
          /\s+/,
          IDENT_RE$1,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          regex.lookahead(FUNC_LEAD_IN_RE)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          PARAMS
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: KEYWORDS$1,
        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          USE_STRICT,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          GRAPHQL_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          { match: /\$\d+/ },
          NUMBER,
          CLASS_REFERENCE,
          {
            scope: "attr",
            match: IDENT_RE$1 + regex.lookahead(":"),
            relevance: 0
          },
          FUNCTION_VARIABLE,
          {
            begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: "function",
                begin: FUNC_LEAD_IN_RE,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              {
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  { match: XML_SELF_CLOSING },
                  {
                    begin: XML_TAG.begin,
                    "on:begin": XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          FUNCTION_DEFINITION,
          {
            beginKeywords: "while if switch catch for"
          },
          {
            begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            returnBegin: true,
            label: "func.def",
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
            ]
          },
          {
            match: /\.\.\./,
            relevance: 0
          },
          PROPERTY_ACCESS,
          {
            match: "\\$" + IDENT_RE$1,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [PARAMS]
          },
          FUNCTION_CALL,
          UPPER_CASE_CONSTANT,
          CLASS_OR_EXTENDS,
          GETTER_OR_SETTER,
          {
            match: /\$[(.]/
          }
        ]
      };
    }
    function typescript(hljs) {
      const regex = hljs.regex;
      const tsLanguage = javascript(hljs);
      const IDENT_RE$1 = IDENT_RE;
      const TYPES2 = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ];
      const NAMESPACE = {
        begin: [
          /namespace/,
          /\s+/,
          hljs.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      };
      const INTERFACE = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: TYPES2
        },
        contains: [tsLanguage.exports.CLASS_REFERENCE]
      };
      const USE_STRICT = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      };
      const TS_SPECIFIC_KEYWORDS = [
        "type",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ];
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
        literal: LITERALS,
        built_in: BUILT_INS.concat(TYPES2),
        "variable.language": BUILT_IN_VARIABLES
      };
      const DECORATOR = {
        className: "meta",
        begin: "@" + IDENT_RE$1
      };
      const swapMode = (mode, label, replacement) => {
        const indx = mode.contains.findIndex((m) => m.label === label);
        if (indx === -1) {
          throw new Error("can not find mode to replace");
        }
        mode.contains.splice(indx, 1, replacement);
      };
      Object.assign(tsLanguage.keywords, KEYWORDS$1);
      tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
      const ATTRIBUTE_HIGHLIGHT = tsLanguage.contains.find((c) => c.scope === "attr");
      const OPTIONAL_KEY_OR_ARGUMENT = Object.assign({}, ATTRIBUTE_HIGHLIGHT, { match: regex.concat(IDENT_RE$1, regex.lookahead(/\s*\?:/)) });
      tsLanguage.exports.PARAMS_CONTAINS.push([
        tsLanguage.exports.CLASS_REFERENCE,
        ATTRIBUTE_HIGHLIGHT,
        OPTIONAL_KEY_OR_ARGUMENT
      ]);
      tsLanguage.contains = tsLanguage.contains.concat([
        DECORATOR,
        NAMESPACE,
        INTERFACE,
        OPTIONAL_KEY_OR_ARGUMENT
      ]);
      swapMode(tsLanguage, "shebang", hljs.SHEBANG());
      swapMode(tsLanguage, "use_strict", USE_STRICT);
      const functionDeclaration = tsLanguage.contains.find((m) => m.label === "func.def");
      functionDeclaration.relevance = 0;
      Object.assign(tsLanguage, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      });
      return tsLanguage;
    }
    module2.exports = typescript;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/verilog.js
var require_verilog = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/verilog.js"(exports, module2) {
    function verilog(hljs) {
      const regex = hljs.regex;
      const KEYWORDS = {
        $pattern: /\$?[\w]+(\$[\w]+)*/,
        keyword: [
          "accept_on",
          "alias",
          "always",
          "always_comb",
          "always_ff",
          "always_latch",
          "and",
          "assert",
          "assign",
          "assume",
          "automatic",
          "before",
          "begin",
          "bind",
          "bins",
          "binsof",
          "bit",
          "break",
          "buf|0",
          "bufif0",
          "bufif1",
          "byte",
          "case",
          "casex",
          "casez",
          "cell",
          "chandle",
          "checker",
          "class",
          "clocking",
          "cmos",
          "config",
          "const",
          "constraint",
          "context",
          "continue",
          "cover",
          "covergroup",
          "coverpoint",
          "cross",
          "deassign",
          "default",
          "defparam",
          "design",
          "disable",
          "dist",
          "do",
          "edge",
          "else",
          "end",
          "endcase",
          "endchecker",
          "endclass",
          "endclocking",
          "endconfig",
          "endfunction",
          "endgenerate",
          "endgroup",
          "endinterface",
          "endmodule",
          "endpackage",
          "endprimitive",
          "endprogram",
          "endproperty",
          "endspecify",
          "endsequence",
          "endtable",
          "endtask",
          "enum",
          "event",
          "eventually",
          "expect",
          "export",
          "extends",
          "extern",
          "final",
          "first_match",
          "for",
          "force",
          "foreach",
          "forever",
          "fork",
          "forkjoin",
          "function",
          "generate|5",
          "genvar",
          "global",
          "highz0",
          "highz1",
          "if",
          "iff",
          "ifnone",
          "ignore_bins",
          "illegal_bins",
          "implements",
          "implies",
          "import",
          "incdir",
          "include",
          "initial",
          "inout",
          "input",
          "inside",
          "instance",
          "int",
          "integer",
          "interconnect",
          "interface",
          "intersect",
          "join",
          "join_any",
          "join_none",
          "large",
          "let",
          "liblist",
          "library",
          "local",
          "localparam",
          "logic",
          "longint",
          "macromodule",
          "matches",
          "medium",
          "modport",
          "module",
          "nand",
          "negedge",
          "nettype",
          "new",
          "nexttime",
          "nmos",
          "nor",
          "noshowcancelled",
          "not",
          "notif0",
          "notif1",
          "or",
          "output",
          "package",
          "packed",
          "parameter",
          "pmos",
          "posedge",
          "primitive",
          "priority",
          "program",
          "property",
          "protected",
          "pull0",
          "pull1",
          "pulldown",
          "pullup",
          "pulsestyle_ondetect",
          "pulsestyle_onevent",
          "pure",
          "rand",
          "randc",
          "randcase",
          "randsequence",
          "rcmos",
          "real",
          "realtime",
          "ref",
          "reg",
          "reject_on",
          "release",
          "repeat",
          "restrict",
          "return",
          "rnmos",
          "rpmos",
          "rtran",
          "rtranif0",
          "rtranif1",
          "s_always",
          "s_eventually",
          "s_nexttime",
          "s_until",
          "s_until_with",
          "scalared",
          "sequence",
          "shortint",
          "shortreal",
          "showcancelled",
          "signed",
          "small",
          "soft",
          "solve",
          "specify",
          "specparam",
          "static",
          "string",
          "strong",
          "strong0",
          "strong1",
          "struct",
          "super",
          "supply0",
          "supply1",
          "sync_accept_on",
          "sync_reject_on",
          "table",
          "tagged",
          "task",
          "this",
          "throughout",
          "time",
          "timeprecision",
          "timeunit",
          "tran",
          "tranif0",
          "tranif1",
          "tri",
          "tri0",
          "tri1",
          "triand",
          "trior",
          "trireg",
          "type",
          "typedef",
          "union",
          "unique",
          "unique0",
          "unsigned",
          "until",
          "until_with",
          "untyped",
          "use",
          "uwire",
          "var",
          "vectored",
          "virtual",
          "void",
          "wait",
          "wait_order",
          "wand",
          "weak",
          "weak0",
          "weak1",
          "while",
          "wildcard",
          "wire",
          "with",
          "within",
          "wor",
          "xnor",
          "xor"
        ],
        literal: ["null"],
        built_in: [
          "$finish",
          "$stop",
          "$exit",
          "$fatal",
          "$error",
          "$warning",
          "$info",
          "$realtime",
          "$time",
          "$printtimescale",
          "$bitstoreal",
          "$bitstoshortreal",
          "$itor",
          "$signed",
          "$cast",
          "$bits",
          "$stime",
          "$timeformat",
          "$realtobits",
          "$shortrealtobits",
          "$rtoi",
          "$unsigned",
          "$asserton",
          "$assertkill",
          "$assertpasson",
          "$assertfailon",
          "$assertnonvacuouson",
          "$assertoff",
          "$assertcontrol",
          "$assertpassoff",
          "$assertfailoff",
          "$assertvacuousoff",
          "$isunbounded",
          "$sampled",
          "$fell",
          "$changed",
          "$past_gclk",
          "$fell_gclk",
          "$changed_gclk",
          "$rising_gclk",
          "$steady_gclk",
          "$coverage_control",
          "$coverage_get",
          "$coverage_save",
          "$set_coverage_db_name",
          "$rose",
          "$stable",
          "$past",
          "$rose_gclk",
          "$stable_gclk",
          "$future_gclk",
          "$falling_gclk",
          "$changing_gclk",
          "$display",
          "$coverage_get_max",
          "$coverage_merge",
          "$get_coverage",
          "$load_coverage_db",
          "$typename",
          "$unpacked_dimensions",
          "$left",
          "$low",
          "$increment",
          "$clog2",
          "$ln",
          "$log10",
          "$exp",
          "$sqrt",
          "$pow",
          "$floor",
          "$ceil",
          "$sin",
          "$cos",
          "$tan",
          "$countbits",
          "$onehot",
          "$isunknown",
          "$fatal",
          "$warning",
          "$dimensions",
          "$right",
          "$high",
          "$size",
          "$asin",
          "$acos",
          "$atan",
          "$atan2",
          "$hypot",
          "$sinh",
          "$cosh",
          "$tanh",
          "$asinh",
          "$acosh",
          "$atanh",
          "$countones",
          "$onehot0",
          "$error",
          "$info",
          "$random",
          "$dist_chi_square",
          "$dist_erlang",
          "$dist_exponential",
          "$dist_normal",
          "$dist_poisson",
          "$dist_t",
          "$dist_uniform",
          "$q_initialize",
          "$q_remove",
          "$q_exam",
          "$async$and$array",
          "$async$nand$array",
          "$async$or$array",
          "$async$nor$array",
          "$sync$and$array",
          "$sync$nand$array",
          "$sync$or$array",
          "$sync$nor$array",
          "$q_add",
          "$q_full",
          "$psprintf",
          "$async$and$plane",
          "$async$nand$plane",
          "$async$or$plane",
          "$async$nor$plane",
          "$sync$and$plane",
          "$sync$nand$plane",
          "$sync$or$plane",
          "$sync$nor$plane",
          "$system",
          "$display",
          "$displayb",
          "$displayh",
          "$displayo",
          "$strobe",
          "$strobeb",
          "$strobeh",
          "$strobeo",
          "$write",
          "$readmemb",
          "$readmemh",
          "$writememh",
          "$value$plusargs",
          "$dumpvars",
          "$dumpon",
          "$dumplimit",
          "$dumpports",
          "$dumpportson",
          "$dumpportslimit",
          "$writeb",
          "$writeh",
          "$writeo",
          "$monitor",
          "$monitorb",
          "$monitorh",
          "$monitoro",
          "$writememb",
          "$dumpfile",
          "$dumpoff",
          "$dumpall",
          "$dumpflush",
          "$dumpportsoff",
          "$dumpportsall",
          "$dumpportsflush",
          "$fclose",
          "$fdisplay",
          "$fdisplayb",
          "$fdisplayh",
          "$fdisplayo",
          "$fstrobe",
          "$fstrobeb",
          "$fstrobeh",
          "$fstrobeo",
          "$swrite",
          "$swriteb",
          "$swriteh",
          "$swriteo",
          "$fscanf",
          "$fread",
          "$fseek",
          "$fflush",
          "$feof",
          "$fopen",
          "$fwrite",
          "$fwriteb",
          "$fwriteh",
          "$fwriteo",
          "$fmonitor",
          "$fmonitorb",
          "$fmonitorh",
          "$fmonitoro",
          "$sformat",
          "$sformatf",
          "$fgetc",
          "$ungetc",
          "$fgets",
          "$sscanf",
          "$rewind",
          "$ftell",
          "$ferror"
        ]
      };
      const BUILT_IN_CONSTANTS = [
        "__FILE__",
        "__LINE__"
      ];
      const DIRECTIVES = [
        "begin_keywords",
        "celldefine",
        "default_nettype",
        "default_decay_time",
        "default_trireg_strength",
        "define",
        "delay_mode_distributed",
        "delay_mode_path",
        "delay_mode_unit",
        "delay_mode_zero",
        "else",
        "elsif",
        "end_keywords",
        "endcelldefine",
        "endif",
        "ifdef",
        "ifndef",
        "include",
        "line",
        "nounconnected_drive",
        "pragma",
        "resetall",
        "timescale",
        "unconnected_drive",
        "undef",
        "undefineall"
      ];
      return {
        name: "Verilog",
        aliases: [
          "v",
          "sv",
          "svh"
        ],
        case_insensitive: false,
        keywords: KEYWORDS,
        contains: [
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            scope: "number",
            contains: [hljs.BACKSLASH_ESCAPE],
            variants: [
              { begin: /\b((\d+'([bhodBHOD]))[0-9xzXZa-fA-F_]+)/ },
              { begin: /\B(('([bhodBHOD]))[0-9xzXZa-fA-F_]+)/ },
              {
                begin: /\b[0-9][0-9_]*/,
                relevance: 0
              }
            ]
          },
          {
            scope: "variable",
            variants: [
              { begin: "#\\((?!parameter).+\\)" },
              {
                begin: "\\.\\w+",
                relevance: 0
              }
            ]
          },
          {
            scope: "variable.constant",
            match: regex.concat(/`/, regex.either(...BUILT_IN_CONSTANTS))
          },
          {
            scope: "meta",
            begin: regex.concat(/`/, regex.either(...DIRECTIVES)),
            end: /$|\/\/|\/\*/,
            returnEnd: true,
            keywords: DIRECTIVES
          }
        ]
      };
    }
    module2.exports = verilog;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/vhdl.js
var require_vhdl = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/vhdl.js"(exports, module2) {
    function vhdl(hljs) {
      const INTEGER_RE = "\\d(_|\\d)*";
      const EXPONENT_RE = "[eE][-+]?" + INTEGER_RE;
      const DECIMAL_LITERAL_RE = INTEGER_RE + "(\\." + INTEGER_RE + ")?(" + EXPONENT_RE + ")?";
      const BASED_INTEGER_RE = "\\w+";
      const BASED_LITERAL_RE = INTEGER_RE + "#" + BASED_INTEGER_RE + "(\\." + BASED_INTEGER_RE + ")?#(" + EXPONENT_RE + ")?";
      const NUMBER_RE = "\\b(" + BASED_LITERAL_RE + "|" + DECIMAL_LITERAL_RE + ")";
      const KEYWORDS = [
        "abs",
        "access",
        "after",
        "alias",
        "all",
        "and",
        "architecture",
        "array",
        "assert",
        "assume",
        "assume_guarantee",
        "attribute",
        "begin",
        "block",
        "body",
        "buffer",
        "bus",
        "case",
        "component",
        "configuration",
        "constant",
        "context",
        "cover",
        "disconnect",
        "downto",
        "default",
        "else",
        "elsif",
        "end",
        "entity",
        "exit",
        "fairness",
        "file",
        "for",
        "force",
        "function",
        "generate",
        "generic",
        "group",
        "guarded",
        "if",
        "impure",
        "in",
        "inertial",
        "inout",
        "is",
        "label",
        "library",
        "linkage",
        "literal",
        "loop",
        "map",
        "mod",
        "nand",
        "new",
        "next",
        "nor",
        "not",
        "null",
        "of",
        "on",
        "open",
        "or",
        "others",
        "out",
        "package",
        "parameter",
        "port",
        "postponed",
        "procedure",
        "process",
        "property",
        "protected",
        "pure",
        "range",
        "record",
        "register",
        "reject",
        "release",
        "rem",
        "report",
        "restrict",
        "restrict_guarantee",
        "return",
        "rol",
        "ror",
        "select",
        "sequence",
        "severity",
        "shared",
        "signal",
        "sla",
        "sll",
        "sra",
        "srl",
        "strong",
        "subtype",
        "then",
        "to",
        "transport",
        "type",
        "unaffected",
        "units",
        "until",
        "use",
        "variable",
        "view",
        "vmode",
        "vprop",
        "vunit",
        "wait",
        "when",
        "while",
        "with",
        "xnor",
        "xor"
      ];
      const BUILT_INS = [
        "boolean",
        "bit",
        "character",
        "integer",
        "time",
        "delay_length",
        "natural",
        "positive",
        "string",
        "bit_vector",
        "file_open_kind",
        "file_open_status",
        "std_logic",
        "std_logic_vector",
        "unsigned",
        "signed",
        "boolean_vector",
        "integer_vector",
        "std_ulogic",
        "std_ulogic_vector",
        "unresolved_unsigned",
        "u_unsigned",
        "unresolved_signed",
        "u_signed",
        "real_vector",
        "time_vector"
      ];
      const LITERALS = [
        "false",
        "true",
        "note",
        "warning",
        "error",
        "failure",
        "line",
        "text",
        "side",
        "width"
      ];
      return {
        name: "VHDL",
        case_insensitive: true,
        keywords: {
          keyword: KEYWORDS,
          built_in: BUILT_INS,
          literal: LITERALS
        },
        illegal: /\{/,
        contains: [
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.COMMENT("--", "$"),
          hljs.QUOTE_STRING_MODE,
          {
            className: "number",
            begin: NUMBER_RE,
            relevance: 0
          },
          {
            className: "string",
            begin: "'(U|X|0|1|Z|W|L|H|-)'",
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          {
            className: "symbol",
            begin: "'[A-Za-z](_?[A-Za-z0-9])*",
            contains: [hljs.BACKSLASH_ESCAPE]
          }
        ]
      };
    }
    module2.exports = vhdl;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/xml.js
var require_xml = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/xml.js"(exports, module2) {
    function xml(hljs) {
      const regex = hljs.regex;
      const TAG_NAME_RE = regex.concat(/[\p{L}_]/u, regex.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
      const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
      const XML_ENTITIES = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      };
      const XML_META_KEYWORDS = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      };
      const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
        begin: /\(/,
        end: /\)/
      });
      const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
      const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
      const TAG_INTERNALS = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: XML_IDENT_RE,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [XML_ENTITIES]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [XML_ENTITIES]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              XML_META_KEYWORDS,
              QUOTE_META_STRING_MODE,
              APOS_META_STRING_MODE,
              XML_META_PAR_KEYWORDS,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      XML_META_KEYWORDS,
                      XML_META_PAR_KEYWORDS,
                      QUOTE_META_STRING_MODE,
                      APOS_META_STRING_MODE
                    ]
                  }
                ]
              }
            ]
          },
          hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          XML_ENTITIES,
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  QUOTE_META_STRING_MODE
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          {
            className: "tag",
            begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\/>/, />/, /\s/)))),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0,
                starts: TAG_INTERNALS
              }
            ]
          },
          {
            className: "tag",
            begin: regex.concat(/<\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    module2.exports = xml;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/yaml.js
var require_yaml = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/yaml.js"(exports, module2) {
    function yaml(hljs) {
      const LITERALS = "true false yes no null";
      const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
      const KEY = {
        className: "attr",
        variants: [
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      };
      const TEMPLATE_VARIABLES = {
        className: "template-variable",
        variants: [
          {
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            begin: /%\{/,
            end: /\}/
          }
        ]
      };
      const SINGLE_QUOTE_STRING = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      };
      const STRING = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          hljs.BACKSLASH_ESCAPE,
          TEMPLATE_VARIABLES
        ]
      };
      const CONTAINER_STRING = hljs.inherit(STRING, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] });
      const DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
      const TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
      const FRACTION_RE = "(\\.[0-9]*)?";
      const ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
      const TIMESTAMP = {
        className: "number",
        begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
      };
      const VALUE_CONTAINER = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: LITERALS,
        relevance: 0
      };
      const OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const ARRAY = {
        begin: "\\[",
        end: "\\]",
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      const MODES = [
        KEY,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          className: "type",
          begin: "!\\w+!" + URI_CHARACTERS
        },
        {
          className: "type",
          begin: "!<" + URI_CHARACTERS + ">"
        },
        {
          className: "type",
          begin: "!" + URI_CHARACTERS
        },
        {
          className: "type",
          begin: "!!" + URI_CHARACTERS
        },
        {
          className: "meta",
          begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          className: "meta",
          begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          className: "bullet",
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        hljs.HASH_COMMENT_MODE,
        {
          beginKeywords: LITERALS,
          keywords: { literal: LITERALS }
        },
        TIMESTAMP,
        {
          className: "number",
          begin: hljs.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        OBJECT,
        ARRAY,
        SINGLE_QUOTE_STRING,
        STRING
      ];
      const VALUE_MODES = [...MODES];
      VALUE_MODES.pop();
      VALUE_MODES.push(CONTAINER_STRING);
      VALUE_CONTAINER.contains = VALUE_MODES;
      return {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: MODES
      };
    }
    module2.exports = yaml;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/diff.js
var require_diff = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/diff.js"(exports, module2) {
    function diff(hljs) {
      const regex = hljs.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: regex.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/)
          },
          {
            className: "comment",
            variants: [
              {
                begin: regex.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    module2.exports = diff;
  }
});

// ../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/protobuf.js
var require_protobuf = __commonJS({
  "../../node_modules/.pnpm/highlight.js@11.11.1/node_modules/highlight.js/lib/languages/protobuf.js"(exports, module2) {
    function protobuf(hljs) {
      const KEYWORDS = [
        "package",
        "import",
        "option",
        "optional",
        "required",
        "repeated",
        "group",
        "oneof"
      ];
      const TYPES = [
        "double",
        "float",
        "int32",
        "int64",
        "uint32",
        "uint64",
        "sint32",
        "sint64",
        "fixed32",
        "fixed64",
        "sfixed32",
        "sfixed64",
        "bool",
        "string",
        "bytes"
      ];
      const CLASS_DEFINITION = {
        match: [
          /(message|enum|service)\s+/,
          hljs.IDENT_RE
        ],
        scope: {
          1: "keyword",
          2: "title.class"
        }
      };
      return {
        name: "Protocol Buffers",
        aliases: ["proto"],
        keywords: {
          keyword: KEYWORDS,
          type: TYPES,
          literal: [
            "true",
            "false"
          ]
        },
        contains: [
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          CLASS_DEFINITION,
          {
            className: "function",
            beginKeywords: "rpc",
            end: /[{;]/,
            excludeEnd: true,
            keywords: "rpc returns"
          },
          {
            begin: /^\s*[A-Z_]+(?=\s*=[^\n]+;$)/
          }
        ]
      };
    }
    module2.exports = protobuf;
  }
});

// ../../packages/core/dist/utils/langHighlight.js
var require_langHighlight = __commonJS({
  "../../packages/core/dist/utils/langHighlight.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = __importDefault(require_core());
    var bash_1 = __importDefault(require_bash());
    var clojure_1 = __importDefault(require_clojure());
    var cpp_1 = __importDefault(require_cpp());
    var csharp_1 = __importDefault(require_csharp());
    var css_1 = __importDefault(require_css());
    var dart_1 = __importDefault(require_dart());
    var dockerfile_1 = __importDefault(require_dockerfile());
    var erlang_1 = __importDefault(require_erlang());
    var go_1 = __importDefault(require_go());
    var gradle_1 = __importDefault(require_gradle());
    var groovy_1 = __importDefault(require_groovy());
    var haskell_1 = __importDefault(require_haskell());
    var java_1 = __importDefault(require_java());
    var javascript_1 = __importDefault(require_javascript());
    var json_1 = __importDefault(require_json());
    var julia_1 = __importDefault(require_julia());
    var kotlin_1 = __importDefault(require_kotlin());
    var lisp_1 = __importDefault(require_lisp());
    var lua_1 = __importDefault(require_lua());
    var makefile_1 = __importDefault(require_makefile());
    var markdown_1 = __importDefault(require_markdown());
    var matlab_1 = __importDefault(require_matlab());
    var objectivec_1 = __importDefault(require_objectivec());
    var perl_1 = __importDefault(require_perl());
    var php_1 = __importDefault(require_php());
    var python_1 = __importDefault(require_python());
    var r_1 = __importDefault(require_r());
    var ruby_1 = __importDefault(require_ruby());
    var rust_1 = __importDefault(require_rust());
    var scala_1 = __importDefault(require_scala());
    var shell_1 = __importDefault(require_shell());
    var sql_1 = __importDefault(require_sql());
    var swift_1 = __importDefault(require_swift());
    var latex_1 = __importDefault(require_latex());
    var typescript_1 = __importDefault(require_typescript());
    var verilog_1 = __importDefault(require_verilog());
    var vhdl_1 = __importDefault(require_vhdl());
    var xml_1 = __importDefault(require_xml());
    var yaml_1 = __importDefault(require_yaml());
    var diff_1 = __importDefault(require_diff());
    var protobuf_1 = __importDefault(require_protobuf());
    core_1.default.registerLanguage("bash", bash_1.default);
    core_1.default.registerLanguage("clojure", clojure_1.default);
    core_1.default.registerLanguage("cpp", cpp_1.default);
    core_1.default.registerLanguage("cs", csharp_1.default);
    core_1.default.registerLanguage("csharp", csharp_1.default);
    core_1.default.registerLanguage("css", css_1.default);
    core_1.default.registerLanguage("dart", dart_1.default);
    core_1.default.registerLanguage("dockerfile", dockerfile_1.default);
    core_1.default.registerLanguage("erlang", erlang_1.default);
    core_1.default.registerLanguage("go", go_1.default);
    core_1.default.registerLanguage("gradle", gradle_1.default);
    core_1.default.registerLanguage("groovy", groovy_1.default);
    core_1.default.registerLanguage("haskell", haskell_1.default);
    core_1.default.registerLanguage("java", java_1.default);
    core_1.default.registerLanguage("javascript", javascript_1.default);
    core_1.default.registerLanguage("js", javascript_1.default);
    core_1.default.registerLanguage("json", json_1.default);
    core_1.default.registerLanguage("julia", julia_1.default);
    core_1.default.registerLanguage("kotlin", kotlin_1.default);
    core_1.default.registerLanguage("lisp", lisp_1.default);
    core_1.default.registerLanguage("lua", lua_1.default);
    core_1.default.registerLanguage("makefile", makefile_1.default);
    core_1.default.registerLanguage("markdown", markdown_1.default);
    core_1.default.registerLanguage("matlab", matlab_1.default);
    core_1.default.registerLanguage("objectivec", objectivec_1.default);
    core_1.default.registerLanguage("perl", perl_1.default);
    core_1.default.registerLanguage("php", php_1.default);
    core_1.default.registerLanguage("python", python_1.default);
    core_1.default.registerLanguage("r", r_1.default);
    core_1.default.registerLanguage("ruby", ruby_1.default);
    core_1.default.registerLanguage("rust", rust_1.default);
    core_1.default.registerLanguage("scala", scala_1.default);
    core_1.default.registerLanguage("shell", shell_1.default);
    core_1.default.registerLanguage("sql", sql_1.default);
    core_1.default.registerLanguage("swift", swift_1.default);
    core_1.default.registerLanguage("tex", latex_1.default);
    core_1.default.registerLanguage("latex", latex_1.default);
    core_1.default.registerLanguage("typescript", typescript_1.default);
    core_1.default.registerLanguage("ts", typescript_1.default);
    core_1.default.registerLanguage("verilog", verilog_1.default);
    core_1.default.registerLanguage("vhdl", vhdl_1.default);
    core_1.default.registerLanguage("xml", xml_1.default);
    core_1.default.registerLanguage("html", xml_1.default);
    core_1.default.registerLanguage("yaml", yaml_1.default);
    core_1.default.registerLanguage("diff", diff_1.default);
    core_1.default.registerLanguage("protobuf", protobuf_1.default);
    exports.default = core_1.default;
  }
});

// ../../packages/core/dist/MarkdownParser.js
var require_MarkdownParser = __commonJS({
  "../../packages/core/dist/MarkdownParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMarkdownParser = void 0;
    var markdown_it_1 = __importDefault(require_index_cjs4());
    var markdown_it_deflist_1 = __importDefault(require_markdown_it_deflist());
    var markdown_it_implicit_figures_1 = __importDefault(require_markdown_it_implicit_figures());
    var markdown_it_table_of_contents_1 = __importDefault(require_markdown_it_table_of_contents());
    var markdown_it_ruby_1 = __importDefault(require_markdown_it_ruby());
    var markdown_it_mark_1 = __importDefault(require_index_cjs5());
    var markdown_it_sub_1 = __importDefault(require_index_cjs6());
    var markdown_it_sup_1 = __importDefault(require_index_cjs7());
    var markdown_it_emoji_1 = require_index_cjs8();
    var markdown_it_math_1 = __importDefault(require_markdown_it_math());
    var markdown_it_span_1 = __importDefault(require_markdown_it_span());
    var markdown_it_table_container_1 = __importDefault(require_markdown_it_table_container());
    var markdown_it_linkfoot_1 = __importDefault(require_markdown_it_linkfoot());
    var markdown_it_imageflow_1 = __importDefault(require_markdown_it_imageflow());
    var markdown_it_multiquote_1 = __importDefault(require_markdown_it_multiquote());
    var markdown_it_li_1 = __importDefault(require_markdown_it_li());
    var markdown_it_github_alert_1 = __importDefault(require_markdown_it_github_alert());
    var markdown_it_task_lists_1 = __importDefault(require_markdown_it_task_lists());
    var markdown_it_checkbox_emoji_1 = __importDefault(require_markdown_it_checkbox_emoji());
    var langHighlight_1 = __importDefault(require_langHighlight());
    var createMarkdownParser2 = () => {
      const markdownParser = new markdown_it_1.default({
        html: true,
        highlight: (str, lang) => {
          if (lang === void 0 || lang === "") {
            lang = "bash";
          }
          if (lang && langHighlight_1.default.getLanguage(lang)) {
            try {
              const formatted = langHighlight_1.default.highlight(str, {
                language: lang,
                ignoreIllegals: true
              }).value;
              return '<pre class="custom"><code class="hljs">' + formatted + "</code></pre>";
            } catch (e) {
            }
          }
          return '<pre class="custom"><code class="hljs">' + markdownParser.utils.escapeHtml(str) + "</code></pre>";
        }
      });
      markdownParser.use(markdown_it_span_1.default).use(markdown_it_table_container_1.default).use(markdown_it_math_1.default).use(markdown_it_linkfoot_1.default).use(markdown_it_table_of_contents_1.default, {
        transformLink: () => "",
        includeLevel: [2, 3],
        markerPattern: /^\[toc\]/im
      }).use(markdown_it_ruby_1.default).use(markdown_it_implicit_figures_1.default, { figcaption: true }).use(markdown_it_deflist_1.default).use(markdown_it_li_1.default).use(markdown_it_imageflow_1.default).use(markdown_it_multiquote_1.default).use(markdown_it_mark_1.default).use(markdown_it_sub_1.default).use(markdown_it_sup_1.default).use(markdown_it_emoji_1.full).use(markdown_it_github_alert_1.default).use(markdown_it_task_lists_1.default, {
        enabled: true,
        label: true,
        labelAfter: true
      }).use(markdown_it_checkbox_emoji_1.default);
      return markdownParser;
    };
    exports.createMarkdownParser = createMarkdownParser2;
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/decode.json
var require_decode2 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/decode.json"(exports, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint2 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/decode_codepoint.js"(exports, module2) {
    var decodeMap = require_decode2();
    module2.exports = decodeCodePoint;
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decodeMap) {
        codePoint = decodeMap[codePoint];
      }
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/entities.json
var require_entities = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/legacy.json
var require_legacy = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/legacy.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/xml.json
var require_xml2 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/maps/xml.json"(exports, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Tokenizer.js"(exports, module2) {
    module2.exports = Tokenizer;
    var decodeCodePoint = require_decode_codepoint2();
    var entityMap = require_entities();
    var legacyMap = require_legacy();
    var xmlMap = require_xml2();
    var i = 0;
    var TEXT = i++;
    var BEFORE_TAG_NAME = i++;
    var IN_TAG_NAME = i++;
    var IN_SELF_CLOSING_TAG = i++;
    var BEFORE_CLOSING_TAG_NAME = i++;
    var IN_CLOSING_TAG_NAME = i++;
    var AFTER_CLOSING_TAG_NAME = i++;
    var BEFORE_ATTRIBUTE_NAME = i++;
    var IN_ATTRIBUTE_NAME = i++;
    var AFTER_ATTRIBUTE_NAME = i++;
    var BEFORE_ATTRIBUTE_VALUE = i++;
    var IN_ATTRIBUTE_VALUE_DQ = i++;
    var IN_ATTRIBUTE_VALUE_SQ = i++;
    var IN_ATTRIBUTE_VALUE_NQ = i++;
    var BEFORE_DECLARATION = i++;
    var IN_DECLARATION = i++;
    var IN_PROCESSING_INSTRUCTION = i++;
    var BEFORE_COMMENT = i++;
    var IN_COMMENT = i++;
    var AFTER_COMMENT_1 = i++;
    var AFTER_COMMENT_2 = i++;
    var BEFORE_CDATA_1 = i++;
    var BEFORE_CDATA_2 = i++;
    var BEFORE_CDATA_3 = i++;
    var BEFORE_CDATA_4 = i++;
    var BEFORE_CDATA_5 = i++;
    var BEFORE_CDATA_6 = i++;
    var IN_CDATA = i++;
    var AFTER_CDATA_1 = i++;
    var AFTER_CDATA_2 = i++;
    var BEFORE_SPECIAL = i++;
    var BEFORE_SPECIAL_END = i++;
    var BEFORE_SCRIPT_1 = i++;
    var BEFORE_SCRIPT_2 = i++;
    var BEFORE_SCRIPT_3 = i++;
    var BEFORE_SCRIPT_4 = i++;
    var BEFORE_SCRIPT_5 = i++;
    var AFTER_SCRIPT_1 = i++;
    var AFTER_SCRIPT_2 = i++;
    var AFTER_SCRIPT_3 = i++;
    var AFTER_SCRIPT_4 = i++;
    var AFTER_SCRIPT_5 = i++;
    var BEFORE_STYLE_1 = i++;
    var BEFORE_STYLE_2 = i++;
    var BEFORE_STYLE_3 = i++;
    var BEFORE_STYLE_4 = i++;
    var AFTER_STYLE_1 = i++;
    var AFTER_STYLE_2 = i++;
    var AFTER_STYLE_3 = i++;
    var AFTER_STYLE_4 = i++;
    var BEFORE_ENTITY = i++;
    var BEFORE_NUMERIC_ENTITY = i++;
    var IN_NAMED_ENTITY = i++;
    var IN_NUMERIC_ENTITY = i++;
    var IN_HEX_ENTITY = i++;
    var j = 0;
    var SPECIAL_NONE = j++;
    var SPECIAL_SCRIPT = j++;
    var SPECIAL_STYLE = j++;
    function whitespace(c) {
      return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
    }
    function ifElseState(upper, SUCCESS, FAILURE) {
      var lower = upper.toLowerCase();
      if (upper === lower) {
        return function(c) {
          if (c === lower) {
            this._state = SUCCESS;
          } else {
            this._state = FAILURE;
            this._index--;
          }
        };
      } else {
        return function(c) {
          if (c === lower || c === upper) {
            this._state = SUCCESS;
          } else {
            this._state = FAILURE;
            this._index--;
          }
        };
      }
    }
    function consumeSpecialNameChar(upper, NEXT_STATE) {
      var lower = upper.toLowerCase();
      return function(c) {
        if (c === lower || c === upper) {
          this._state = NEXT_STATE;
        } else {
          this._state = IN_TAG_NAME;
          this._index--;
        }
      };
    }
    function Tokenizer(options, cbs) {
      this._state = TEXT;
      this._buffer = "";
      this._sectionStart = 0;
      this._index = 0;
      this._bufferOffset = 0;
      this._baseState = TEXT;
      this._special = SPECIAL_NONE;
      this._cbs = cbs;
      this._running = true;
      this._ended = false;
      this._xmlMode = !!(options && options.xmlMode);
      this._decodeEntities = !!(options && options.decodeEntities);
    }
    Tokenizer.prototype._stateText = function(c) {
      if (c === "<") {
        if (this._index > this._sectionStart) {
          this._cbs.ontext(this._getSection());
        }
        this._state = BEFORE_TAG_NAME;
        this._sectionStart = this._index;
      } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
        if (this._index > this._sectionStart) {
          this._cbs.ontext(this._getSection());
        }
        this._baseState = TEXT;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateBeforeTagName = function(c) {
      if (c === "/") {
        this._state = BEFORE_CLOSING_TAG_NAME;
      } else if (c === "<") {
        this._cbs.ontext(this._getSection());
        this._sectionStart = this._index;
      } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
        this._state = TEXT;
      } else if (c === "!") {
        this._state = BEFORE_DECLARATION;
        this._sectionStart = this._index + 1;
      } else if (c === "?") {
        this._state = IN_PROCESSING_INSTRUCTION;
        this._sectionStart = this._index + 1;
      } else {
        this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateInTagName = function(c) {
      if (c === "/" || c === ">" || whitespace(c)) {
        this._emitToken("onopentagname");
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
      }
    };
    Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
      if (whitespace(c))
        ;
      else if (c === ">") {
        this._state = TEXT;
      } else if (this._special !== SPECIAL_NONE) {
        if (c === "s" || c === "S") {
          this._state = BEFORE_SPECIAL_END;
        } else {
          this._state = TEXT;
          this._index--;
        }
      } else {
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateInCloseingTagName = function(c) {
      if (c === ">" || whitespace(c)) {
        this._emitToken("onclosetag");
        this._state = AFTER_CLOSING_TAG_NAME;
        this._index--;
      }
    };
    Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
      if (c === ">") {
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      }
    };
    Tokenizer.prototype._stateBeforeAttributeName = function(c) {
      if (c === ">") {
        this._cbs.onopentagend();
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      } else if (c === "/") {
        this._state = IN_SELF_CLOSING_TAG;
      } else if (!whitespace(c)) {
        this._state = IN_ATTRIBUTE_NAME;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateInSelfClosingTag = function(c) {
      if (c === ">") {
        this._cbs.onselfclosingtag();
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      } else if (!whitespace(c)) {
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
      }
    };
    Tokenizer.prototype._stateInAttributeName = function(c) {
      if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
        this._cbs.onattribname(this._getSection());
        this._sectionStart = -1;
        this._state = AFTER_ATTRIBUTE_NAME;
        this._index--;
      }
    };
    Tokenizer.prototype._stateAfterAttributeName = function(c) {
      if (c === "=") {
        this._state = BEFORE_ATTRIBUTE_VALUE;
      } else if (c === "/" || c === ">") {
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
      } else if (!whitespace(c)) {
        this._cbs.onattribend();
        this._state = IN_ATTRIBUTE_NAME;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
      if (c === '"') {
        this._state = IN_ATTRIBUTE_VALUE_DQ;
        this._sectionStart = this._index + 1;
      } else if (c === "'") {
        this._state = IN_ATTRIBUTE_VALUE_SQ;
        this._sectionStart = this._index + 1;
      } else if (!whitespace(c)) {
        this._state = IN_ATTRIBUTE_VALUE_NQ;
        this._sectionStart = this._index;
        this._index--;
      }
    };
    Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
      if (c === '"') {
        this._emitToken("onattribdata");
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
      } else if (this._decodeEntities && c === "&") {
        this._emitToken("onattribdata");
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
      if (c === "'") {
        this._emitToken("onattribdata");
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
      } else if (this._decodeEntities && c === "&") {
        this._emitToken("onattribdata");
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
      if (whitespace(c) || c === ">") {
        this._emitToken("onattribdata");
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
      } else if (this._decodeEntities && c === "&") {
        this._emitToken("onattribdata");
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
      }
    };
    Tokenizer.prototype._stateBeforeDeclaration = function(c) {
      this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
    };
    Tokenizer.prototype._stateInDeclaration = function(c) {
      if (c === ">") {
        this._cbs.ondeclaration(this._getSection());
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      }
    };
    Tokenizer.prototype._stateInProcessingInstruction = function(c) {
      if (c === ">") {
        this._cbs.onprocessinginstruction(this._getSection());
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      }
    };
    Tokenizer.prototype._stateBeforeComment = function(c) {
      if (c === "-") {
        this._state = IN_COMMENT;
        this._sectionStart = this._index + 1;
      } else {
        this._state = IN_DECLARATION;
      }
    };
    Tokenizer.prototype._stateInComment = function(c) {
      if (c === "-")
        this._state = AFTER_COMMENT_1;
    };
    Tokenizer.prototype._stateAfterComment1 = function(c) {
      if (c === "-") {
        this._state = AFTER_COMMENT_2;
      } else {
        this._state = IN_COMMENT;
      }
    };
    Tokenizer.prototype._stateAfterComment2 = function(c) {
      if (c === ">") {
        this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      } else if (c !== "-") {
        this._state = IN_COMMENT;
      }
    };
    Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata6 = function(c) {
      if (c === "[") {
        this._state = IN_CDATA;
        this._sectionStart = this._index + 1;
      } else {
        this._state = IN_DECLARATION;
        this._index--;
      }
    };
    Tokenizer.prototype._stateInCdata = function(c) {
      if (c === "]")
        this._state = AFTER_CDATA_1;
    };
    Tokenizer.prototype._stateAfterCdata1 = function(c) {
      if (c === "]")
        this._state = AFTER_CDATA_2;
      else
        this._state = IN_CDATA;
    };
    Tokenizer.prototype._stateAfterCdata2 = function(c) {
      if (c === ">") {
        this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
        this._state = TEXT;
        this._sectionStart = this._index + 1;
      } else if (c !== "]") {
        this._state = IN_CDATA;
      }
    };
    Tokenizer.prototype._stateBeforeSpecial = function(c) {
      if (c === "c" || c === "C") {
        this._state = BEFORE_SCRIPT_1;
      } else if (c === "t" || c === "T") {
        this._state = BEFORE_STYLE_1;
      } else {
        this._state = IN_TAG_NAME;
        this._index--;
      }
    };
    Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
      if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
        this._state = AFTER_SCRIPT_1;
      } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
        this._state = AFTER_STYLE_1;
      } else
        this._state = TEXT;
    };
    Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
    Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
    Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
    Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
    Tokenizer.prototype._stateBeforeScript5 = function(c) {
      if (c === "/" || c === ">" || whitespace(c)) {
        this._special = SPECIAL_SCRIPT;
      }
      this._state = IN_TAG_NAME;
      this._index--;
    };
    Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
    Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
    Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
    Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
    Tokenizer.prototype._stateAfterScript5 = function(c) {
      if (c === ">" || whitespace(c)) {
        this._special = SPECIAL_NONE;
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index - 6;
        this._index--;
      } else
        this._state = TEXT;
    };
    Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
    Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
    Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
    Tokenizer.prototype._stateBeforeStyle4 = function(c) {
      if (c === "/" || c === ">" || whitespace(c)) {
        this._special = SPECIAL_STYLE;
      }
      this._state = IN_TAG_NAME;
      this._index--;
    };
    Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
    Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
    Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
    Tokenizer.prototype._stateAfterStyle4 = function(c) {
      if (c === ">" || whitespace(c)) {
        this._special = SPECIAL_NONE;
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index - 5;
        this._index--;
      } else
        this._state = TEXT;
    };
    Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
    Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
    Tokenizer.prototype._parseNamedEntityStrict = function() {
      if (this._sectionStart + 1 < this._index) {
        var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
        if (map.hasOwnProperty(entity)) {
          this._emitPartial(map[entity]);
          this._sectionStart = this._index + 1;
        }
      }
    };
    Tokenizer.prototype._parseLegacyEntity = function() {
      var start = this._sectionStart + 1, limit = this._index - start;
      if (limit > 6)
        limit = 6;
      while (limit >= 2) {
        var entity = this._buffer.substr(start, limit);
        if (legacyMap.hasOwnProperty(entity)) {
          this._emitPartial(legacyMap[entity]);
          this._sectionStart += limit + 1;
          return;
        } else {
          limit--;
        }
      }
    };
    Tokenizer.prototype._stateInNamedEntity = function(c) {
      if (c === ";") {
        this._parseNamedEntityStrict();
        if (this._sectionStart + 1 < this._index && !this._xmlMode) {
          this._parseLegacyEntity();
        }
        this._state = this._baseState;
      } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
        if (this._xmlMode)
          ;
        else if (this._sectionStart + 1 === this._index)
          ;
        else if (this._baseState !== TEXT) {
          if (c !== "=") {
            this._parseNamedEntityStrict();
          }
        } else {
          this._parseLegacyEntity();
        }
        this._state = this._baseState;
        this._index--;
      }
    };
    Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
      var sectionStart = this._sectionStart + offset;
      if (sectionStart !== this._index) {
        var entity = this._buffer.substring(sectionStart, this._index);
        var parsed = parseInt(entity, base);
        this._emitPartial(decodeCodePoint(parsed));
        this._sectionStart = this._index;
      } else {
        this._sectionStart--;
      }
      this._state = this._baseState;
    };
    Tokenizer.prototype._stateInNumericEntity = function(c) {
      if (c === ";") {
        this._decodeNumericEntity(2, 10);
        this._sectionStart++;
      } else if (c < "0" || c > "9") {
        if (!this._xmlMode) {
          this._decodeNumericEntity(2, 10);
        } else {
          this._state = this._baseState;
        }
        this._index--;
      }
    };
    Tokenizer.prototype._stateInHexEntity = function(c) {
      if (c === ";") {
        this._decodeNumericEntity(3, 16);
        this._sectionStart++;
      } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
        if (!this._xmlMode) {
          this._decodeNumericEntity(3, 16);
        } else {
          this._state = this._baseState;
        }
        this._index--;
      }
    };
    Tokenizer.prototype._cleanup = function() {
      if (this._sectionStart < 0) {
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else if (this._running) {
        if (this._state === TEXT) {
          if (this._sectionStart !== this._index) {
            this._cbs.ontext(this._buffer.substr(this._sectionStart));
          }
          this._buffer = "";
          this._bufferOffset += this._index;
          this._index = 0;
        } else if (this._sectionStart === this._index) {
          this._buffer = "";
          this._bufferOffset += this._index;
          this._index = 0;
        } else {
          this._buffer = this._buffer.substr(this._sectionStart);
          this._index -= this._sectionStart;
          this._bufferOffset += this._sectionStart;
        }
        this._sectionStart = 0;
      }
    };
    Tokenizer.prototype.write = function(chunk) {
      if (this._ended)
        this._cbs.onerror(Error(".write() after done!"));
      this._buffer += chunk;
      this._parse();
    };
    Tokenizer.prototype._parse = function() {
      while (this._index < this._buffer.length && this._running) {
        var c = this._buffer.charAt(this._index);
        if (this._state === TEXT) {
          this._stateText(c);
        } else if (this._state === BEFORE_TAG_NAME) {
          this._stateBeforeTagName(c);
        } else if (this._state === IN_TAG_NAME) {
          this._stateInTagName(c);
        } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
          this._stateBeforeCloseingTagName(c);
        } else if (this._state === IN_CLOSING_TAG_NAME) {
          this._stateInCloseingTagName(c);
        } else if (this._state === AFTER_CLOSING_TAG_NAME) {
          this._stateAfterCloseingTagName(c);
        } else if (this._state === IN_SELF_CLOSING_TAG) {
          this._stateInSelfClosingTag(c);
        } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
          this._stateBeforeAttributeName(c);
        } else if (this._state === IN_ATTRIBUTE_NAME) {
          this._stateInAttributeName(c);
        } else if (this._state === AFTER_ATTRIBUTE_NAME) {
          this._stateAfterAttributeName(c);
        } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
          this._stateBeforeAttributeValue(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
          this._stateInAttributeValueDoubleQuotes(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
          this._stateInAttributeValueSingleQuotes(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
          this._stateInAttributeValueNoQuotes(c);
        } else if (this._state === BEFORE_DECLARATION) {
          this._stateBeforeDeclaration(c);
        } else if (this._state === IN_DECLARATION) {
          this._stateInDeclaration(c);
        } else if (this._state === IN_PROCESSING_INSTRUCTION) {
          this._stateInProcessingInstruction(c);
        } else if (this._state === BEFORE_COMMENT) {
          this._stateBeforeComment(c);
        } else if (this._state === IN_COMMENT) {
          this._stateInComment(c);
        } else if (this._state === AFTER_COMMENT_1) {
          this._stateAfterComment1(c);
        } else if (this._state === AFTER_COMMENT_2) {
          this._stateAfterComment2(c);
        } else if (this._state === BEFORE_CDATA_1) {
          this._stateBeforeCdata1(c);
        } else if (this._state === BEFORE_CDATA_2) {
          this._stateBeforeCdata2(c);
        } else if (this._state === BEFORE_CDATA_3) {
          this._stateBeforeCdata3(c);
        } else if (this._state === BEFORE_CDATA_4) {
          this._stateBeforeCdata4(c);
        } else if (this._state === BEFORE_CDATA_5) {
          this._stateBeforeCdata5(c);
        } else if (this._state === BEFORE_CDATA_6) {
          this._stateBeforeCdata6(c);
        } else if (this._state === IN_CDATA) {
          this._stateInCdata(c);
        } else if (this._state === AFTER_CDATA_1) {
          this._stateAfterCdata1(c);
        } else if (this._state === AFTER_CDATA_2) {
          this._stateAfterCdata2(c);
        } else if (this._state === BEFORE_SPECIAL) {
          this._stateBeforeSpecial(c);
        } else if (this._state === BEFORE_SPECIAL_END) {
          this._stateBeforeSpecialEnd(c);
        } else if (this._state === BEFORE_SCRIPT_1) {
          this._stateBeforeScript1(c);
        } else if (this._state === BEFORE_SCRIPT_2) {
          this._stateBeforeScript2(c);
        } else if (this._state === BEFORE_SCRIPT_3) {
          this._stateBeforeScript3(c);
        } else if (this._state === BEFORE_SCRIPT_4) {
          this._stateBeforeScript4(c);
        } else if (this._state === BEFORE_SCRIPT_5) {
          this._stateBeforeScript5(c);
        } else if (this._state === AFTER_SCRIPT_1) {
          this._stateAfterScript1(c);
        } else if (this._state === AFTER_SCRIPT_2) {
          this._stateAfterScript2(c);
        } else if (this._state === AFTER_SCRIPT_3) {
          this._stateAfterScript3(c);
        } else if (this._state === AFTER_SCRIPT_4) {
          this._stateAfterScript4(c);
        } else if (this._state === AFTER_SCRIPT_5) {
          this._stateAfterScript5(c);
        } else if (this._state === BEFORE_STYLE_1) {
          this._stateBeforeStyle1(c);
        } else if (this._state === BEFORE_STYLE_2) {
          this._stateBeforeStyle2(c);
        } else if (this._state === BEFORE_STYLE_3) {
          this._stateBeforeStyle3(c);
        } else if (this._state === BEFORE_STYLE_4) {
          this._stateBeforeStyle4(c);
        } else if (this._state === AFTER_STYLE_1) {
          this._stateAfterStyle1(c);
        } else if (this._state === AFTER_STYLE_2) {
          this._stateAfterStyle2(c);
        } else if (this._state === AFTER_STYLE_3) {
          this._stateAfterStyle3(c);
        } else if (this._state === AFTER_STYLE_4) {
          this._stateAfterStyle4(c);
        } else if (this._state === BEFORE_ENTITY) {
          this._stateBeforeEntity(c);
        } else if (this._state === BEFORE_NUMERIC_ENTITY) {
          this._stateBeforeNumericEntity(c);
        } else if (this._state === IN_NAMED_ENTITY) {
          this._stateInNamedEntity(c);
        } else if (this._state === IN_NUMERIC_ENTITY) {
          this._stateInNumericEntity(c);
        } else if (this._state === IN_HEX_ENTITY) {
          this._stateInHexEntity(c);
        } else {
          this._cbs.onerror(Error("unknown _state"), this._state);
        }
        this._index++;
      }
      this._cleanup();
    };
    Tokenizer.prototype.pause = function() {
      this._running = false;
    };
    Tokenizer.prototype.resume = function() {
      this._running = true;
      if (this._index < this._buffer.length) {
        this._parse();
      }
      if (this._ended) {
        this._finish();
      }
    };
    Tokenizer.prototype.end = function(chunk) {
      if (this._ended)
        this._cbs.onerror(Error(".end() after done!"));
      if (chunk)
        this.write(chunk);
      this._ended = true;
      if (this._running)
        this._finish();
    };
    Tokenizer.prototype._finish = function() {
      if (this._sectionStart < this._index) {
        this._handleTrailingData();
      }
      this._cbs.onend();
    };
    Tokenizer.prototype._handleTrailingData = function() {
      var data = this._buffer.substr(this._sectionStart);
      if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
        this._cbs.oncdata(data);
      } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
        this._cbs.oncomment(data);
      } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
        this._parseLegacyEntity();
        if (this._sectionStart < this._index) {
          this._state = this._baseState;
          this._handleTrailingData();
        }
      } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
        this._decodeNumericEntity(2, 10);
        if (this._sectionStart < this._index) {
          this._state = this._baseState;
          this._handleTrailingData();
        }
      } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
        this._decodeNumericEntity(3, 16);
        if (this._sectionStart < this._index) {
          this._state = this._baseState;
          this._handleTrailingData();
        }
      } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
        this._cbs.ontext(data);
      }
    };
    Tokenizer.prototype.reset = function() {
      Tokenizer.call(this, { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities }, this._cbs);
    };
    Tokenizer.prototype.getAbsoluteIndex = function() {
      return this._bufferOffset + this._index;
    };
    Tokenizer.prototype._getSection = function() {
      return this._buffer.substring(this._sectionStart, this._index);
    };
    Tokenizer.prototype._emitToken = function(name) {
      this._cbs[name](this._getSection());
      this._sectionStart = -1;
    };
    Tokenizer.prototype._emitPartial = function(value) {
      if (this._baseState !== TEXT) {
        this._cbs.onattribdata(value);
      } else {
        this._cbs.ontext(value);
      }
    };
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Parser.js"(exports, module2) {
    var Tokenizer = require_Tokenizer();
    var formTags = {
      input: true,
      option: true,
      optgroup: true,
      select: true,
      button: true,
      datalist: true,
      textarea: true
    };
    var openImpliesClose = {
      tr: { tr: true, th: true, td: true },
      th: { th: true },
      td: { thead: true, th: true, td: true },
      body: { head: true, link: true, script: true },
      li: { li: true },
      p: { p: true },
      h1: { p: true },
      h2: { p: true },
      h3: { p: true },
      h4: { p: true },
      h5: { p: true },
      h6: { p: true },
      select: formTags,
      input: formTags,
      output: formTags,
      button: formTags,
      datalist: formTags,
      textarea: formTags,
      option: { option: true },
      optgroup: { optgroup: true }
    };
    var voidElements = {
      __proto__: null,
      area: true,
      base: true,
      basefont: true,
      br: true,
      col: true,
      command: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      isindex: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    var foreignContextElements = {
      __proto__: null,
      math: true,
      svg: true
    };
    var htmlIntegrationElements = {
      __proto__: null,
      mi: true,
      mo: true,
      mn: true,
      ms: true,
      mtext: true,
      "annotation-xml": true,
      foreignObject: true,
      desc: true,
      title: true
    };
    var re_nameEnd = /\s|\//;
    function Parser(cbs, options) {
      this._options = options || {};
      this._cbs = cbs || {};
      this._tagname = "";
      this._attribname = "";
      this._attribvalue = "";
      this._attribs = null;
      this._stack = [];
      this._foreignContext = [];
      this.startIndex = 0;
      this.endIndex = null;
      this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
      this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
      if (this._options.Tokenizer) {
        Tokenizer = this._options.Tokenizer;
      }
      this._tokenizer = new Tokenizer(this._options, this);
      if (this._cbs.onparserinit)
        this._cbs.onparserinit(this);
    }
    require_inherits_browser()(Parser, require("events").EventEmitter);
    Parser.prototype._updatePosition = function(initialOffset) {
      if (this.endIndex === null) {
        if (this._tokenizer._sectionStart <= initialOffset) {
          this.startIndex = 0;
        } else {
          this.startIndex = this._tokenizer._sectionStart - initialOffset;
        }
      } else
        this.startIndex = this.endIndex + 1;
      this.endIndex = this._tokenizer.getAbsoluteIndex();
    };
    Parser.prototype.ontext = function(data) {
      this._updatePosition(1);
      this.endIndex--;
      if (this._cbs.ontext)
        this._cbs.ontext(data);
    };
    Parser.prototype.onopentagname = function(name) {
      if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      this._tagname = name;
      if (!this._options.xmlMode && name in openImpliesClose) {
        for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el))
          ;
      }
      if (this._options.xmlMode || !(name in voidElements)) {
        this._stack.push(name);
        if (name in foreignContextElements)
          this._foreignContext.push(true);
        else if (name in htmlIntegrationElements)
          this._foreignContext.push(false);
      }
      if (this._cbs.onopentagname)
        this._cbs.onopentagname(name);
      if (this._cbs.onopentag)
        this._attribs = {};
    };
    Parser.prototype.onopentagend = function() {
      this._updatePosition(1);
      if (this._attribs) {
        if (this._cbs.onopentag)
          this._cbs.onopentag(this._tagname, this._attribs);
        this._attribs = null;
      }
      if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
        this._cbs.onclosetag(this._tagname);
      }
      this._tagname = "";
    };
    Parser.prototype.onclosetag = function(name) {
      this._updatePosition(1);
      if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      if (name in foreignContextElements || name in htmlIntegrationElements) {
        this._foreignContext.pop();
      }
      if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
        var pos = this._stack.lastIndexOf(name);
        if (pos !== -1) {
          if (this._cbs.onclosetag) {
            pos = this._stack.length - pos;
            while (pos--)
              this._cbs.onclosetag(this._stack.pop());
          } else
            this._stack.length = pos;
        } else if (name === "p" && !this._options.xmlMode) {
          this.onopentagname(name);
          this._closeCurrentTag();
        }
      } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
        this.onopentagname(name);
        this._closeCurrentTag();
      }
    };
    Parser.prototype.onselfclosingtag = function() {
      if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
        this._closeCurrentTag();
      } else {
        this.onopentagend();
      }
    };
    Parser.prototype._closeCurrentTag = function() {
      var name = this._tagname;
      this.onopentagend();
      if (this._stack[this._stack.length - 1] === name) {
        if (this._cbs.onclosetag) {
          this._cbs.onclosetag(name);
        }
        this._stack.pop();
      }
    };
    Parser.prototype.onattribname = function(name) {
      if (this._lowerCaseAttributeNames) {
        name = name.toLowerCase();
      }
      this._attribname = name;
    };
    Parser.prototype.onattribdata = function(value) {
      this._attribvalue += value;
    };
    Parser.prototype.onattribend = function() {
      if (this._cbs.onattribute)
        this._cbs.onattribute(this._attribname, this._attribvalue);
      if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
        this._attribs[this._attribname] = this._attribvalue;
      }
      this._attribname = "";
      this._attribvalue = "";
    };
    Parser.prototype._getInstructionName = function(value) {
      var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
      if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      return name;
    };
    Parser.prototype.ondeclaration = function(value) {
      if (this._cbs.onprocessinginstruction) {
        var name = this._getInstructionName(value);
        this._cbs.onprocessinginstruction("!" + name, "!" + value);
      }
    };
    Parser.prototype.onprocessinginstruction = function(value) {
      if (this._cbs.onprocessinginstruction) {
        var name = this._getInstructionName(value);
        this._cbs.onprocessinginstruction("?" + name, "?" + value);
      }
    };
    Parser.prototype.oncomment = function(value) {
      this._updatePosition(4);
      if (this._cbs.oncomment)
        this._cbs.oncomment(value);
      if (this._cbs.oncommentend)
        this._cbs.oncommentend();
    };
    Parser.prototype.oncdata = function(value) {
      this._updatePosition(1);
      if (this._options.xmlMode || this._options.recognizeCDATA) {
        if (this._cbs.oncdatastart)
          this._cbs.oncdatastart();
        if (this._cbs.ontext)
          this._cbs.ontext(value);
        if (this._cbs.oncdataend)
          this._cbs.oncdataend();
      } else {
        this.oncomment("[CDATA[" + value + "]]");
      }
    };
    Parser.prototype.onerror = function(err) {
      if (this._cbs.onerror)
        this._cbs.onerror(err);
    };
    Parser.prototype.onend = function() {
      if (this._cbs.onclosetag) {
        for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]))
          ;
      }
      if (this._cbs.onend)
        this._cbs.onend();
    };
    Parser.prototype.reset = function() {
      if (this._cbs.onreset)
        this._cbs.onreset();
      this._tokenizer.reset();
      this._tagname = "";
      this._attribname = "";
      this._attribs = null;
      this._stack = [];
      if (this._cbs.onparserinit)
        this._cbs.onparserinit(this);
    };
    Parser.prototype.parseComplete = function(data) {
      this.reset();
      this.end(data);
    };
    Parser.prototype.write = function(chunk) {
      this._tokenizer.write(chunk);
    };
    Parser.prototype.end = function(chunk) {
      this._tokenizer.end(chunk);
    };
    Parser.prototype.pause = function() {
      this._tokenizer.pause();
    };
    Parser.prototype.resume = function() {
      this._tokenizer.resume();
    };
    Parser.prototype.parseChunk = Parser.prototype.write;
    Parser.prototype.done = Parser.prototype.end;
    module2.exports = Parser;
  }
});

// ../../node_modules/.pnpm/domelementtype@1.3.1/node_modules/domelementtype/index.js
var require_domelementtype = __commonJS({
  "../../node_modules/.pnpm/domelementtype@1.3.1/node_modules/domelementtype/index.js"(exports, module2) {
    module2.exports = {
      Text: "text",
      Directive: "directive",
      Comment: "comment",
      Script: "script",
      Style: "style",
      Tag: "tag",
      CDATA: "cdata",
      Doctype: "doctype",
      isTag: function(elem) {
        return elem.type === "tag" || elem.type === "script" || elem.type === "style";
      }
    };
  }
});

// ../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/lib/node.js"(exports, module2) {
    var NodePrototype = module2.exports = {
      get firstChild() {
        var children = this.children;
        return children && children[0] || null;
      },
      get lastChild() {
        var children = this.children;
        return children && children[children.length - 1] || null;
      },
      get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
      }
    };
    var domLvl1 = {
      tagName: "name",
      childNodes: "children",
      parentNode: "parent",
      previousSibling: "prev",
      nextSibling: "next",
      nodeValue: "data"
    };
    var nodeTypes = {
      element: 1,
      text: 3,
      cdata: 4,
      comment: 8
    };
    Object.keys(domLvl1).forEach(function(key) {
      var shorthand = domLvl1[key];
      Object.defineProperty(NodePrototype, key, {
        get: function() {
          return this[shorthand] || null;
        },
        set: function(val) {
          this[shorthand] = val;
          return val;
        }
      });
    });
  }
});

// ../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/lib/element.js
var require_element = __commonJS({
  "../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/lib/element.js"(exports, module2) {
    var NodePrototype = require_node();
    var ElementPrototype = module2.exports = Object.create(NodePrototype);
    var domLvl1 = {
      tagName: "name"
    };
    Object.keys(domLvl1).forEach(function(key) {
      var shorthand = domLvl1[key];
      Object.defineProperty(ElementPrototype, key, {
        get: function() {
          return this[shorthand] || null;
        },
        set: function(val) {
          this[shorthand] = val;
          return val;
        }
      });
    });
  }
});

// ../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/index.js
var require_domhandler = __commonJS({
  "../../node_modules/.pnpm/domhandler@2.4.2/node_modules/domhandler/index.js"(exports, module2) {
    var ElementType = require_domelementtype();
    var re_whitespace = /\s+/g;
    var NodePrototype = require_node();
    var ElementPrototype = require_element();
    function DomHandler(callback, options, elementCB) {
      if (typeof callback === "object") {
        elementCB = options;
        options = callback;
        callback = null;
      } else if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      this._callback = callback;
      this._options = options || defaultOpts;
      this._elementCB = elementCB;
      this.dom = [];
      this._done = false;
      this._tagStack = [];
      this._parser = this._parser || null;
    }
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false
    };
    DomHandler.prototype.onparserinit = function(parser) {
      this._parser = parser;
    };
    DomHandler.prototype.onreset = function() {
      DomHandler.call(this, this._callback, this._options, this._elementCB);
    };
    DomHandler.prototype.onend = function() {
      if (this._done)
        return;
      this._done = true;
      this._parser = null;
      this._handleCallback(null);
    };
    DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(error) {
      if (typeof this._callback === "function") {
        this._callback(error, this.dom);
      } else {
        if (error)
          throw error;
      }
    };
    DomHandler.prototype.onclosetag = function() {
      var elem = this._tagStack.pop();
      if (this._options.withEndIndices && elem) {
        elem.endIndex = this._parser.endIndex;
      }
      if (this._elementCB)
        this._elementCB(elem);
    };
    DomHandler.prototype._createDomElement = function(properties) {
      if (!this._options.withDomLvl1)
        return properties;
      var element;
      if (properties.type === "tag") {
        element = Object.create(ElementPrototype);
      } else {
        element = Object.create(NodePrototype);
      }
      for (var key in properties) {
        if (properties.hasOwnProperty(key)) {
          element[key] = properties[key];
        }
      }
      return element;
    };
    DomHandler.prototype._addDomElement = function(element) {
      var parent = this._tagStack[this._tagStack.length - 1];
      var siblings = parent ? parent.children : this.dom;
      var previousSibling = siblings[siblings.length - 1];
      element.next = null;
      if (this._options.withStartIndices) {
        element.startIndex = this._parser.startIndex;
      }
      if (this._options.withEndIndices) {
        element.endIndex = this._parser.endIndex;
      }
      if (previousSibling) {
        element.prev = previousSibling;
        previousSibling.next = element;
      } else {
        element.prev = null;
      }
      siblings.push(element);
      element.parent = parent || null;
    };
    DomHandler.prototype.onopentag = function(name, attribs) {
      var properties = {
        type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
        name,
        attribs,
        children: []
      };
      var element = this._createDomElement(properties);
      this._addDomElement(element);
      this._tagStack.push(element);
    };
    DomHandler.prototype.ontext = function(data) {
      var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
      var lastTag;
      if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
        if (normalize) {
          lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
        } else {
          lastTag.data += data;
        }
      } else {
        if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
          if (normalize) {
            lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
          } else {
            lastTag.data += data;
          }
        } else {
          if (normalize) {
            data = data.replace(re_whitespace, " ");
          }
          var element = this._createDomElement({
            data,
            type: ElementType.Text
          });
          this._addDomElement(element);
        }
      }
    };
    DomHandler.prototype.oncomment = function(data) {
      var lastTag = this._tagStack[this._tagStack.length - 1];
      if (lastTag && lastTag.type === ElementType.Comment) {
        lastTag.data += data;
        return;
      }
      var properties = {
        data,
        type: ElementType.Comment
      };
      var element = this._createDomElement(properties);
      this._addDomElement(element);
      this._tagStack.push(element);
    };
    DomHandler.prototype.oncdatastart = function() {
      var properties = {
        children: [{
          data: "",
          type: ElementType.Text
        }],
        type: ElementType.CDATA
      };
      var element = this._createDomElement(properties);
      this._addDomElement(element);
      this._tagStack.push(element);
    };
    DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
      this._tagStack.pop();
    };
    DomHandler.prototype.onprocessinginstruction = function(name, data) {
      var element = this._createDomElement({
        name,
        data,
        type: ElementType.Directive
      });
      this._addDomElement(element);
    };
    module2.exports = DomHandler;
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/encode.js
var require_encode2 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/encode.js"(exports) {
    var inverseXML = getInverseObj(require_xml2());
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.XML = getInverse(inverseXML, xmlReplacer);
    var inverseHTML = getInverseObj(require_entities());
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.HTML = getInverse(inverseHTML, htmlReplacer);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [], multiple = [];
      Object.keys(inverse).forEach(function(k) {
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      });
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var re_nonASCII = /[^\0-\x7F]/g;
    var re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function singleCharReplacer(c) {
      return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
    }
    function astralReplacer(c) {
      var high = c.charCodeAt(0);
      var low = c.charCodeAt(1);
      var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
      return "&#x" + codePoint.toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      function func(name) {
        return inverse[name];
      }
      return function(data) {
        return data.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
      };
    }
    var re_xmlChars = getInverseReplacer(inverseXML);
    function escapeXML(data) {
      return data.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
    }
    exports.escape = escapeXML;
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/decode.js
var require_decode3 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/lib/decode.js"(exports, module2) {
    var entityMap = require_entities();
    var legacyMap = require_legacy();
    var xmlMap = require_xml2();
    var decodeCodePoint = require_decode_codepoint2();
    var decodeXMLStrict = getStrictDecoder(xmlMap);
    var decodeHTMLStrict = getStrictDecoder(entityMap);
    function getStrictDecoder(map) {
      var keys = Object.keys(map).join("|"), replace = getReplacer(map);
      keys += "|#[xX][\\da-fA-F]+|#\\d+";
      var re = new RegExp("&(?:" + keys + ");", "g");
      return function(str) {
        return String(str).replace(re, replace);
      };
    }
    var decodeHTML = function() {
      var legacy = Object.keys(legacyMap).sort(sorter);
      var keys = Object.keys(entityMap).sort(sorter);
      for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
          keys[i] += ";?";
          j++;
        } else {
          keys[i] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entityMap);
      function replacer(str) {
        if (str.substr(-1) !== ";")
          str += ";";
        return replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    }();
    function sorter(a, b) {
      return a < b ? 1 : -1;
    }
    function getReplacer(map) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          if (str.charAt(2) === "X" || str.charAt(2) === "x") {
            return decodeCodePoint(parseInt(str.substr(3), 16));
          }
          return decodeCodePoint(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
      };
    }
    module2.exports = {
      XML: decodeXMLStrict,
      HTML: decodeHTML,
      HTMLStrict: decodeHTMLStrict
    };
  }
});

// ../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/index.js
var require_entities2 = __commonJS({
  "../../node_modules/.pnpm/entities@1.1.2/node_modules/entities/index.js"(exports) {
    var encode = require_encode2();
    var decode = require_decode3();
    exports.decode = function(data, level) {
      return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
    };
    exports.decodeStrict = function(data, level) {
      return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
    };
    exports.encode = function(data, level) {
      return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
    };
    exports.encodeXML = encode.XML;
    exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML;
    exports.decodeXML = exports.decodeXMLStrict = decode.XML;
    exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML;
    exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict;
    exports.escape = encode.escape;
  }
});

// ../../node_modules/.pnpm/dom-serializer@0.1.1/node_modules/dom-serializer/index.js
var require_dom_serializer = __commonJS({
  "../../node_modules/.pnpm/dom-serializer@0.1.1/node_modules/dom-serializer/index.js"(exports, module2) {
    var ElementType = require_domelementtype();
    var entities = require_entities2();
    var unencodedElements = {
      __proto__: null,
      style: true,
      script: true,
      xmp: true,
      iframe: true,
      noembed: true,
      noframes: true,
      plaintext: true,
      noscript: true
    };
    function formatAttrs(attributes, opts) {
      if (!attributes)
        return;
      var output = "", value;
      for (var key in attributes) {
        value = attributes[key];
        if (output) {
          output += " ";
        }
        output += key;
        if (value !== null && value !== "" || opts.xmlMode) {
          output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
        }
      }
      return output;
    }
    var singleTag = {
      __proto__: null,
      area: true,
      base: true,
      basefont: true,
      br: true,
      col: true,
      command: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      isindex: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    var render = module2.exports = function(dom, opts) {
      if (!Array.isArray(dom) && !dom.cheerio)
        dom = [dom];
      opts = opts || {};
      var output = "";
      for (var i = 0; i < dom.length; i++) {
        var elem = dom[i];
        if (elem.type === "root")
          output += render(elem.children, opts);
        else if (ElementType.isTag(elem))
          output += renderTag(elem, opts);
        else if (elem.type === ElementType.Directive)
          output += renderDirective(elem);
        else if (elem.type === ElementType.Comment)
          output += renderComment(elem);
        else if (elem.type === ElementType.CDATA)
          output += renderCdata(elem);
        else
          output += renderText(elem, opts);
      }
      return output;
    };
    function renderTag(elem, opts) {
      if (elem.name === "svg")
        opts = { decodeEntities: opts.decodeEntities, xmlMode: true };
      var tag = "<" + elem.name, attribs = formatAttrs(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children) {
          tag += render(elem.children, opts);
        }
        if (!singleTag[elem.name] || opts.xmlMode) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
        data = entities.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/stringify.js"(exports, module2) {
    var ElementType = require_domelementtype();
    var getOuterHTML = require_dom_serializer();
    var isTag = ElementType.isTag;
    module2.exports = {
      getInnerHTML,
      getOuterHTML,
      getText
    };
    function getInnerHTML(elem, opts) {
      return elem.children ? elem.children.map(function(elem2) {
        return getOuterHTML(elem2, opts);
      }).join("") : "";
    }
    function getText(elem) {
      if (Array.isArray(elem))
        return elem.map(getText).join("");
      if (isTag(elem))
        return elem.name === "br" ? "\n" : getText(elem.children);
      if (elem.type === ElementType.CDATA)
        return getText(elem.children);
      if (elem.type === ElementType.Text)
        return elem.data;
      return "";
    }
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/traversal.js"(exports) {
    var getChildren = exports.getChildren = function(elem) {
      return elem.children;
    };
    var getParent = exports.getParent = function(elem) {
      return elem.parent;
    };
    exports.getSiblings = function(elem) {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [elem];
    };
    exports.getAttributeValue = function(elem, name) {
      return elem.attribs && elem.attribs[name];
    };
    exports.hasAttrib = function(elem, name) {
      return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
    };
    exports.getName = function(elem) {
      return elem.name;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/manipulation.js"(exports) {
    exports.removeElement = function(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    };
    exports.replaceElement = function(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    };
    exports.appendChild = function(elem, child) {
      child.parent = elem;
      if (elem.children.push(child) !== 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
        child.next = null;
      }
    };
    exports.append = function(elem, next) {
      var parent = elem.parent, currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    };
    exports.prepend = function(elem, prev) {
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/querying.js"(exports, module2) {
    var isTag = require_domelementtype().isTag;
    module2.exports = {
      filter,
      find,
      findOneChild,
      findOne,
      existsOne,
      findAll
    };
    function filter(test, element, recurse, limit) {
      if (!Array.isArray(element))
        element = [element];
      if (typeof limit !== "number" || !isFinite(limit)) {
        limit = Infinity;
      }
      return find(test, element, recurse !== false, limit);
    }
    function find(test, elems, recurse, limit) {
      var result = [], childs;
      for (var i = 0, j = elems.length; i < j; i++) {
        if (test(elems[i])) {
          result.push(elems[i]);
          if (--limit <= 0)
            break;
        }
        childs = elems[i].children;
        if (recurse && childs && childs.length > 0) {
          childs = find(test, childs, recurse, limit);
          result = result.concat(childs);
          limit -= childs.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    function findOneChild(test, elems) {
      for (var i = 0, l = elems.length; i < l; i++) {
        if (test(elems[i]))
          return elems[i];
      }
      return null;
    }
    function findOne(test, elems) {
      var elem = null;
      for (var i = 0, l = elems.length; i < l && !elem; i++) {
        if (!isTag(elems[i])) {
          continue;
        } else if (test(elems[i])) {
          elem = elems[i];
        } else if (elems[i].children.length > 0) {
          elem = findOne(test, elems[i].children);
        }
      }
      return elem;
    }
    function existsOne(test, elems) {
      for (var i = 0, l = elems.length; i < l; i++) {
        if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
          return true;
        }
      }
      return false;
    }
    function findAll(test, rootElems) {
      var result = [];
      var stack = rootElems.slice();
      while (stack.length) {
        var elem = stack.shift();
        if (!isTag(elem))
          continue;
        if (elem.children && elem.children.length > 0) {
          stack.unshift.apply(stack, elem.children);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/legacy.js"(exports) {
    var ElementType = require_domelementtype();
    var isTag = exports.isTag = ElementType.isTag;
    exports.testElement = function(options, element) {
      for (var key in options) {
        if (!options.hasOwnProperty(key))
          ;
        else if (key === "tag_name") {
          if (!isTag(element) || !options.tag_name(element.name)) {
            return false;
          }
        } else if (key === "tag_type") {
          if (!options.tag_type(element.type))
            return false;
        } else if (key === "tag_contains") {
          if (isTag(element) || !options.tag_contains(element.data)) {
            return false;
          }
        } else if (!element.attribs || !options[key](element.attribs[key])) {
          return false;
        }
      }
      return true;
    };
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return isTag(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return isTag;
        } else {
          return function(elem) {
            return isTag(elem) && elem.name === name;
          };
        }
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        } else {
          return function(elem) {
            return elem.type === type;
          };
        }
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return !isTag(elem) && data(elem.data);
          };
        } else {
          return function(elem) {
            return !isTag(elem) && elem.data === data;
          };
        }
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return elem.attribs && value(elem.attribs[attrib]);
        };
      } else {
        return function(elem) {
          return elem.attribs && elem.attribs[attrib] === value;
        };
      }
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    exports.getElements = function(options, element, recurse, limit) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
    };
    exports.getElementById = function(id, element, recurse) {
      if (!Array.isArray(element))
        element = [element];
      return this.findOne(getAttribCheck("id", id), element, recurse !== false);
    };
    exports.getElementsByTagName = function(name, element, recurse, limit) {
      return this.filter(Checks.tag_name(name), element, recurse, limit);
    };
    exports.getElementsByTagType = function(type, element, recurse, limit) {
      return this.filter(Checks.tag_type(type), element, recurse, limit);
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/lib/helpers.js"(exports) {
    exports.removeSubsets = function(nodes) {
      var idx = nodes.length, node, ancestor, replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = ancestor.parent;
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    };
    var POSITION = {
      DISCONNECTED: 1,
      PRECEDING: 2,
      FOLLOWING: 4,
      CONTAINS: 8,
      CONTAINED_BY: 16
    };
    var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      var current, sharedParent, siblings, aSibling, bSibling, idx;
      if (nodeA === nodeB) {
        return 0;
      }
      current = nodeA;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = nodeB;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      idx = 0;
      while (aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return POSITION.DISCONNECTED;
      }
      sharedParent = aParents[idx - 1];
      siblings = sharedParent.children;
      aSibling = aParents[idx];
      bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
        }
        return POSITION.FOLLOWING;
      } else {
        if (sharedParent === nodeA) {
          return POSITION.PRECEDING | POSITION.CONTAINS;
        }
        return POSITION.PRECEDING;
      }
    };
    exports.uniqueSort = function(nodes) {
      var idx = nodes.length, node, position;
      nodes = nodes.slice();
      while (--idx > -1) {
        node = nodes[idx];
        position = nodes.indexOf(node);
        if (position > -1 && position < idx) {
          nodes.splice(idx, 1);
        }
      }
      nodes.sort(function(a, b) {
        var relative = comparePos(a, b);
        if (relative & POSITION.PRECEDING) {
          return -1;
        } else if (relative & POSITION.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/index.js
var require_domutils = __commonJS({
  "../../node_modules/.pnpm/domutils@1.7.0/node_modules/domutils/index.js"(exports, module2) {
    var DomUtils = module2.exports;
    [
      require_stringify(),
      require_traversal(),
      require_manipulation(),
      require_querying(),
      require_legacy2(),
      require_helpers()
    ].forEach(function(ext) {
      Object.keys(ext).forEach(function(key) {
        DomUtils[key] = ext[key].bind(DomUtils);
      });
    });
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/FeedHandler.js"(exports, module2) {
    var DomHandler = require_domhandler();
    var DomUtils = require_domutils();
    function FeedHandler(callback, options) {
      this.init(callback, options);
    }
    require_inherits_browser()(FeedHandler, DomHandler);
    FeedHandler.prototype.init = DomHandler;
    function getElements(what, where) {
      return DomUtils.getElementsByTagName(what, where, true);
    }
    function getOneElement(what, where) {
      return DomUtils.getElementsByTagName(what, where, true, 1)[0];
    }
    function fetch(what, where, recurse) {
      return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, what, where, recurse) {
      var tmp = fetch(what, where, recurse);
      if (tmp)
        obj[prop] = tmp;
    }
    var isValidFeed = function(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    };
    FeedHandler.prototype.onend = function() {
      var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
      if (feedRoot) {
        if (feedRoot.name === "feed") {
          childs = feedRoot.children;
          feed.type = "atom";
          addConditionally(feed, "id", "id", childs);
          addConditionally(feed, "title", "title", childs);
          if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
            feed.link = tmp;
          addConditionally(feed, "description", "subtitle", childs);
          if (tmp = fetch("updated", childs))
            feed.updated = new Date(tmp);
          addConditionally(feed, "author", "email", childs, true);
          feed.items = getElements("entry", childs).map(function(item) {
            var entry = {}, tmp2;
            item = item.children;
            addConditionally(entry, "id", "id", item);
            addConditionally(entry, "title", "title", item);
            if ((tmp2 = getOneElement("link", item)) && (tmp2 = tmp2.attribs) && (tmp2 = tmp2.href))
              entry.link = tmp2;
            if (tmp2 = fetch("summary", item) || fetch("content", item))
              entry.description = tmp2;
            if (tmp2 = fetch("updated", item))
              entry.pubDate = new Date(tmp2);
            return entry;
          });
        } else {
          childs = getOneElement("channel", feedRoot.children).children;
          feed.type = feedRoot.name.substr(0, 3);
          feed.id = "";
          addConditionally(feed, "title", "title", childs);
          addConditionally(feed, "link", "link", childs);
          addConditionally(feed, "description", "description", childs);
          if (tmp = fetch("lastBuildDate", childs))
            feed.updated = new Date(tmp);
          addConditionally(feed, "author", "managingEditor", childs, true);
          feed.items = getElements("item", feedRoot.children).map(function(item) {
            var entry = {}, tmp2;
            item = item.children;
            addConditionally(entry, "id", "guid", item);
            addConditionally(entry, "title", "title", item);
            addConditionally(entry, "link", "link", item);
            addConditionally(entry, "description", "description", item);
            if (tmp2 = fetch("pubDate", item))
              entry.pubDate = new Date(tmp2);
            return entry;
          });
        }
      }
      this.dom = feed;
      DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
    };
    module2.exports = FeedHandler;
  }
});

// (disabled):../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "(disabled):../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js"() {
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/WritableStream.js
var require_WritableStream = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/WritableStream.js"(exports, module2) {
    module2.exports = Stream;
    var Parser = require_Parser();
    var WritableStream = require_readable_browser().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var Buffer2 = require("buffer").Buffer;
    function Stream(cbs, options) {
      var parser = this._parser = new Parser(cbs, options);
      var decoder = this._decoder = new StringDecoder();
      WritableStream.call(this, { decodeStrings: false });
      this.once("finish", function() {
        parser.end(decoder.end());
      });
    }
    require_inherits_browser()(Stream, WritableStream);
    Stream.prototype._write = function(chunk, encoding, cb) {
      if (chunk instanceof Buffer2)
        chunk = this._decoder.write(chunk);
      this._parser.write(chunk);
      cb();
    };
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Stream.js
var require_Stream = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/Stream.js"(exports, module2) {
    module2.exports = Stream;
    var Parser = require_WritableStream();
    function Stream(options) {
      Parser.call(this, new Cbs(this), options);
    }
    require_inherits_browser()(Stream, Parser);
    Stream.prototype.readable = true;
    function Cbs(scope) {
      this.scope = scope;
    }
    var EVENTS = require_lib2().EVENTS;
    Object.keys(EVENTS).forEach(function(name) {
      if (EVENTS[name] === 0) {
        Cbs.prototype["on" + name] = function() {
          this.scope.emit(name);
        };
      } else if (EVENTS[name] === 1) {
        Cbs.prototype["on" + name] = function(a) {
          this.scope.emit(name, a);
        };
      } else if (EVENTS[name] === 2) {
        Cbs.prototype["on" + name] = function(a, b) {
          this.scope.emit(name, a, b);
        };
      } else {
        throw Error("wrong number of arguments!");
      }
    });
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/ProxyHandler.js
var require_ProxyHandler = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/ProxyHandler.js"(exports, module2) {
    module2.exports = ProxyHandler;
    function ProxyHandler(cbs) {
      this._cbs = cbs || {};
    }
    var EVENTS = require_lib2().EVENTS;
    Object.keys(EVENTS).forEach(function(name) {
      if (EVENTS[name] === 0) {
        name = "on" + name;
        ProxyHandler.prototype[name] = function() {
          if (this._cbs[name])
            this._cbs[name]();
        };
      } else if (EVENTS[name] === 1) {
        name = "on" + name;
        ProxyHandler.prototype[name] = function(a) {
          if (this._cbs[name])
            this._cbs[name](a);
        };
      } else if (EVENTS[name] === 2) {
        name = "on" + name;
        ProxyHandler.prototype[name] = function(a, b) {
          if (this._cbs[name])
            this._cbs[name](a, b);
        };
      } else {
        throw Error("wrong number of arguments");
      }
    });
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/CollectingHandler.js
var require_CollectingHandler = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/CollectingHandler.js"(exports, module2) {
    module2.exports = CollectingHandler;
    function CollectingHandler(cbs) {
      this._cbs = cbs || {};
      this.events = [];
    }
    var EVENTS = require_lib2().EVENTS;
    Object.keys(EVENTS).forEach(function(name) {
      if (EVENTS[name] === 0) {
        name = "on" + name;
        CollectingHandler.prototype[name] = function() {
          this.events.push([name]);
          if (this._cbs[name])
            this._cbs[name]();
        };
      } else if (EVENTS[name] === 1) {
        name = "on" + name;
        CollectingHandler.prototype[name] = function(a) {
          this.events.push([name, a]);
          if (this._cbs[name])
            this._cbs[name](a);
        };
      } else if (EVENTS[name] === 2) {
        name = "on" + name;
        CollectingHandler.prototype[name] = function(a, b) {
          this.events.push([name, a, b]);
          if (this._cbs[name])
            this._cbs[name](a, b);
        };
      } else {
        throw Error("wrong number of arguments");
      }
    });
    CollectingHandler.prototype.onreset = function() {
      this.events = [];
      if (this._cbs.onreset)
        this._cbs.onreset();
    };
    CollectingHandler.prototype.restart = function() {
      if (this._cbs.onreset)
        this._cbs.onreset();
      for (var i = 0, len = this.events.length; i < len; i++) {
        if (this._cbs[this.events[i][0]]) {
          var num = this.events[i].length;
          if (num === 1) {
            this._cbs[this.events[i][0]]();
          } else if (num === 2) {
            this._cbs[this.events[i][0]](this.events[i][1]);
          } else {
            this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@3.10.1/node_modules/htmlparser2/lib/index.js"(exports, module2) {
    var Parser = require_Parser();
    var DomHandler = require_domhandler();
    function defineProp(name, value) {
      delete module2.exports[name];
      module2.exports[name] = value;
      return value;
    }
    module2.exports = {
      Parser,
      Tokenizer: require_Tokenizer(),
      ElementType: require_domelementtype(),
      DomHandler,
      get FeedHandler() {
        return defineProp("FeedHandler", require_FeedHandler());
      },
      get Stream() {
        return defineProp("Stream", require_Stream());
      },
      get WritableStream() {
        return defineProp("WritableStream", require_WritableStream());
      },
      get ProxyHandler() {
        return defineProp("ProxyHandler", require_ProxyHandler());
      },
      get DomUtils() {
        return defineProp("DomUtils", require_domutils());
      },
      get CollectingHandler() {
        return defineProp("CollectingHandler", require_CollectingHandler());
      },
      DefaultHandler: DomHandler,
      get RssHandler() {
        return defineProp("RssHandler", this.FeedHandler);
      },
      parseDOM: function(data, options) {
        var handler = new DomHandler(options);
        new Parser(handler, options).end(data);
        return handler.dom;
      },
      parseFeed: function(feed, options) {
        var handler = new module2.exports.FeedHandler(options);
        new Parser(handler, options).end(feed);
        return handler.dom;
      },
      createDomStream: function(cb, options, elementCb) {
        var handler = new DomHandler(cb, options, elementCb);
        return new Parser(handler, options);
      },
      EVENTS: {
        attribute: 2,
        cdatastart: 0,
        cdataend: 0,
        text: 1,
        processinginstruction: 2,
        comment: 1,
        commentend: 0,
        closetag: 1,
        opentag: 2,
        opentagname: 1,
        error: 1,
        end: 0
      }
    };
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/parse.js"(exports, module2) {
    var htmlparser = require_lib2();
    exports = module2.exports = function(content, options) {
      var dom = exports.evaluate(content, options), root = exports.evaluate("<root></root>", options)[0];
      root.type = "root";
      exports.update(dom, root);
      return root;
    };
    exports.evaluate = function(content, options) {
      var dom;
      if (typeof content === "string" || Buffer.isBuffer(content)) {
        dom = htmlparser.parseDOM(content, options);
      } else {
        dom = content;
      }
      return dom;
    };
    exports.update = function(arr, parent) {
      if (!Array.isArray(arr))
        arr = [arr];
      if (parent) {
        parent.children = arr;
      } else {
        parent = null;
      }
      for (var i = 0; i < arr.length; i++) {
        var node = arr[i];
        var oldParent = node.parent || node.root, oldSiblings = oldParent && oldParent.children;
        if (oldSiblings && oldSiblings !== arr) {
          oldSiblings.splice(oldSiblings.indexOf(node), 1);
          if (node.prev) {
            node.prev.next = node.next;
          }
          if (node.next) {
            node.next.prev = node.prev;
          }
        }
        if (parent) {
          node.prev = arr[i - 1] || null;
          node.next = arr[i + 1] || null;
        } else {
          node.prev = node.next = null;
        }
        if (parent && parent.type === "root") {
          node.root = parent;
          node.parent = null;
        } else {
          node.root = null;
          node.parent = parent;
        }
      }
      return parent;
    };
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/utils.js"(exports) {
    var parse = require_parse();
    var render = require_dom_serializer();
    var tags = { tag: true, script: true, style: true };
    exports.isTag = function(type) {
      if (type.type)
        type = type.type;
      return tags[type] || false;
    };
    exports.camelCase = function(str) {
      return str.replace(/[_.-](\w|$)/g, function(_, x) {
        return x.toUpperCase();
      });
    };
    exports.cssCase = function(str) {
      return str.replace(/[A-Z]/g, "-$&").toLowerCase();
    };
    exports.domEach = function(cheerio, fn) {
      var i = 0, len = cheerio.length;
      while (i < len && fn.call(cheerio, i, cheerio[i]) !== false)
        ++i;
      return cheerio;
    };
    exports.cloneDom = function(dom, options) {
      return parse(render(dom, options), options).children;
    };
    var quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
    exports.isHtml = function(str) {
      if (str.charAt(0) === "<" && str.charAt(str.length - 1) === ">" && str.length >= 3)
        return true;
      var match = quickExpr.exec(str);
      return !!(match && match[1]);
    };
  }
});

// ../../node_modules/.pnpm/lodash.assignin@4.2.0/node_modules/lodash.assignin/index.js
var require_lodash = __commonJS({
  "../../node_modules/.pnpm/lodash.assignin@4.2.0/node_modules/lodash.assignin/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = assignIn;
  }
});

// ../../node_modules/.pnpm/lodash.bind@4.2.1/node_modules/lodash.bind/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/.pnpm/lodash.bind@4.2.1/node_modules/lodash.bind/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var PLACEHOLDER = "__lodash_placeholder__";
    var BIND_FLAG = 1;
    var BIND_KEY_FLAG = 2;
    var CURRY_BOUND_FLAG = 4;
    var CURRY_FLAG = 8;
    var CURRY_RIGHT_FLAG = 16;
    var PARTIAL_FLAG = 32;
    var PARTIAL_RIGHT_FLAG = 64;
    var ARY_FLAG = 128;
    var REARG_FLAG = 256;
    var FLIP_FLAG = 512;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var wrapFlags = [
      ["ary", ARY_FLAG],
      ["bind", BIND_FLAG],
      ["bindKey", BIND_KEY_FLAG],
      ["curry", CURRY_FLAG],
      ["curryRight", CURRY_RIGHT_FLAG],
      ["flip", FLIP_FLAG],
      ["partial", PARTIAL_FLAG],
      ["partialRight", PARTIAL_RIGHT_FLAG],
      ["rearg", REARG_FLAG]
    ];
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reTrim = /^\s+|\s+$/g;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
    var reSplitDetails = /,? & /;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          result++;
        }
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var objectCreate = Object.create;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var defineProperty = function() {
      var func = getNative(Object, "defineProperty"), name = getNative.name;
      return name && name.length > 2 ? func : void 0;
    }();
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    function createCtor(Ctor) {
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args[0]);
          case 2:
            return new Ctor(args[0], args[1]);
          case 3:
            return new Ctor(args[0], args[1], args[2]);
          case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
          case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      };
    }
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
        while (index--) {
          args[index] = arguments[index];
        }
        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length -= holders.length;
        if (length < arity) {
          return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length);
        }
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
      bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
      if (!(bitmask & CURRY_BOUND_FLAG)) {
        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
      }
      var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = void 0;
      }
      ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === void 0 ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = void 0;
      }
      var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
      ];
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(void 0, newData);
      }
      return setWrapToString(result, func, bitmask);
    }
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }
    function insertWrapDetails(source, details) {
      var length = details.length, lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
      details = details.join(length > 2 ? ", " : " ");
      return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function reorder(array, indexes) {
      var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
      }
      return array;
    }
    var setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {
      var source = reference + "";
      return defineProperty(wrapper, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
      });
    };
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = "_." + pair[0];
        if (bitmask & pair[1] && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    bind.placeholder = {};
    module2.exports = bind;
  }
});

// ../../node_modules/.pnpm/lodash.foreach@4.5.0/node_modules/lodash.foreach/index.js
var require_lodash3 = __commonJS({
  "../../node_modules/.pnpm/lodash.foreach@4.5.0/node_modules/lodash.foreach/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, typeof iteratee == "function" ? iteratee : identity);
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    module2.exports = forEach;
  }
});

// ../../node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js
var require_lodash4 = __commonJS({
  "../../node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/stringify.js"(exports, module2) {
    var ElementType = require_domelementtype();
    var getOuterHTML = require_dom_serializer();
    var isTag = ElementType.isTag;
    module2.exports = {
      getInnerHTML,
      getOuterHTML,
      getText
    };
    function getInnerHTML(elem, opts) {
      return elem.children ? elem.children.map(function(elem2) {
        return getOuterHTML(elem2, opts);
      }).join("") : "";
    }
    function getText(elem) {
      if (Array.isArray(elem))
        return elem.map(getText).join("");
      if (isTag(elem) || elem.type === ElementType.CDATA)
        return getText(elem.children);
      if (elem.type === ElementType.Text)
        return elem.data;
      return "";
    }
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/traversal.js
var require_traversal2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/traversal.js"(exports) {
    var getChildren = exports.getChildren = function(elem) {
      return elem.children;
    };
    var getParent = exports.getParent = function(elem) {
      return elem.parent;
    };
    exports.getSiblings = function(elem) {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [elem];
    };
    exports.getAttributeValue = function(elem, name) {
      return elem.attribs && elem.attribs[name];
    };
    exports.hasAttrib = function(elem, name) {
      return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
    };
    exports.getName = function(elem) {
      return elem.name;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/manipulation.js
var require_manipulation2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/manipulation.js"(exports) {
    exports.removeElement = function(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    };
    exports.replaceElement = function(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    };
    exports.appendChild = function(elem, child) {
      child.parent = elem;
      if (elem.children.push(child) !== 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
        child.next = null;
      }
    };
    exports.append = function(elem, next) {
      var parent = elem.parent, currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    };
    exports.prepend = function(elem, prev) {
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/querying.js
var require_querying2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/querying.js"(exports, module2) {
    var isTag = require_domelementtype().isTag;
    module2.exports = {
      filter,
      find,
      findOneChild,
      findOne,
      existsOne,
      findAll
    };
    function filter(test, element, recurse, limit) {
      if (!Array.isArray(element))
        element = [element];
      if (typeof limit !== "number" || !isFinite(limit)) {
        limit = Infinity;
      }
      return find(test, element, recurse !== false, limit);
    }
    function find(test, elems, recurse, limit) {
      var result = [], childs;
      for (var i = 0, j = elems.length; i < j; i++) {
        if (test(elems[i])) {
          result.push(elems[i]);
          if (--limit <= 0)
            break;
        }
        childs = elems[i].children;
        if (recurse && childs && childs.length > 0) {
          childs = find(test, childs, recurse, limit);
          result = result.concat(childs);
          limit -= childs.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    function findOneChild(test, elems) {
      for (var i = 0, l = elems.length; i < l; i++) {
        if (test(elems[i]))
          return elems[i];
      }
      return null;
    }
    function findOne(test, elems) {
      var elem = null;
      for (var i = 0, l = elems.length; i < l && !elem; i++) {
        if (!isTag(elems[i])) {
          continue;
        } else if (test(elems[i])) {
          elem = elems[i];
        } else if (elems[i].children.length > 0) {
          elem = findOne(test, elems[i].children);
        }
      }
      return elem;
    }
    function existsOne(test, elems) {
      for (var i = 0, l = elems.length; i < l; i++) {
        if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
          return true;
        }
      }
      return false;
    }
    function findAll(test, elems) {
      var result = [];
      for (var i = 0, j = elems.length; i < j; i++) {
        if (!isTag(elems[i]))
          continue;
        if (test(elems[i]))
          result.push(elems[i]);
        if (elems[i].children.length > 0) {
          result = result.concat(findAll(test, elems[i].children));
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/legacy.js
var require_legacy3 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/legacy.js"(exports) {
    var ElementType = require_domelementtype();
    var isTag = exports.isTag = ElementType.isTag;
    exports.testElement = function(options, element) {
      for (var key in options) {
        if (!options.hasOwnProperty(key))
          ;
        else if (key === "tag_name") {
          if (!isTag(element) || !options.tag_name(element.name)) {
            return false;
          }
        } else if (key === "tag_type") {
          if (!options.tag_type(element.type))
            return false;
        } else if (key === "tag_contains") {
          if (isTag(element) || !options.tag_contains(element.data)) {
            return false;
          }
        } else if (!element.attribs || !options[key](element.attribs[key])) {
          return false;
        }
      }
      return true;
    };
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return isTag(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return isTag;
        } else {
          return function(elem) {
            return isTag(elem) && elem.name === name;
          };
        }
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        } else {
          return function(elem) {
            return elem.type === type;
          };
        }
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return !isTag(elem) && data(elem.data);
          };
        } else {
          return function(elem) {
            return !isTag(elem) && elem.data === data;
          };
        }
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return elem.attribs && value(elem.attribs[attrib]);
        };
      } else {
        return function(elem) {
          return elem.attribs && elem.attribs[attrib] === value;
        };
      }
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    exports.getElements = function(options, element, recurse, limit) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
    };
    exports.getElementById = function(id, element, recurse) {
      if (!Array.isArray(element))
        element = [element];
      return this.findOne(getAttribCheck("id", id), element, recurse !== false);
    };
    exports.getElementsByTagName = function(name, element, recurse, limit) {
      return this.filter(Checks.tag_name(name), element, recurse, limit);
    };
    exports.getElementsByTagType = function(type, element, recurse, limit) {
      return this.filter(Checks.tag_type(type), element, recurse, limit);
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/helpers.js
var require_helpers2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/lib/helpers.js"(exports) {
    exports.removeSubsets = function(nodes) {
      var idx = nodes.length, node, ancestor, replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = ancestor.parent;
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    };
    var POSITION = {
      DISCONNECTED: 1,
      PRECEDING: 2,
      FOLLOWING: 4,
      CONTAINS: 8,
      CONTAINED_BY: 16
    };
    var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      var current, sharedParent, siblings, aSibling, bSibling, idx;
      if (nodeA === nodeB) {
        return 0;
      }
      current = nodeA;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = nodeB;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      idx = 0;
      while (aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return POSITION.DISCONNECTED;
      }
      sharedParent = aParents[idx - 1];
      siblings = sharedParent.children;
      aSibling = aParents[idx];
      bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
        }
        return POSITION.FOLLOWING;
      } else {
        if (sharedParent === nodeA) {
          return POSITION.PRECEDING | POSITION.CONTAINS;
        }
        return POSITION.PRECEDING;
      }
    };
    exports.uniqueSort = function(nodes) {
      var idx = nodes.length, node, position;
      nodes = nodes.slice();
      while (--idx > -1) {
        node = nodes[idx];
        position = nodes.indexOf(node);
        if (position > -1 && position < idx) {
          nodes.splice(idx, 1);
        }
      }
      nodes.sort(function(a, b) {
        var relative = comparePos(a, b);
        if (relative & POSITION.PRECEDING) {
          return -1;
        } else if (relative & POSITION.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    };
  }
});

// ../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/index.js
var require_domutils2 = __commonJS({
  "../../node_modules/.pnpm/domutils@1.5.1/node_modules/domutils/index.js"(exports, module2) {
    var DomUtils = module2.exports;
    [
      require_stringify2(),
      require_traversal2(),
      require_manipulation2(),
      require_querying2(),
      require_legacy3(),
      require_helpers2()
    ].forEach(function(ext) {
      Object.keys(ext).forEach(function(key) {
        DomUtils[key] = ext[key].bind(DomUtils);
      });
    });
  }
});

// ../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/parse.js"(exports, module2) {
    module2.exports = parse;
    var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
    function parse(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      } else {
        var parsed = formula.match(re_nthElement);
        if (!parsed) {
          throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
        }
        var a;
        if (parsed[1]) {
          a = parseInt(parsed[1], 10);
          if (isNaN(a)) {
            if (parsed[1].charAt(0) === "-")
              a = -1;
            else
              a = 1;
          }
        } else
          a = 0;
        return [
          a,
          parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
        ];
      }
    }
  }
});

// ../../node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "../../node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js"(exports, module2) {
    module2.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// ../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/compile.js
var require_compile = __commonJS({
  "../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/compile.js"(exports, module2) {
    module2.exports = compile;
    var BaseFuncs = require_boolbase();
    var trueFunc = BaseFuncs.trueFunc;
    var falseFunc = BaseFuncs.falseFunc;
    function compile(parsed) {
      var a = parsed[0], b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return falseFunc;
      if (a === -1)
        return function(pos) {
          return pos <= b;
        };
      if (a === 0)
        return function(pos) {
          return pos === b;
        };
      if (a === 1)
        return b < 0 ? trueFunc : function(pos) {
          return pos >= b;
        };
      var bMod = b % a;
      if (bMod < 0)
        bMod += a;
      if (a > 1) {
        return function(pos) {
          return pos >= b && pos % a === bMod;
        };
      }
      a *= -1;
      return function(pos) {
        return pos <= b && pos % a === bMod;
      };
    }
  }
});

// ../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/index.js
var require_nth_check = __commonJS({
  "../../node_modules/.pnpm/nth-check@1.0.2/node_modules/nth-check/index.js"(exports, module2) {
    var parse = require_parse2();
    var compile = require_compile();
    module2.exports = function nthCheck(formula) {
      return compile(parse(formula));
    };
    module2.exports.parse = parse;
    module2.exports.compile = compile;
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/attributes.js"(exports, module2) {
    var DomUtils = require_domutils2();
    var hasAttrib = DomUtils.hasAttrib;
    var getAttributeValue = DomUtils.getAttributeValue;
    var falseFunc = require_boolbase().falseFunc;
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    var attributeRules = {
      __proto__: null,
      equals: function(next, data) {
        var name = data.name, value = data.value;
        if (data.ignoreCase) {
          value = value.toLowerCase();
          return function equalsIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.toLowerCase() === value && next(elem);
          };
        }
        return function equals(elem) {
          return getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data) {
        var name = data.name, value = data.value, len = value.length;
        if (data.ignoreCase) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = getAttributeValue(elem, name);
          return attr != null && attr.substr(0, len) === value && (attr.length === len || attr.charAt(len) === "-") && next(elem);
        };
      },
      element: function(next, data) {
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return falseFunc;
        }
        value = value.replace(reChars, "\\$&");
        var pattern = "(?:^|\\s)" + value + "(?:$|\\s)", flags = data.ignoreCase ? "i" : "", regex = new RegExp(pattern, flags);
        return function element(elem) {
          var attr = getAttributeValue(elem, name);
          return attr != null && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, data) {
        var name = data.name;
        return function exists(elem) {
          return hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data) {
        var name = data.name, value = data.value, len = value.length;
        if (len === 0) {
          return falseFunc;
        }
        if (data.ignoreCase) {
          value = value.toLowerCase();
          return function startIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function start(elem) {
          var attr = getAttributeValue(elem, name);
          return attr != null && attr.substr(0, len) === value && next(elem);
        };
      },
      end: function(next, data) {
        var name = data.name, value = data.value, len = -value.length;
        if (len === 0) {
          return falseFunc;
        }
        if (data.ignoreCase) {
          value = value.toLowerCase();
          return function endIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
          };
        }
        return function end(elem) {
          var attr = getAttributeValue(elem, name);
          return attr != null && attr.substr(len) === value && next(elem);
        };
      },
      any: function(next, data) {
        var name = data.name, value = data.value;
        if (value === "") {
          return falseFunc;
        }
        if (data.ignoreCase) {
          var regex = new RegExp(value.replace(reChars, "\\$&"), "i");
          return function anyIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && regex.test(attr) && next(elem);
          };
        }
        return function any(elem) {
          var attr = getAttributeValue(elem, name);
          return attr != null && attr.indexOf(value) >= 0 && next(elem);
        };
      },
      not: function(next, data) {
        var name = data.name, value = data.value;
        if (value === "") {
          return function notEmpty(elem) {
            return !!getAttributeValue(elem, name) && next(elem);
          };
        } else if (data.ignoreCase) {
          value = value.toLowerCase();
          return function notIC(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.toLowerCase() !== value && next(elem);
          };
        }
        return function not(elem) {
          return getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
    module2.exports = {
      compile: function(next, data, options) {
        if (options && options.strict && (data.ignoreCase || data.action === "not"))
          throw SyntaxError("Unsupported attribute selector");
        return attributeRules[data.action](next, data);
      },
      rules: attributeRules
    };
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/pseudos.js
var require_pseudos = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/pseudos.js"(exports, module2) {
    var DomUtils = require_domutils2();
    var isTag = DomUtils.isTag;
    var getText = DomUtils.getText;
    var getParent = DomUtils.getParent;
    var getChildren = DomUtils.getChildren;
    var getSiblings = DomUtils.getSiblings;
    var hasAttrib = DomUtils.hasAttrib;
    var getName = DomUtils.getName;
    var getAttribute = DomUtils.getAttributeValue;
    var getNCheck = require_nth_check();
    var checkAttrib = require_attributes().rules.equals;
    var BaseFuncs = require_boolbase();
    var trueFunc = BaseFuncs.trueFunc;
    var falseFunc = BaseFuncs.falseFunc;
    function getFirstElement(elems) {
      for (var i = 0; elems && i < elems.length; i++) {
        if (isTag(elems[i]))
          return elems[i];
      }
    }
    function getAttribFunc(name, value) {
      var data = { name, value };
      return function attribFunc(next) {
        return checkAttrib(next, data);
      };
    }
    function getChildFunc(next) {
      return function(elem) {
        return !!getParent(elem) && next(elem);
      };
    }
    var filters = {
      contains: function(next, text) {
        return function contains(elem) {
          return next(elem) && getText(elem).indexOf(text) >= 0;
        };
      },
      icontains: function(next, text) {
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && getText(elem).toLowerCase().indexOf(itext) >= 0;
        };
      },
      "nth-child": function(next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
          return func;
        if (func === trueFunc)
          return getChildFunc(next);
        return function nthChild(elem) {
          var siblings = getSiblings(elem);
          for (var i = 0, pos = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              else
                pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
          return func;
        if (func === trueFunc)
          return getChildFunc(next);
        return function nthLastChild(elem) {
          var siblings = getSiblings(elem);
          for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              else
                pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
          return func;
        if (func === trueFunc)
          return getChildFunc(next);
        return function nthOfType(elem) {
          var siblings = getSiblings(elem);
          for (var pos = 0, i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              if (getName(siblings[i]) === getName(elem))
                pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
          return func;
        if (func === trueFunc)
          return getChildFunc(next);
        return function nthLastOfType(elem) {
          var siblings = getSiblings(elem);
          for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              if (getName(siblings[i]) === getName(elem))
                pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      root: function(next) {
        return function(elem) {
          return !getParent(elem) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        if (!context || context.length === 0) {
          return filters.root(next);
        }
        if (context.length === 1) {
          return function(elem) {
            return context[0] === elem && next(elem);
          };
        }
        return function(elem) {
          return context.indexOf(elem) >= 0 && next(elem);
        };
      },
      checkbox: getAttribFunc("type", "checkbox"),
      file: getAttribFunc("type", "file"),
      password: getAttribFunc("type", "password"),
      radio: getAttribFunc("type", "radio"),
      reset: getAttribFunc("type", "reset"),
      image: getAttribFunc("type", "image"),
      submit: getAttribFunc("type", "submit")
    };
    var pseudos = {
      empty: function(elem) {
        return !getChildren(elem).some(function(elem2) {
          return isTag(elem2) || elem2.type === "text";
        });
      },
      "first-child": function(elem) {
        return getFirstElement(getSiblings(elem)) === elem;
      },
      "last-child": function(elem) {
        var siblings = getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (siblings[i] === elem)
            return true;
          if (isTag(siblings[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem) {
        var siblings = getSiblings(elem);
        for (var i = 0; i < siblings.length; i++) {
          if (isTag(siblings[i])) {
            if (siblings[i] === elem)
              return true;
            if (getName(siblings[i]) === getName(elem))
              break;
          }
        }
        return false;
      },
      "last-of-type": function(elem) {
        var siblings = getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (isTag(siblings[i])) {
            if (siblings[i] === elem)
              return true;
            if (getName(siblings[i]) === getName(elem))
              break;
          }
        }
        return false;
      },
      "only-of-type": function(elem) {
        var siblings = getSiblings(elem);
        for (var i = 0, j = siblings.length; i < j; i++) {
          if (isTag(siblings[i])) {
            if (siblings[i] === elem)
              continue;
            if (getName(siblings[i]) === getName(elem))
              return false;
          }
        }
        return true;
      },
      "only-child": function(elem) {
        var siblings = getSiblings(elem);
        for (var i = 0; i < siblings.length; i++) {
          if (isTag(siblings[i]) && siblings[i] !== elem)
            return false;
        }
        return true;
      },
      link: function(elem) {
        return hasAttrib(elem, "href");
      },
      visited: falseFunc,
      selected: function(elem) {
        if (hasAttrib(elem, "selected"))
          return true;
        else if (getName(elem) !== "option")
          return false;
        var parent = getParent(elem);
        if (!parent || getName(parent) !== "select" || hasAttrib(parent, "multiple"))
          return false;
        var siblings = getChildren(parent), sawElem = false;
        for (var i = 0; i < siblings.length; i++) {
          if (isTag(siblings[i])) {
            if (siblings[i] === elem) {
              sawElem = true;
            } else if (!sawElem) {
              return false;
            } else if (hasAttrib(siblings[i], "selected")) {
              return false;
            }
          }
        }
        return sawElem;
      },
      disabled: function(elem) {
        return hasAttrib(elem, "disabled");
      },
      enabled: function(elem) {
        return !hasAttrib(elem, "disabled");
      },
      checked: function(elem) {
        return hasAttrib(elem, "checked") || pseudos.selected(elem);
      },
      required: function(elem) {
        return hasAttrib(elem, "required");
      },
      optional: function(elem) {
        return !hasAttrib(elem, "required");
      },
      parent: function(elem) {
        return !pseudos.empty(elem);
      },
      header: function(elem) {
        var name = getName(elem);
        return name === "h1" || name === "h2" || name === "h3" || name === "h4" || name === "h5" || name === "h6";
      },
      button: function(elem) {
        var name = getName(elem);
        return name === "button" || name === "input" && getAttribute(elem, "type") === "button";
      },
      input: function(elem) {
        var name = getName(elem);
        return name === "input" || name === "textarea" || name === "select" || name === "button";
      },
      text: function(elem) {
        var attr;
        return getName(elem) === "input" && (!(attr = getAttribute(elem, "type")) || attr.toLowerCase() === "text");
      }
    };
    function verifyArgs(func, name, subselect) {
      if (subselect === null) {
        if (func.length > 1 && name !== "scope") {
          throw new SyntaxError("pseudo-selector :" + name + " requires an argument");
        }
      } else {
        if (func.length === 1) {
          throw new SyntaxError("pseudo-selector :" + name + " doesn't have any arguments");
        }
      }
    }
    var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
    module2.exports = {
      compile: function(next, data, options, context) {
        var name = data.name, subselect = data.data;
        if (options && options.strict && !re_CSS3.test(name)) {
          throw SyntaxError(":" + name + " isn't part of CSS3");
        }
        if (typeof filters[name] === "function") {
          verifyArgs(filters[name], name, subselect);
          return filters[name](next, subselect, options, context);
        } else if (typeof pseudos[name] === "function") {
          var func = pseudos[name];
          verifyArgs(func, name, subselect);
          if (next === trueFunc)
            return func;
          return function pseudoArgs(elem) {
            return func(elem, subselect) && next(elem);
          };
        } else {
          throw new SyntaxError("unmatched pseudo-class :" + name);
        }
      },
      filters,
      pseudos
    };
  }
});

// ../../node_modules/.pnpm/css-what@2.1.3/node_modules/css-what/index.js
var require_css_what = __commonJS({
  "../../node_modules/.pnpm/css-what@2.1.3/node_modules/css-what/index.js"(exports, module2) {
    "use strict";
    module2.exports = parse;
    var re_name = /^(?:\\.|[\w\-\u00b0-\uFFFF])+/;
    var re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig;
    var re_attr = /^\s*((?:\\.|[\w\u00b0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF\-])*)|)|)\s*(i)?\]/;
    var actionTypes = {
      __proto__: null,
      "undefined": "exists",
      "": "equals",
      "~": "element",
      "^": "start",
      "$": "end",
      "*": "any",
      "!": "not",
      "|": "hyphen"
    };
    var simpleSelectors = {
      __proto__: null,
      ">": "child",
      "<": "parent",
      "~": "sibling",
      "+": "adjacent"
    };
    var attribSelectors = {
      __proto__: null,
      "#": ["id", "equals"],
      ".": ["class", "element"]
    };
    var unpackPseudos = {
      __proto__: null,
      "has": true,
      "not": true,
      "matches": true
    };
    var stripQuotesFromPseudos = {
      __proto__: null,
      "contains": true,
      "icontains": true
    };
    var quotes = {
      __proto__: null,
      '"': true,
      "'": true
    };
    function funescape(_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    }
    function unescapeCSS(str) {
      return str.replace(re_escape, funescape);
    }
    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
    }
    function parse(selector, options) {
      var subselects = [];
      selector = parseSelector(subselects, selector + "", options);
      if (selector !== "") {
        throw new SyntaxError("Unmatched selector: " + selector);
      }
      return subselects;
    }
    function parseSelector(subselects, selector, options) {
      var tokens = [], sawWS = false, data, firstChar, name, quot;
      function getName() {
        var sub = selector.match(re_name)[0];
        selector = selector.substr(sub.length);
        return unescapeCSS(sub);
      }
      function stripWhitespace(start) {
        while (isWhitespace(selector.charAt(start)))
          start++;
        selector = selector.substr(start);
      }
      function isEscaped(pos2) {
        var slashCount = 0;
        while (selector.charAt(--pos2) === "\\")
          slashCount++;
        return (slashCount & 1) === 1;
      }
      stripWhitespace(0);
      while (selector !== "") {
        firstChar = selector.charAt(0);
        if (isWhitespace(firstChar)) {
          sawWS = true;
          stripWhitespace(1);
        } else if (firstChar in simpleSelectors) {
          tokens.push({ type: simpleSelectors[firstChar] });
          sawWS = false;
          stripWhitespace(1);
        } else if (firstChar === ",") {
          if (tokens.length === 0) {
            throw new SyntaxError("empty sub-selector");
          }
          subselects.push(tokens);
          tokens = [];
          sawWS = false;
          stripWhitespace(1);
        } else {
          if (sawWS) {
            if (tokens.length > 0) {
              tokens.push({ type: "descendant" });
            }
            sawWS = false;
          }
          if (firstChar === "*") {
            selector = selector.substr(1);
            tokens.push({ type: "universal" });
          } else if (firstChar in attribSelectors) {
            selector = selector.substr(1);
            tokens.push({
              type: "attribute",
              name: attribSelectors[firstChar][0],
              action: attribSelectors[firstChar][1],
              value: getName(),
              ignoreCase: false
            });
          } else if (firstChar === "[") {
            selector = selector.substr(1);
            data = selector.match(re_attr);
            if (!data) {
              throw new SyntaxError("Malformed attribute selector: " + selector);
            }
            selector = selector.substr(data[0].length);
            name = unescapeCSS(data[1]);
            if (!options || ("lowerCaseAttributeNames" in options ? options.lowerCaseAttributeNames : !options.xmlMode)) {
              name = name.toLowerCase();
            }
            tokens.push({
              type: "attribute",
              name,
              action: actionTypes[data[2]],
              value: unescapeCSS(data[4] || data[5] || ""),
              ignoreCase: !!data[6]
            });
          } else if (firstChar === ":") {
            if (selector.charAt(1) === ":") {
              selector = selector.substr(2);
              tokens.push({ type: "pseudo-element", name: getName().toLowerCase() });
              continue;
            }
            selector = selector.substr(1);
            name = getName().toLowerCase();
            data = null;
            if (selector.charAt(0) === "(") {
              if (name in unpackPseudos) {
                quot = selector.charAt(1);
                var quoted = quot in quotes;
                selector = selector.substr(quoted + 1);
                data = [];
                selector = parseSelector(data, selector, options);
                if (quoted) {
                  if (selector.charAt(0) !== quot) {
                    throw new SyntaxError("unmatched quotes in :" + name);
                  } else {
                    selector = selector.substr(1);
                  }
                }
                if (selector.charAt(0) !== ")") {
                  throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
                }
                selector = selector.substr(1);
              } else {
                var pos = 1, counter = 1;
                for (; counter > 0 && pos < selector.length; pos++) {
                  if (selector.charAt(pos) === "(" && !isEscaped(pos))
                    counter++;
                  else if (selector.charAt(pos) === ")" && !isEscaped(pos))
                    counter--;
                }
                if (counter) {
                  throw new SyntaxError("parenthesis not matched");
                }
                data = selector.substr(1, pos - 2);
                selector = selector.substr(pos);
                if (name in stripQuotesFromPseudos) {
                  quot = data.charAt(0);
                  if (quot === data.slice(-1) && quot in quotes) {
                    data = data.slice(1, -1);
                  }
                  data = unescapeCSS(data);
                }
              }
            }
            tokens.push({ type: "pseudo", name, data });
          } else if (re_name.test(selector)) {
            name = getName();
            if (!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)) {
              name = name.toLowerCase();
            }
            tokens.push({ type: "tag", name });
          } else {
            if (tokens.length && tokens[tokens.length - 1].type === "descendant") {
              tokens.pop();
            }
            addToken(subselects, tokens);
            return selector;
          }
        }
      }
      addToken(subselects, tokens);
      return selector;
    }
    function addToken(subselects, tokens) {
      if (subselects.length > 0 && tokens.length === 0) {
        throw new SyntaxError("empty sub-selector");
      }
      subselects.push(tokens);
    }
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/general.js"(exports, module2) {
    var DomUtils = require_domutils2();
    var isTag = DomUtils.isTag;
    var getParent = DomUtils.getParent;
    var getChildren = DomUtils.getChildren;
    var getSiblings = DomUtils.getSiblings;
    var getName = DomUtils.getName;
    module2.exports = {
      __proto__: null,
      attribute: require_attributes().compile,
      pseudo: require_pseudos().compile,
      tag: function(next, data) {
        var name = data.name;
        return function tag(elem) {
          return getName(elem) === name && next(elem);
        };
      },
      descendant: function(next, rule, options, context, acceptSelf) {
        return function descendant(elem) {
          if (acceptSelf && next(elem))
            return true;
          var found = false;
          while (!found && (elem = getParent(elem))) {
            found = next(elem);
          }
          return found;
        };
      },
      parent: function(next, data, options) {
        if (options && options.strict)
          throw SyntaxError("Parent selector isn't part of CSS3");
        return function parent(elem) {
          return getChildren(elem).some(test);
        };
        function test(elem) {
          return isTag(elem) && next(elem);
        }
      },
      child: function(next) {
        return function child(elem) {
          var parent = getParent(elem);
          return !!parent && next(parent);
        };
      },
      sibling: function(next) {
        return function sibling(elem) {
          var siblings = getSiblings(elem);
          for (var i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              if (next(siblings[i]))
                return true;
            }
          }
          return false;
        };
      },
      adjacent: function(next) {
        return function adjacent(elem) {
          var siblings = getSiblings(elem), lastElement;
          for (var i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
              if (siblings[i] === elem)
                break;
              lastElement = siblings[i];
            }
          }
          return !!lastElement && next(lastElement);
        };
      },
      universal: function(next) {
        return next;
      }
    };
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/procedure.json
var require_procedure = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/procedure.json"(exports, module2) {
    module2.exports = {
      universal: 50,
      tag: 30,
      attribute: 1,
      pseudo: 0,
      descendant: -1,
      child: -1,
      parent: -1,
      sibling: -1,
      adjacent: -1
    };
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/sort.js"(exports, module2) {
    module2.exports = sortByProcedure;
    var procedure = require_procedure();
    var attributes = {
      __proto__: null,
      exists: 10,
      equals: 8,
      not: 7,
      start: 6,
      end: 6,
      any: 5,
      hyphen: 4,
      element: 4
    };
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    function getProcedure(token) {
      var proc = procedure[token.type];
      if (proc === procedure.attribute) {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (proc === procedure.pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (token.name === "matches" || token.name === "not") {
          proc = 0;
          for (var i = 0; i < token.data.length; i++) {
            if (token.data[i].length !== 1)
              continue;
            var cur = getProcedure(token.data[i][0]);
            if (cur === 0) {
              proc = 0;
              break;
            }
            if (cur > proc)
              proc = cur;
          }
          if (token.data.length > 1 && proc > 0)
            proc -= 1;
        } else {
          proc = 1;
        }
      }
      return proc;
    }
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/lib/compile.js"(exports, module2) {
    module2.exports = compile;
    module2.exports.compileUnsafe = compileUnsafe;
    module2.exports.compileToken = compileToken;
    var parse = require_css_what();
    var DomUtils = require_domutils2();
    var isTag = DomUtils.isTag;
    var Rules = require_general();
    var sortRules = require_sort();
    var BaseFuncs = require_boolbase();
    var trueFunc = BaseFuncs.trueFunc;
    var falseFunc = BaseFuncs.falseFunc;
    var procedure = require_procedure();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return wrap(next);
    }
    function wrap(next) {
      return function base(elem) {
        return isTag(elem) && next(elem);
      };
    }
    function compileUnsafe(selector, options, context) {
      var token = parse(selector, options);
      return compileToken(token, options, context);
    }
    function includesScopePseudo(t2) {
      return t2.type === "pseudo" && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: "descendant" };
    var SCOPE_TOKEN = { type: "pseudo", name: "scope" };
    var PLACEHOLDER_ELEMENT = {};
    var getParent = DomUtils.getParent;
    function absolutize(token, context) {
      var hasContext = !!context && !!context.length && context.every(function(e) {
        return e === PLACEHOLDER_ELEMENT || !!getParent(e);
      });
      token.forEach(function(t2) {
        if (t2.length > 0 && isTraversal(t2[0]) && t2[0].type !== "descendant") {
        } else if (hasContext && !includesScopePseudo(t2)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          return;
        }
        t2.unshift(SCOPE_TOKEN);
      });
    }
    function compileToken(token, options, context) {
      token = token.filter(function(t2) {
        return t2.length > 0;
      });
      token.forEach(sortRules);
      var isArrayContext = Array.isArray(context);
      context = options && options.context || context;
      if (context && !isArrayContext)
        context = [context];
      absolutize(token, context);
      return token.map(function(rules) {
        return compileRules(rules, options, context, isArrayContext);
      }).reduce(reduceRules, falseFunc);
    }
    function isTraversal(t2) {
      return procedure[t2.type] < 0;
    }
    function compileRules(rules, options, context, isArrayContext) {
      var acceptSelf = isArrayContext && rules[0].name === "scope" && rules[1].type === "descendant";
      return rules.reduce(function(func, rule, index) {
        if (func === falseFunc)
          return func;
        return Rules[rule.type](func, rule, options, context, acceptSelf && index === 1);
      }, options && options.rootFunc || trueFunc);
    }
    function reduceRules(a, b) {
      if (b === falseFunc || a === trueFunc) {
        return a;
      }
      if (a === falseFunc || b === trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
    var Pseudos = require_pseudos();
    var filters = Pseudos.filters;
    var existsOne = DomUtils.existsOne;
    var isTag = DomUtils.isTag;
    var getChildren = DomUtils.getChildren;
    function containsTraversal(t2) {
      return t2.some(isTraversal);
    }
    filters.not = function(next, token, options, context) {
      var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict)
      };
      if (opts.strict) {
        if (token.length > 1 || token.some(containsTraversal)) {
          throw new SyntaxError("complex selectors in :not aren't allowed in strict mode");
        }
      }
      var func = compileToken(token, opts, context);
      if (func === falseFunc)
        return next;
      if (func === trueFunc)
        return falseFunc;
      return function(elem) {
        return !func(elem) && next(elem);
      };
    };
    filters.has = function(next, token, options) {
      var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict)
      };
      var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;
      var func = compileToken(token, opts, context);
      if (func === falseFunc)
        return falseFunc;
      if (func === trueFunc)
        return function(elem) {
          return getChildren(elem).some(isTag) && next(elem);
        };
      func = wrap(func);
      if (context) {
        return function has(elem) {
          return next(elem) && (context[0] = elem, existsOne(func, getChildren(elem)));
        };
      }
      return function has(elem) {
        return next(elem) && existsOne(func, getChildren(elem));
      };
    };
    filters.matches = function(next, token, options, context) {
      var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        rootFunc: next
      };
      return compileToken(token, opts, context);
    };
  }
});

// ../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/index.js
var require_css_select = __commonJS({
  "../../node_modules/.pnpm/css-select@1.2.0/node_modules/css-select/index.js"(exports, module2) {
    "use strict";
    module2.exports = CSSselect;
    var Pseudos = require_pseudos();
    var DomUtils = require_domutils2();
    var findOne = DomUtils.findOne;
    var findAll = DomUtils.findAll;
    var getChildren = DomUtils.getChildren;
    var removeSubsets = DomUtils.removeSubsets;
    var falseFunc = require_boolbase().falseFunc;
    var compile = require_compile2();
    var compileUnsafe = compile.compileUnsafe;
    var compileToken = compile.compileToken;
    function getSelectorFunc(searchFunc) {
      return function select(query, elems, options) {
        if (typeof query !== "function")
          query = compileUnsafe(query, options, elems);
        if (!Array.isArray(elems))
          elems = getChildren(elems);
        else
          elems = removeSubsets(elems);
        return searchFunc(query, elems);
      };
    }
    var selectAll = getSelectorFunc(function selectAll2(query, elems) {
      return query === falseFunc || !elems || elems.length === 0 ? [] : findAll(query, elems);
    });
    var selectOne = getSelectorFunc(function selectOne2(query, elems) {
      return query === falseFunc || !elems || elems.length === 0 ? null : findOne(query, elems);
    });
    function is(elem, query, options) {
      return (typeof query === "function" ? query : compile(query, options))(elem);
    }
    function CSSselect(query, elems, options) {
      return selectAll(query, elems, options);
    }
    CSSselect.compile = compile;
    CSSselect.filters = Pseudos.filters;
    CSSselect.pseudos = Pseudos.pseudos;
    CSSselect.selectAll = selectAll;
    CSSselect.selectOne = selectOne;
    CSSselect.is = is;
    CSSselect.parse = compile;
    CSSselect.iterate = selectAll;
    CSSselect._compileUnsafe = compileUnsafe;
    CSSselect._compileToken = compileToken;
  }
});

// ../../node_modules/.pnpm/lodash.merge@4.6.2/node_modules/lodash.merge/index.js
var require_lodash5 = __commonJS({
  "../../node_modules/.pnpm/lodash.merge@4.6.2/node_modules/lodash.merge/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = merge;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/static.js
var require_static = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/static.js"(exports) {
    var serialize = require_dom_serializer();
    var select = require_css_select();
    var parse = require_parse();
    var _ = {
      merge: require_lodash5(),
      defaults: require_lodash4()
    };
    exports.load = function(content, options) {
      var Cheerio = require_cheerio();
      options = _.defaults(options || {}, Cheerio.prototype.options);
      var root = parse(content, options);
      var initialize = function(selector, context, r, opts) {
        if (!(this instanceof initialize)) {
          return new initialize(selector, context, r, opts);
        }
        opts = _.defaults(opts || {}, options);
        return Cheerio.call(this, selector, context, r || root, opts);
      };
      initialize.prototype = Object.create(Cheerio.prototype);
      initialize.prototype.constructor = initialize;
      initialize.fn = initialize.prototype;
      initialize.prototype._originalRoot = root;
      _.merge(initialize, exports);
      initialize._root = root;
      initialize._options = options;
      return initialize;
    };
    function render(that, dom, options) {
      if (!dom) {
        if (that._root && that._root.children) {
          dom = that._root.children;
        } else {
          return "";
        }
      } else if (typeof dom === "string") {
        dom = select(dom, that._root, options);
      }
      return serialize(dom, options);
    }
    exports.html = function(dom, options) {
      var Cheerio = require_cheerio();
      if (Object.prototype.toString.call(dom) === "[object Object]" && !options && !("length" in dom) && !("type" in dom)) {
        options = dom;
        dom = void 0;
      }
      options = _.defaults(options || {}, this._options, Cheerio.prototype.options);
      return render(this, dom, options);
    };
    exports.xml = function(dom) {
      var options = _.defaults({ xmlMode: true }, this._options);
      return render(this, dom, options);
    };
    exports.text = function(elems) {
      if (!elems) {
        elems = this.root();
      }
      var ret = "", len = elems.length, elem;
      for (var i = 0; i < len; i++) {
        elem = elems[i];
        if (elem.type === "text")
          ret += elem.data;
        else if (elem.children && elem.type !== "comment") {
          ret += exports.text(elem.children);
        }
      }
      return ret;
    };
    exports.parseHTML = function(data, context, keepScripts) {
      var parsed;
      if (!data || typeof data !== "string") {
        return null;
      }
      if (typeof context === "boolean") {
        keepScripts = context;
      }
      parsed = this.load(data);
      if (!keepScripts) {
        parsed("script").remove();
      }
      return parsed.root()[0].children.slice();
    };
    exports.root = function() {
      return this(this._root);
    };
    exports.contains = function(container, contained) {
      if (contained === container) {
        return false;
      }
      while (contained && contained !== contained.parent) {
        contained = contained.parent;
        if (contained === container) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../../node_modules/.pnpm/lodash.some@4.6.0/node_modules/lodash.some/index.js
var require_lodash6 = __commonJS({
  "../../node_modules/.pnpm/lodash.some@4.6.0/node_modules/lodash.some/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = some;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/attributes.js
var require_attributes2 = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/attributes.js"(exports) {
    var $ = require_static();
    var utils = require_utils();
    var isTag = utils.isTag;
    var domEach = utils.domEach;
    var hasOwn = Object.prototype.hasOwnProperty;
    var camelCase = utils.camelCase;
    var cssCase = utils.cssCase;
    var rspace = /\s+/;
    var dataAttrPrefix = "data-";
    var _ = {
      forEach: require_lodash3(),
      extend: require_lodash(),
      some: require_lodash6()
    };
    var primitives = {
      null: null,
      true: true,
      false: false
    };
    var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;
    var getAttr = function(elem, name) {
      if (!elem || !isTag(elem))
        return;
      if (!elem.attribs) {
        elem.attribs = {};
      }
      if (!name) {
        return elem.attribs;
      }
      if (hasOwn.call(elem.attribs, name)) {
        return rboolean.test(name) ? name : elem.attribs[name];
      }
      if (elem.name === "option" && name === "value") {
        return $.text(elem.children);
      }
      if (elem.name === "input" && (elem.attribs.type === "radio" || elem.attribs.type === "checkbox") && name === "value") {
        return "on";
      }
    };
    var setAttr = function(el, name, value) {
      if (value === null) {
        removeAttribute(el, name);
      } else {
        el.attribs[name] = value + "";
      }
    };
    exports.attr = function(name, value) {
      if (typeof name === "object" || value !== void 0) {
        if (typeof value === "function") {
          return domEach(this, function(i, el) {
            setAttr(el, name, value.call(el, i, el.attribs[name]));
          });
        }
        return domEach(this, function(i, el) {
          if (!isTag(el))
            return;
          if (typeof name === "object") {
            _.forEach(name, function(value2, name2) {
              setAttr(el, name2, value2);
            });
          } else {
            setAttr(el, name, value);
          }
        });
      }
      return getAttr(this[0], name);
    };
    var getProp = function(el, name) {
      if (!el || !isTag(el))
        return;
      return el.hasOwnProperty(name) ? el[name] : rboolean.test(name) ? getAttr(el, name) !== void 0 : getAttr(el, name);
    };
    var setProp = function(el, name, value) {
      el[name] = rboolean.test(name) ? !!value : value;
    };
    exports.prop = function(name, value) {
      var i = 0, property;
      if (typeof name === "string" && value === void 0) {
        switch (name) {
          case "style":
            property = this.css();
            _.forEach(property, function(v, p) {
              property[i++] = p;
            });
            property.length = i;
            break;
          case "tagName":
          case "nodeName":
            property = this[0].name.toUpperCase();
            break;
          default:
            property = getProp(this[0], name);
        }
        return property;
      }
      if (typeof name === "object" || value !== void 0) {
        if (typeof value === "function") {
          return domEach(this, function(i2, el) {
            setProp(el, name, value.call(el, i2, getProp(el, name)));
          });
        }
        return domEach(this, function(i2, el) {
          if (!isTag(el))
            return;
          if (typeof name === "object") {
            _.forEach(name, function(val, name2) {
              setProp(el, name2, val);
            });
          } else {
            setProp(el, name, value);
          }
        });
      }
    };
    var setData = function(el, name, value) {
      if (!el.data) {
        el.data = {};
      }
      if (typeof name === "object")
        return _.extend(el.data, name);
      if (typeof name === "string" && value !== void 0) {
        el.data[name] = value;
      } else if (typeof name === "object") {
        _.extend(el.data, name);
      }
    };
    var readData = function(el, name) {
      var readAll = arguments.length === 1;
      var domNames, domName, jsNames, jsName, value, idx, length;
      if (readAll) {
        domNames = Object.keys(el.attribs).filter(function(attrName) {
          return attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix;
        });
        jsNames = domNames.map(function(domName2) {
          return camelCase(domName2.slice(dataAttrPrefix.length));
        });
      } else {
        domNames = [dataAttrPrefix + cssCase(name)];
        jsNames = [name];
      }
      for (idx = 0, length = domNames.length; idx < length; ++idx) {
        domName = domNames[idx];
        jsName = jsNames[idx];
        if (hasOwn.call(el.attribs, domName)) {
          value = el.attribs[domName];
          if (hasOwn.call(primitives, value)) {
            value = primitives[value];
          } else if (value === String(Number(value))) {
            value = Number(value);
          } else if (rbrace.test(value)) {
            try {
              value = JSON.parse(value);
            } catch (e) {
            }
          }
          el.data[jsName] = value;
        }
      }
      return readAll ? el.data : value;
    };
    exports.data = function(name, value) {
      var elem = this[0];
      if (!elem || !isTag(elem))
        return;
      if (!elem.data) {
        elem.data = {};
      }
      if (!name) {
        return readData(elem);
      }
      if (typeof name === "object" || value !== void 0) {
        domEach(this, function(i, el) {
          setData(el, name, value);
        });
        return this;
      } else if (hasOwn.call(elem.data, name)) {
        return elem.data[name];
      }
      return readData(elem, name);
    };
    exports.val = function(value) {
      var querying = arguments.length === 0, element = this[0];
      if (!element)
        return;
      switch (element.name) {
        case "textarea":
          return this.text(value);
        case "input":
          switch (this.attr("type")) {
            case "radio":
              if (querying) {
                return this.attr("value");
              } else {
                this.attr("value", value);
                return this;
              }
              break;
            default:
              return this.attr("value", value);
          }
          return;
        case "select":
          var option = this.find("option:selected"), returnValue;
          if (option === void 0)
            return void 0;
          if (!querying) {
            if (!this.attr().hasOwnProperty("multiple") && typeof value == "object") {
              return this;
            }
            if (typeof value != "object") {
              value = [value];
            }
            this.find("option").removeAttr("selected");
            for (var i = 0; i < value.length; i++) {
              this.find('option[value="' + value[i] + '"]').attr("selected", "");
            }
            return this;
          }
          returnValue = option.attr("value");
          if (this.attr().hasOwnProperty("multiple")) {
            returnValue = [];
            domEach(option, function(i2, el) {
              returnValue.push(getAttr(el, "value"));
            });
          }
          return returnValue;
        case "option":
          if (!querying) {
            this.attr("value", value);
            return this;
          }
          return this.attr("value");
      }
    };
    var removeAttribute = function(elem, name) {
      if (!elem.attribs || !hasOwn.call(elem.attribs, name))
        return;
      delete elem.attribs[name];
    };
    exports.removeAttr = function(name) {
      domEach(this, function(i, elem) {
        removeAttribute(elem, name);
      });
      return this;
    };
    exports.hasClass = function(className) {
      return _.some(this, function(elem) {
        var attrs = elem.attribs, clazz = attrs && attrs["class"], idx = -1, end;
        if (clazz) {
          while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
            end = idx + className.length;
            if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end === clazz.length || rspace.test(clazz[end]))) {
              return true;
            }
          }
        }
      });
    };
    exports.addClass = function(value) {
      if (typeof value === "function") {
        return domEach(this, function(i2, el) {
          var className2 = el.attribs["class"] || "";
          exports.addClass.call([el], value.call(el, i2, className2));
        });
      }
      if (!value || typeof value !== "string")
        return this;
      var classNames = value.split(rspace), numElements = this.length;
      for (var i = 0; i < numElements; i++) {
        if (!isTag(this[i]))
          continue;
        var className = getAttr(this[i], "class"), numClasses, setClass;
        if (!className) {
          setAttr(this[i], "class", classNames.join(" ").trim());
        } else {
          setClass = " " + className + " ";
          numClasses = classNames.length;
          for (var j = 0; j < numClasses; j++) {
            var appendClass = classNames[j] + " ";
            if (setClass.indexOf(" " + appendClass) < 0)
              setClass += appendClass;
          }
          setAttr(this[i], "class", setClass.trim());
        }
      }
      return this;
    };
    var splitClass = function(className) {
      return className ? className.trim().split(rspace) : [];
    };
    exports.removeClass = function(value) {
      var classes, numClasses, removeAll;
      if (typeof value === "function") {
        return domEach(this, function(i, el) {
          exports.removeClass.call([el], value.call(el, i, el.attribs["class"] || ""));
        });
      }
      classes = splitClass(value);
      numClasses = classes.length;
      removeAll = arguments.length === 0;
      return domEach(this, function(i, el) {
        if (!isTag(el))
          return;
        if (removeAll) {
          el.attribs.class = "";
        } else {
          var elClasses = splitClass(el.attribs.class), index, changed;
          for (var j = 0; j < numClasses; j++) {
            index = elClasses.indexOf(classes[j]);
            if (index >= 0) {
              elClasses.splice(index, 1);
              changed = true;
              j--;
            }
          }
          if (changed) {
            el.attribs.class = elClasses.join(" ");
          }
        }
      });
    };
    exports.toggleClass = function(value, stateVal) {
      if (typeof value === "function") {
        return domEach(this, function(i2, el) {
          exports.toggleClass.call([el], value.call(el, i2, el.attribs["class"] || "", stateVal), stateVal);
        });
      }
      if (!value || typeof value !== "string")
        return this;
      var classNames = value.split(rspace), numClasses = classNames.length, state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0, numElements = this.length, elementClasses, index;
      for (var i = 0; i < numElements; i++) {
        if (!isTag(this[i]))
          continue;
        elementClasses = splitClass(this[i].attribs.class);
        for (var j = 0; j < numClasses; j++) {
          index = elementClasses.indexOf(classNames[j]);
          if (state >= 0 && index < 0) {
            elementClasses.push(classNames[j]);
          } else if (state <= 0 && index >= 0) {
            elementClasses.splice(index, 1);
          }
        }
        this[i].attribs.class = elementClasses.join(" ");
      }
      return this;
    };
    exports.is = function(selector) {
      if (selector) {
        return this.filter(selector).length > 0;
      }
      return false;
    };
  }
});

// ../../node_modules/.pnpm/lodash.reject@4.6.0/node_modules/lodash.reject/index.js
var require_lodash7 = __commonJS({
  "../../node_modules/.pnpm/lodash.reject@4.6.0/node_modules/lodash.reject/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = reject;
  }
});

// ../../node_modules/.pnpm/lodash.filter@4.6.0/node_modules/lodash.filter/index.js
var require_lodash8 = __commonJS({
  "../../node_modules/.pnpm/lodash.filter@4.6.0/node_modules/lodash.filter/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = filter;
  }
});

// ../../node_modules/.pnpm/lodash.reduce@4.6.0/node_modules/lodash.reduce/index.js
var require_lodash9 = __commonJS({
  "../../node_modules/.pnpm/lodash.reduce@4.6.0/node_modules/lodash.reduce/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = reduce;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/traversing.js
var require_traversing = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/traversing.js"(exports) {
    var select = require_css_select();
    var utils = require_utils();
    var domEach = utils.domEach;
    var uniqueSort = require_lib2().DomUtils.uniqueSort;
    var isTag = utils.isTag;
    var _ = {
      bind: require_lodash2(),
      forEach: require_lodash3(),
      reject: require_lodash7(),
      filter: require_lodash8(),
      reduce: require_lodash9()
    };
    exports.find = function(selectorOrHaystack) {
      var elems = _.reduce(this, function(memo, elem) {
        return memo.concat(_.filter(elem.children, isTag));
      }, []);
      var contains = this.constructor.contains;
      var haystack;
      if (selectorOrHaystack && typeof selectorOrHaystack !== "string") {
        if (selectorOrHaystack.cheerio) {
          haystack = selectorOrHaystack.get();
        } else {
          haystack = [selectorOrHaystack];
        }
        return this._make(haystack.filter(function(elem) {
          var idx, len;
          for (idx = 0, len = this.length; idx < len; ++idx) {
            if (contains(this[idx], elem)) {
              return true;
            }
          }
        }, this));
      }
      var options = { __proto__: this.options, context: this.toArray() };
      return this._make(select(selectorOrHaystack, elems, options));
    };
    exports.parent = function(selector) {
      var set = [];
      domEach(this, function(idx, elem) {
        var parentElem = elem.parent;
        if (parentElem && set.indexOf(parentElem) < 0) {
          set.push(parentElem);
        }
      });
      if (arguments.length) {
        set = exports.filter.call(set, selector, this);
      }
      return this._make(set);
    };
    exports.parents = function(selector) {
      var parentNodes = [];
      this.get().reverse().forEach(function(elem) {
        traverseParents(this, elem.parent, selector, Infinity).forEach(function(node) {
          if (parentNodes.indexOf(node) === -1) {
            parentNodes.push(node);
          }
        });
      }, this);
      return this._make(parentNodes);
    };
    exports.parentsUntil = function(selector, filter) {
      var parentNodes = [], untilNode, untilNodes;
      if (typeof selector === "string") {
        untilNode = select(selector, this.parents().toArray(), this.options)[0];
      } else if (selector && selector.cheerio) {
        untilNodes = selector.toArray();
      } else if (selector) {
        untilNode = selector;
      }
      this.toArray().reverse().forEach(function(elem) {
        while (elem = elem.parent) {
          if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
            if (isTag(elem) && parentNodes.indexOf(elem) === -1) {
              parentNodes.push(elem);
            }
          } else {
            break;
          }
        }
      }, this);
      return this._make(filter ? select(filter, parentNodes, this.options) : parentNodes);
    };
    exports.closest = function(selector) {
      var set = [];
      if (!selector) {
        return this._make(set);
      }
      domEach(this, function(idx, elem) {
        var closestElem = traverseParents(this, elem, selector, 1)[0];
        if (closestElem && set.indexOf(closestElem) < 0) {
          set.push(closestElem);
        }
      }.bind(this));
      return this._make(set);
    };
    exports.next = function(selector) {
      if (!this[0]) {
        return this;
      }
      var elems = [];
      _.forEach(this, function(elem) {
        while (elem = elem.next) {
          if (isTag(elem)) {
            elems.push(elem);
            return;
          }
        }
      });
      return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
    };
    exports.nextAll = function(selector) {
      if (!this[0]) {
        return this;
      }
      var elems = [];
      _.forEach(this, function(elem) {
        while (elem = elem.next) {
          if (isTag(elem) && elems.indexOf(elem) === -1) {
            elems.push(elem);
          }
        }
      });
      return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
    };
    exports.nextUntil = function(selector, filterSelector) {
      if (!this[0]) {
        return this;
      }
      var elems = [], untilNode, untilNodes;
      if (typeof selector === "string") {
        untilNode = select(selector, this.nextAll().get(), this.options)[0];
      } else if (selector && selector.cheerio) {
        untilNodes = selector.get();
      } else if (selector) {
        untilNode = selector;
      }
      _.forEach(this, function(elem) {
        while (elem = elem.next) {
          if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
            if (isTag(elem) && elems.indexOf(elem) === -1) {
              elems.push(elem);
            }
          } else {
            break;
          }
        }
      });
      return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
    };
    exports.prev = function(selector) {
      if (!this[0]) {
        return this;
      }
      var elems = [];
      _.forEach(this, function(elem) {
        while (elem = elem.prev) {
          if (isTag(elem)) {
            elems.push(elem);
            return;
          }
        }
      });
      return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
    };
    exports.prevAll = function(selector) {
      if (!this[0]) {
        return this;
      }
      var elems = [];
      _.forEach(this, function(elem) {
        while (elem = elem.prev) {
          if (isTag(elem) && elems.indexOf(elem) === -1) {
            elems.push(elem);
          }
        }
      });
      return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
    };
    exports.prevUntil = function(selector, filterSelector) {
      if (!this[0]) {
        return this;
      }
      var elems = [], untilNode, untilNodes;
      if (typeof selector === "string") {
        untilNode = select(selector, this.prevAll().get(), this.options)[0];
      } else if (selector && selector.cheerio) {
        untilNodes = selector.get();
      } else if (selector) {
        untilNode = selector;
      }
      _.forEach(this, function(elem) {
        while (elem = elem.prev) {
          if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
            if (isTag(elem) && elems.indexOf(elem) === -1) {
              elems.push(elem);
            }
          } else {
            break;
          }
        }
      });
      return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
    };
    exports.siblings = function(selector) {
      var parent = this.parent();
      var elems = _.filter(parent ? parent.children() : this.siblingsAndMe(), _.bind(function(elem) {
        return isTag(elem) && !this.is(elem);
      }, this));
      if (selector !== void 0) {
        return exports.filter.call(elems, selector, this);
      } else {
        return this._make(elems);
      }
    };
    exports.children = function(selector) {
      var elems = _.reduce(this, function(memo, elem) {
        return memo.concat(_.filter(elem.children, isTag));
      }, []);
      if (selector === void 0)
        return this._make(elems);
      return exports.filter.call(elems, selector, this);
    };
    exports.contents = function() {
      return this._make(_.reduce(this, function(all, elem) {
        all.push.apply(all, elem.children);
        return all;
      }, []));
    };
    exports.each = function(fn) {
      var i = 0, len = this.length;
      while (i < len && fn.call(this[i], i, this[i]) !== false)
        ++i;
      return this;
    };
    exports.map = function(fn) {
      return this._make(_.reduce(this, function(memo, el, i) {
        var val = fn.call(el, i, el);
        return val == null ? memo : memo.concat(val);
      }, []));
    };
    var makeFilterMethod = function(filterFn) {
      return function(match, container) {
        var testFn;
        container = container || this;
        if (typeof match === "string") {
          testFn = select.compile(match, container.options);
        } else if (typeof match === "function") {
          testFn = function(el, i) {
            return match.call(el, i, el);
          };
        } else if (match.cheerio) {
          testFn = match.is.bind(match);
        } else {
          testFn = function(el) {
            return match === el;
          };
        }
        return container._make(filterFn(this, testFn));
      };
    };
    exports.filter = makeFilterMethod(_.filter);
    exports.not = makeFilterMethod(_.reject);
    exports.has = function(selectorOrHaystack) {
      var that = this;
      return exports.filter.call(this, function() {
        return that._make(this).find(selectorOrHaystack).length > 0;
      });
    };
    exports.first = function() {
      return this.length > 1 ? this._make(this[0]) : this;
    };
    exports.last = function() {
      return this.length > 1 ? this._make(this[this.length - 1]) : this;
    };
    exports.eq = function(i) {
      i = +i;
      if (i === 0 && this.length <= 1)
        return this;
      if (i < 0)
        i = this.length + i;
      return this[i] ? this._make(this[i]) : this._make([]);
    };
    exports.get = function(i) {
      if (i == null) {
        return Array.prototype.slice.call(this);
      } else {
        return this[i < 0 ? this.length + i : i];
      }
    };
    exports.index = function(selectorOrNeedle) {
      var $haystack, needle;
      if (arguments.length === 0) {
        $haystack = this.parent().children();
        needle = this[0];
      } else if (typeof selectorOrNeedle === "string") {
        $haystack = this._make(selectorOrNeedle);
        needle = this[0];
      } else {
        $haystack = this;
        needle = selectorOrNeedle.cheerio ? selectorOrNeedle[0] : selectorOrNeedle;
      }
      return $haystack.get().indexOf(needle);
    };
    exports.slice = function() {
      return this._make([].slice.apply(this, arguments));
    };
    function traverseParents(self2, elem, selector, limit) {
      var elems = [];
      while (elem && elems.length < limit) {
        if (!selector || exports.filter.call([elem], selector, self2).length) {
          elems.push(elem);
        }
        elem = elem.parent;
      }
      return elems;
    }
    exports.end = function() {
      return this.prevObject || this._make([]);
    };
    exports.add = function(other, context) {
      var selection = this._make(other, context);
      var contents = uniqueSort(selection.get().concat(this.get()));
      for (var i = 0; i < contents.length; ++i) {
        selection[i] = contents[i];
      }
      selection.length = contents.length;
      return selection;
    };
    exports.addBack = function(selector) {
      return this.add(arguments.length ? this.prevObject.filter(selector) : this.prevObject);
    };
  }
});

// ../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js
var require_lodash10 = __commonJS({
  "../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = flatten;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/manipulation.js
var require_manipulation3 = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/manipulation.js"(exports) {
    var parse = require_parse();
    var $ = require_static();
    var updateDOM = parse.update;
    var evaluate = parse.evaluate;
    var utils = require_utils();
    var domEach = utils.domEach;
    var cloneDom = utils.cloneDom;
    var isHtml = utils.isHtml;
    var slice = Array.prototype.slice;
    var _ = {
      flatten: require_lodash10(),
      bind: require_lodash2(),
      forEach: require_lodash3()
    };
    exports._makeDomArray = function makeDomArray(elem, clone) {
      if (elem == null) {
        return [];
      } else if (elem.cheerio) {
        return clone ? cloneDom(elem.get(), elem.options) : elem.get();
      } else if (Array.isArray(elem)) {
        return _.flatten(elem.map(function(el) {
          return this._makeDomArray(el, clone);
        }, this));
      } else if (typeof elem === "string") {
        return evaluate(elem, this.options);
      } else {
        return clone ? cloneDom([elem]) : [elem];
      }
    };
    var _insert = function(concatenator) {
      return function() {
        var elems = slice.call(arguments), lastIdx = this.length - 1;
        return domEach(this, function(i, el) {
          var dom, domSrc;
          if (typeof elems[0] === "function") {
            domSrc = elems[0].call(el, i, $.html(el.children));
          } else {
            domSrc = elems;
          }
          dom = this._makeDomArray(domSrc, i < lastIdx);
          concatenator(dom, el.children, el);
        });
      };
    };
    var uniqueSplice = function(array, spliceIdx, spliceCount, newElems, parent) {
      var spliceArgs = [spliceIdx, spliceCount].concat(newElems), prev = array[spliceIdx - 1] || null, next = array[spliceIdx] || null;
      var idx, len, prevIdx, node, oldParent;
      for (idx = 0, len = newElems.length; idx < len; ++idx) {
        node = newElems[idx];
        oldParent = node.parent || node.root;
        prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);
        if (oldParent && prevIdx > -1) {
          oldParent.children.splice(prevIdx, 1);
          if (parent === oldParent && spliceIdx > prevIdx) {
            spliceArgs[0]--;
          }
        }
        node.root = null;
        node.parent = parent;
        if (node.prev) {
          node.prev.next = node.next || null;
        }
        if (node.next) {
          node.next.prev = node.prev || null;
        }
        node.prev = newElems[idx - 1] || prev;
        node.next = newElems[idx + 1] || next;
      }
      if (prev) {
        prev.next = newElems[0];
      }
      if (next) {
        next.prev = newElems[newElems.length - 1];
      }
      return array.splice.apply(array, spliceArgs);
    };
    exports.appendTo = function(target) {
      if (!target.cheerio) {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
      }
      target.append(this);
      return this;
    };
    exports.prependTo = function(target) {
      if (!target.cheerio) {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
      }
      target.prepend(this);
      return this;
    };
    exports.append = _insert(function(dom, children, parent) {
      uniqueSplice(children, children.length, 0, dom, parent);
    });
    exports.prepend = _insert(function(dom, children, parent) {
      uniqueSplice(children, 0, 0, dom, parent);
    });
    exports.wrap = function(wrapper) {
      var wrapperFn = typeof wrapper === "function" && wrapper, lastIdx = this.length - 1;
      _.forEach(this, _.bind(function(el, i) {
        var parent = el.parent || el.root, siblings = parent.children, dom, index;
        if (!parent) {
          return;
        }
        if (wrapperFn) {
          wrapper = wrapperFn.call(el, i);
        }
        if (typeof wrapper === "string" && !isHtml(wrapper)) {
          wrapper = this.parents().last().find(wrapper).clone();
        }
        dom = this._makeDomArray(wrapper, i < lastIdx).slice(0, 1);
        index = siblings.indexOf(el);
        updateDOM([el], dom[0]);
        uniqueSplice(siblings, index, 0, dom, parent);
      }, this));
      return this;
    };
    exports.after = function() {
      var elems = slice.call(arguments), lastIdx = this.length - 1;
      domEach(this, function(i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, index = siblings.indexOf(el), domSrc, dom;
        if (index < 0)
          return;
        if (typeof elems[0] === "function") {
          domSrc = elems[0].call(el, i, $.html(el.children));
        } else {
          domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice(siblings, index + 1, 0, dom, parent);
      });
      return this;
    };
    exports.insertAfter = function(target) {
      var clones = [], self2 = this;
      if (typeof target === "string") {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
      }
      target = this._makeDomArray(target);
      self2.remove();
      domEach(target, function(i, el) {
        var clonedSelf = self2._makeDomArray(self2.clone());
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
          return;
        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
        clones.push(clonedSelf);
      });
      return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };
    exports.before = function() {
      var elems = slice.call(arguments), lastIdx = this.length - 1;
      domEach(this, function(i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, index = siblings.indexOf(el), domSrc, dom;
        if (index < 0)
          return;
        if (typeof elems[0] === "function") {
          domSrc = elems[0].call(el, i, $.html(el.children));
        } else {
          domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice(siblings, index, 0, dom, parent);
      });
      return this;
    };
    exports.insertBefore = function(target) {
      var clones = [], self2 = this;
      if (typeof target === "string") {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
      }
      target = this._makeDomArray(target);
      self2.remove();
      domEach(target, function(i, el) {
        var clonedSelf = self2._makeDomArray(self2.clone());
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
          return;
        uniqueSplice(siblings, index, 0, clonedSelf, parent);
        clones.push(clonedSelf);
      });
      return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };
    exports.remove = function(selector) {
      var elems = this;
      if (selector)
        elems = elems.filter(selector);
      domEach(elems, function(i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
          return;
        siblings.splice(index, 1);
        if (el.prev) {
          el.prev.next = el.next;
        }
        if (el.next) {
          el.next.prev = el.prev;
        }
        el.prev = el.next = el.parent = el.root = null;
      });
      return this;
    };
    exports.replaceWith = function(content) {
      var self2 = this;
      domEach(this, function(i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
          return;
        }
        var siblings = parent.children, dom = self2._makeDomArray(typeof content === "function" ? content.call(el, i, el) : content), index;
        updateDOM(dom, null);
        index = siblings.indexOf(el);
        uniqueSplice(siblings, index, 1, dom, parent);
        el.parent = el.prev = el.next = el.root = null;
      });
      return this;
    };
    exports.empty = function() {
      domEach(this, function(i, el) {
        _.forEach(el.children, function(el2) {
          el2.next = el2.prev = el2.parent = null;
        });
        el.children.length = 0;
      });
      return this;
    };
    exports.html = function(str) {
      if (str === void 0) {
        if (!this[0] || !this[0].children)
          return null;
        return $.html(this[0].children, this.options);
      }
      var opts = this.options;
      domEach(this, function(i, el) {
        _.forEach(el.children, function(el2) {
          el2.next = el2.prev = el2.parent = null;
        });
        var content = str.cheerio ? str.clone().get() : evaluate("" + str, opts);
        updateDOM(content, el);
      });
      return this;
    };
    exports.toString = function() {
      return $.html(this, this.options);
    };
    exports.text = function(str) {
      if (str === void 0) {
        return $.text(this);
      } else if (typeof str === "function") {
        return domEach(this, function(i, el) {
          var $el = [el];
          return exports.text.call($el, str.call(el, i, $.text($el)));
        });
      }
      domEach(this, function(i, el) {
        _.forEach(el.children, function(el2) {
          el2.next = el2.prev = el2.parent = null;
        });
        var elem = {
          data: "" + str,
          type: "text",
          parent: el,
          prev: null,
          next: null,
          children: []
        };
        updateDOM(elem, el);
      });
      return this;
    };
    exports.clone = function() {
      return this._make(cloneDom(this.get(), this.options));
    };
  }
});

// ../../node_modules/.pnpm/lodash.pick@4.4.0/node_modules/lodash.pick/index.js
var require_lodash11 = __commonJS({
  "../../node_modules/.pnpm/lodash.pick@4.4.0/node_modules/lodash.pick/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var pick = baseRest(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    module2.exports = pick;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/css.js
var require_css2 = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/css.js"(exports) {
    var domEach = require_utils().domEach;
    var _ = {
      pick: require_lodash11()
    };
    var toString = Object.prototype.toString;
    exports.css = function(prop, val) {
      if (arguments.length === 2 || toString.call(prop) === "[object Object]") {
        return domEach(this, function(idx, el) {
          setCss(el, prop, val, idx);
        });
      } else {
        return getCss(this[0], prop);
      }
    };
    function setCss(el, prop, val, idx) {
      if (typeof prop == "string") {
        var styles = getCss(el);
        if (typeof val === "function") {
          val = val.call(el, idx, styles[prop]);
        }
        if (val === "") {
          delete styles[prop];
        } else if (val != null) {
          styles[prop] = val;
        }
        el.attribs.style = stringify(styles);
      } else if (typeof prop == "object") {
        Object.keys(prop).forEach(function(k) {
          setCss(el, k, prop[k]);
        });
      }
    }
    function getCss(el, prop) {
      var styles = parse(el.attribs.style);
      if (typeof prop === "string") {
        return styles[prop];
      } else if (Array.isArray(prop)) {
        return _.pick(styles, prop);
      } else {
        return styles;
      }
    }
    function stringify(obj) {
      return Object.keys(obj || {}).reduce(function(str, prop) {
        return str += (str ? " " : "") + prop + ": " + obj[prop] + ";";
      }, "");
    }
    function parse(styles) {
      styles = (styles || "").trim();
      if (!styles)
        return {};
      return styles.split(";").reduce(function(obj, str) {
        var n = str.indexOf(":");
        if (n < 1 || n === str.length - 1)
          return obj;
        obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
        return obj;
      }, {});
    }
  }
});

// ../../node_modules/.pnpm/lodash.map@4.6.0/node_modules/lodash.map/index.js
var require_lodash12 = __commonJS({
  "../../node_modules/.pnpm/lodash.map@4.6.0/node_modules/lodash.map/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = map;
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/forms.js
var require_forms = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/api/forms.js"(exports) {
    var submittableSelector = "input,select,textarea,keygen";
    var r20 = /%20/g;
    var rCRLF = /\r?\n/g;
    var _ = {
      map: require_lodash12()
    };
    exports.serialize = function() {
      var arr = this.serializeArray();
      var retArr = _.map(arr, function(data) {
        return encodeURIComponent(data.name) + "=" + encodeURIComponent(data.value);
      });
      return retArr.join("&").replace(r20, "+");
    };
    exports.serializeArray = function() {
      var Cheerio = this.constructor;
      return this.map(function() {
        var elem = this;
        var $elem = Cheerio(elem);
        if (elem.name === "form") {
          return $elem.find(submittableSelector).toArray();
        } else {
          return $elem.filter(submittableSelector).toArray();
        }
      }).filter('[name!=""]:not(:disabled):not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))').map(function(i, elem) {
        var $elem = Cheerio(elem);
        var name = $elem.attr("name");
        var val = $elem.val();
        if (val == null) {
          return null;
        } else {
          if (Array.isArray(val)) {
            return _.map(val, function(val2) {
              return { name, value: val2.replace(rCRLF, "\r\n") };
            });
          } else {
            return { name, value: val.replace(rCRLF, "\r\n") };
          }
        }
      }).get();
    };
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/cheerio.js
var require_cheerio = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/lib/cheerio.js"(exports, module2) {
    var parse = require_parse();
    var isHtml = require_utils().isHtml;
    var _ = {
      extend: require_lodash(),
      bind: require_lodash2(),
      forEach: require_lodash3(),
      defaults: require_lodash4()
    };
    var api = [
      require_attributes2(),
      require_traversing(),
      require_manipulation3(),
      require_css2(),
      require_forms()
    ];
    var Cheerio = module2.exports = function(selector, context, root, options) {
      if (!(this instanceof Cheerio))
        return new Cheerio(selector, context, root, options);
      this.options = _.defaults(options || {}, this.options);
      if (!selector)
        return this;
      if (root) {
        if (typeof root === "string")
          root = parse(root, this.options);
        this._root = Cheerio.call(this, root);
      }
      if (selector.cheerio)
        return selector;
      if (isNode(selector))
        selector = [selector];
      if (Array.isArray(selector)) {
        _.forEach(selector, _.bind(function(elem, idx) {
          this[idx] = elem;
        }, this));
        this.length = selector.length;
        return this;
      }
      if (typeof selector === "string" && isHtml(selector)) {
        return Cheerio.call(this, parse(selector, this.options).children);
      }
      if (!context) {
        context = this._root;
      } else if (typeof context === "string") {
        if (isHtml(context)) {
          context = parse(context, this.options);
          context = Cheerio.call(this, context);
        } else {
          selector = [context, selector].join(" ");
          context = this._root;
        }
      } else if (!context.cheerio) {
        context = Cheerio.call(this, context);
      }
      if (!context)
        return this;
      return context.find(selector);
    };
    _.extend(Cheerio, require_static());
    Cheerio.prototype.cheerio = "[cheerio object]";
    Cheerio.prototype.options = {
      withDomLvl1: true,
      normalizeWhitespace: false,
      xmlMode: false,
      decodeEntities: true
    };
    Cheerio.prototype.length = 0;
    Cheerio.prototype.splice = Array.prototype.splice;
    Cheerio.prototype._make = function(dom, context) {
      var cheerio = new this.constructor(dom, context, this._root, this.options);
      cheerio.prevObject = this;
      return cheerio;
    };
    Cheerio.prototype.toArray = function() {
      return this.get();
    };
    api.forEach(function(mod) {
      _.extend(Cheerio.prototype, mod);
    });
    var isNode = function(obj) {
      return obj.name || obj.type === "text" || obj.type === "comment";
    };
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/package.json"(exports, module2) {
    module2.exports = {
      name: "cheerio",
      version: "0.22.0",
      description: "Tiny, fast, and elegant implementation of core jQuery designed specifically for the server",
      author: "Matt Mueller <mattmuelle@gmail.com> (mat.io)",
      license: "MIT",
      keywords: [
        "htmlparser",
        "jquery",
        "selector",
        "scraper",
        "parser",
        "html"
      ],
      repository: {
        type: "git",
        url: "git://github.com/cheeriojs/cheerio.git"
      },
      main: "./index.js",
      files: [
        "index.js",
        "lib"
      ],
      engines: {
        node: ">= 0.6"
      },
      dependencies: {
        "css-select": "~1.2.0",
        "dom-serializer": "~0.1.0",
        entities: "~1.1.1",
        htmlparser2: "^3.9.1",
        "lodash.assignin": "^4.0.9",
        "lodash.bind": "^4.1.4",
        "lodash.defaults": "^4.0.1",
        "lodash.filter": "^4.4.0",
        "lodash.flatten": "^4.2.0",
        "lodash.foreach": "^4.3.0",
        "lodash.map": "^4.4.0",
        "lodash.merge": "^4.4.0",
        "lodash.pick": "^4.2.1",
        "lodash.reduce": "^4.4.0",
        "lodash.reject": "^4.4.0",
        "lodash.some": "^4.4.0"
      },
      devDependencies: {
        benchmark: "^2.1.0",
        coveralls: "^2.11.9",
        "expect.js": "~0.3.1",
        istanbul: "^0.4.3",
        jsdom: "^9.2.1",
        jquery: "^3.0.0",
        jshint: "^2.9.2",
        mocha: "^2.5.3",
        xyz: "~0.5.0"
      },
      scripts: {
        test: "make test"
      }
    };
  }
});

// ../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/index.js
var require_cheerio2 = __commonJS({
  "../../node_modules/.pnpm/cheerio@0.22.0/node_modules/cheerio/index.js"(exports, module2) {
    exports = module2.exports = require_cheerio();
    exports.version = require_package().version;
  }
});

// ../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/debug.js"(exports, module2) {
    exports = module2.exports = debug;
    function debug(label) {
      return _debug.bind(null, label);
    }
    function _debug(label) {
      var args = [].slice.call(arguments, 1);
      args.unshift("[" + label + "]");
      process.stderr.write(args.join(" ") + "\n");
    }
  }
});

// ../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/lexer.js"(exports, module2) {
    var DEBUG = false;
    var TIMER = false;
    var debug = require_debug()("lex");
    exports = module2.exports = lex;
    function lex(css) {
      var start;
      var buffer = "";
      var ch;
      var column = 0;
      var cursor = -1;
      var depth = 0;
      var line = 1;
      var state = "before-selector";
      var stack = [state];
      var token = {};
      var tokens = [];
      var atRules = [
        "media",
        "keyframes",
        { name: "-webkit-keyframes", type: "keyframes", prefix: "-webkit-" },
        { name: "-moz-keyframes", type: "keyframes", prefix: "-moz-" },
        { name: "-ms-keyframes", type: "keyframes", prefix: "-ms-" },
        { name: "-o-keyframes", type: "keyframes", prefix: "-o-" },
        "font-face",
        { name: "import", state: "before-at-value" },
        { name: "charset", state: "before-at-value" },
        "supports",
        "viewport",
        { name: "namespace", state: "before-at-value" },
        "document",
        { name: "-moz-document", type: "document", prefix: "-moz-" },
        "page"
      ];
      function getCh() {
        skip();
        return css[cursor];
      }
      function getState(index) {
        return index ? stack[stack.length - 1 - index] : state;
      }
      function isNextString(str) {
        var start2 = cursor + 1;
        return str === css.slice(start2, start2 + str.length);
      }
      function find(str) {
        var pos2 = css.slice(cursor).indexOf(str);
        return pos2 > 0 ? pos2 : false;
      }
      function isNextChar(ch2) {
        return ch2 === peek(1);
      }
      function peek(offset) {
        return css[cursor + (offset || 1)];
      }
      function popState() {
        var removed = stack.pop();
        state = stack[stack.length - 1];
        return removed;
      }
      function pushState(newState) {
        state = newState;
        stack.push(state);
        return stack.length;
      }
      function replaceState(newState) {
        var previousState = state;
        stack[stack.length - 1] = state = newState;
        return previousState;
      }
      function skip(n) {
        if ((n || 1) == 1) {
          if (css[cursor] == "\n") {
            line++;
            column = 1;
          } else {
            column++;
          }
          cursor++;
        } else {
          var skipStr = css.slice(cursor, cursor + n).split("\n");
          if (skipStr.length > 1) {
            line += skipStr.length - 1;
            column = 1;
          }
          column += skipStr[skipStr.length - 1].length;
          cursor = cursor + n;
        }
      }
      function addToken() {
        token.end = {
          line,
          col: column
        };
        DEBUG && debug("addToken:", JSON.stringify(token, null, 2));
        tokens.push(token);
        buffer = "";
        token = {};
      }
      function initializeToken(type) {
        token = {
          type,
          start: {
            line,
            col: column
          }
        };
      }
      TIMER && (start = Date.now());
      while (ch = getCh()) {
        DEBUG && debug(ch, getState());
        switch (ch) {
          case " ":
            switch (getState()) {
              case "selector":
              case "value":
              case "value-paren":
              case "at-group":
              case "at-value":
              case "comment":
              case "double-string":
              case "single-string":
                buffer += ch;
                break;
            }
            break;
          case "\n":
          case "	":
          case "\r":
          case "\f":
            switch (getState()) {
              case "value":
              case "value-paren":
              case "at-group":
              case "comment":
              case "single-string":
              case "double-string":
              case "selector":
                buffer += ch;
                break;
              case "at-value":
                if (ch === "\n") {
                  token.value = buffer.trim();
                  addToken();
                  popState();
                }
                break;
            }
            break;
          case ":":
            switch (getState()) {
              case "name":
                token.name = buffer.trim();
                buffer = "";
                replaceState("before-value");
                break;
              case "before-selector":
                buffer += ch;
                initializeToken("selector");
                pushState("selector");
                break;
              case "before-value":
                replaceState("value");
                buffer += ch;
                break;
              default:
                buffer += ch;
                break;
            }
            break;
          case ";":
            switch (getState()) {
              case "name":
              case "before-value":
              case "value":
                if (buffer.trim().length > 0) {
                  token.value = buffer.trim(), addToken();
                }
                replaceState("before-name");
                break;
              case "value-paren":
                buffer += ch;
                break;
              case "at-value":
                token.value = buffer.trim();
                addToken();
                popState();
                break;
              case "before-name":
                break;
              default:
                buffer += ch;
                break;
            }
            break;
          case "{":
            switch (getState()) {
              case "selector":
                if (peek(-1) === "\\") {
                  buffer += ch;
                  break;
                }
                token.text = buffer.trim();
                addToken();
                replaceState("before-name");
                depth = depth + 1;
                break;
              case "at-group":
                token.name = buffer.trim();
                switch (token.type) {
                  case "font-face":
                  case "viewport":
                  case "page":
                    pushState("before-name");
                    break;
                  default:
                    pushState("before-selector");
                }
                addToken();
                depth = depth + 1;
                break;
              case "name":
              case "at-rule":
                token.name = buffer.trim();
                addToken();
                pushState("before-name");
                depth = depth + 1;
                break;
              case "comment":
              case "double-string":
              case "single-string":
                buffer += ch;
                break;
              case "before-value":
                replaceState("value");
                buffer += ch;
                break;
            }
            break;
          case "}":
            switch (getState()) {
              case "before-name":
              case "name":
              case "before-value":
              case "value":
                if (buffer) {
                  token.value = buffer.trim();
                }
                if (token.name && token.value) {
                  addToken();
                }
                initializeToken("end");
                addToken();
                popState();
                if (getState() === "at-group") {
                  initializeToken("at-group-end");
                  addToken();
                  popState();
                }
                if (depth > 0) {
                  depth = depth - 1;
                }
                break;
              case "at-group":
              case "before-selector":
              case "selector":
                if (peek(-1) === "\\") {
                  buffer += ch;
                  break;
                }
                if (depth > 0) {
                  if (getState(1) === "at-group") {
                    initializeToken("at-group-end");
                    addToken();
                  }
                }
                if (depth > 1) {
                  popState();
                }
                if (depth > 0) {
                  depth = depth - 1;
                }
                break;
              case "double-string":
              case "single-string":
              case "comment":
                buffer += ch;
                break;
            }
            break;
          case '"':
          case "'":
            switch (getState()) {
              case "double-string":
                if (ch === '"' && peek(-1) !== "\\") {
                  popState();
                }
                break;
              case "single-string":
                if (ch === "'" && peek(-1) !== "\\") {
                  popState();
                }
                break;
              case "before-at-value":
                replaceState("at-value");
                pushState(ch === '"' ? "double-string" : "single-string");
                break;
              case "before-value":
                replaceState("value");
                pushState(ch === '"' ? "double-string" : "single-string");
                break;
              case "comment":
                break;
              default:
                if (peek(-1) !== "\\") {
                  pushState(ch === '"' ? "double-string" : "single-string");
                }
            }
            buffer += ch;
            break;
          case "/":
            switch (getState()) {
              case "comment":
              case "double-string":
              case "single-string":
                buffer += ch;
                break;
              case "before-value":
              case "selector":
              case "name":
              case "value":
                if (isNextChar("*")) {
                  var pos = find("*/");
                  if (pos) {
                    skip(pos + 1);
                  }
                } else {
                  if (getState() == "before-value")
                    replaceState("value");
                  buffer += ch;
                }
                break;
              default:
                if (isNextChar("*")) {
                  initializeToken("comment");
                  pushState("comment");
                  skip();
                } else {
                  buffer += ch;
                }
                break;
            }
            break;
          case "*":
            switch (getState()) {
              case "comment":
                if (isNextChar("/")) {
                  token.text = buffer;
                  skip();
                  addToken();
                  popState();
                } else {
                  buffer += ch;
                }
                break;
              case "before-selector":
                buffer += ch;
                initializeToken("selector");
                pushState("selector");
                break;
              case "before-value":
                replaceState("value");
                buffer += ch;
                break;
              default:
                buffer += ch;
            }
            break;
          case "@":
            switch (getState()) {
              case "comment":
              case "double-string":
              case "single-string":
                buffer += ch;
                break;
              case "before-value":
                replaceState("value");
                buffer += ch;
                break;
              default:
                var tokenized = false;
                var name;
                var rule;
                for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
                  rule = atRules[j];
                  name = rule.name || rule;
                  if (!isNextString(name)) {
                    continue;
                  }
                  tokenized = true;
                  initializeToken(name);
                  pushState(rule.state || "at-group");
                  skip(name.length);
                  if (rule.prefix) {
                    token.prefix = rule.prefix;
                  }
                  if (rule.type) {
                    token.type = rule.type;
                  }
                }
                if (!tokenized) {
                  buffer += ch;
                }
                break;
            }
            break;
          case "(":
            switch (getState()) {
              case "value":
                pushState("value-paren");
                break;
              case "before-value":
                replaceState("value");
                break;
            }
            buffer += ch;
            break;
          case ")":
            switch (getState()) {
              case "value-paren":
                popState();
                break;
              case "before-value":
                replaceState("value");
                break;
            }
            buffer += ch;
            break;
          default:
            switch (getState()) {
              case "before-selector":
                initializeToken("selector");
                pushState("selector");
                break;
              case "before-name":
                initializeToken("property");
                replaceState("name");
                break;
              case "before-value":
                replaceState("value");
                break;
              case "before-at-value":
                replaceState("at-value");
                break;
            }
            buffer += ch;
            break;
        }
      }
      TIMER && debug("ran in", Date.now() - start + "ms");
      return tokens;
    }
  }
});

// ../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/parser.js"(exports, module2) {
    var DEBUG = false;
    var TIMER = false;
    var debug = require_debug()("parse");
    var lex = require_lexer();
    exports = module2.exports = parse;
    var _comments;
    var _depth;
    var _position;
    var _tokens;
    function parse(css, options) {
      var start;
      options || (options = {});
      _comments = !!options.comments;
      _position = !!options.position;
      _depth = 0;
      _tokens = Array.isArray(css) ? css.slice() : lex(css);
      var rule;
      var rules = [];
      var token;
      TIMER && (start = Date.now());
      while (token = next()) {
        rule = parseToken(token);
        rule && rules.push(rule);
      }
      TIMER && debug("ran in", Date.now() - start + "ms");
      return {
        type: "stylesheet",
        stylesheet: {
          rules
        }
      };
    }
    function astNode(token, override) {
      override || (override = {});
      var key;
      var keys = ["type", "name", "value"];
      var node = {};
      for (var i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (token[key]) {
          node[key] = override[key] || token[key];
        }
      }
      keys = Object.keys(override);
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (!node[key]) {
          node[key] = override[key];
        }
      }
      if (_position) {
        node.position = {
          start: token.start,
          end: token.end
        };
      }
      DEBUG && debug("astNode:", JSON.stringify(node, null, 2));
      return node;
    }
    function next() {
      var token = _tokens.shift();
      DEBUG && debug("next:", JSON.stringify(token, null, 2));
      return token;
    }
    function parseAtGroup(token) {
      _depth = _depth + 1;
      var overrides = {};
      switch (token.type) {
        case "font-face":
        case "viewport":
          overrides.declarations = parseDeclarations();
          break;
        case "page":
          overrides.prefix = token.prefix;
          overrides.declarations = parseDeclarations();
          break;
        default:
          overrides.prefix = token.prefix;
          overrides.rules = parseRules();
      }
      return astNode(token, overrides);
    }
    function parseAtImport(token) {
      return astNode(token);
    }
    function parseCharset(token) {
      return astNode(token);
    }
    function parseComment(token) {
      return astNode(token, { text: token.text });
    }
    function parseNamespace(token) {
      return astNode(token);
    }
    function parseProperty(token) {
      return astNode(token);
    }
    function parseSelector(token) {
      function trim(str) {
        return str.trim();
      }
      return astNode(token, {
        type: "rule",
        selectors: token.text.split(",").map(trim),
        declarations: parseDeclarations(token)
      });
    }
    function parseToken(token) {
      switch (token.type) {
        case "property":
          return parseProperty(token);
        case "selector":
          return parseSelector(token);
        case "at-group-end":
          _depth = _depth - 1;
          return;
        case "media":
        case "keyframes":
          return parseAtGroup(token);
        case "comment":
          if (_comments) {
            return parseComment(token);
          }
          break;
        case "charset":
          return parseCharset(token);
        case "import":
          return parseAtImport(token);
        case "namespace":
          return parseNamespace(token);
        case "font-face":
        case "supports":
        case "viewport":
        case "document":
        case "page":
          return parseAtGroup(token);
      }
      DEBUG && debug("parseToken: unexpected token:", JSON.stringify(token));
    }
    function parseTokensWhile(conditionFn) {
      var node;
      var nodes = [];
      var token;
      while ((token = next()) && (conditionFn && conditionFn(token))) {
        node = parseToken(token);
        node && nodes.push(node);
      }
      if (token && token.type !== "end") {
        _tokens.unshift(token);
      }
      return nodes;
    }
    function parseDeclarations() {
      return parseTokensWhile(function(token) {
        return token.type === "property" || token.type === "comment";
      });
    }
    function parseRules() {
      return parseTokensWhile(function() {
        return _depth;
      });
    }
  }
});

// ../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/lib/stringify.js"(exports, module2) {
    var DEBUG = false;
    var TIMER = false;
    var debug = require_debug()("stringify");
    var _comments;
    var _compress;
    var _indentation;
    var _level;
    var _n;
    var _s;
    exports = module2.exports = stringify;
    function stringify(ast, options) {
      var start;
      options || (options = {});
      _indentation = options.indentation || "";
      _compress = !!options.compress;
      _comments = !!options.comments;
      _level = 1;
      if (_compress) {
        _n = _s = "";
      } else {
        _n = "\n";
        _s = " ";
      }
      TIMER && (start = Date.now());
      var css = reduce(ast.stylesheet.rules, stringifyNode).join("\n").trim();
      TIMER && debug("ran in", Date.now() - start + "ms");
      return css;
    }
    function indent(level) {
      if (level) {
        _level += level;
        return;
      }
      if (_compress) {
        return "";
      }
      return Array(_level).join(_indentation || "");
    }
    function stringifyAtRule(node) {
      return "@" + node.type + " " + node.value + ";" + _n;
    }
    function stringifyAtGroup(node) {
      var label = "";
      var prefix = node.prefix || "";
      if (node.name) {
        label = " " + node.name;
      }
      var chomp = node.type !== "page";
      return "@" + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n;
    }
    function stringifyComment(node) {
      if (!_comments) {
        return "";
      }
      return "/*" + (node.text || "") + "*/" + _n;
    }
    function stringifyRule(node) {
      var label;
      if (node.selectors) {
        label = node.selectors.join("," + _n);
      } else {
        label = "@" + node.type;
        label += node.name ? " " + node.name : "";
      }
      return indent() + label + _s + stringifyBlock(node) + _n;
    }
    function reduce(items, fn) {
      return items.reduce(function(results, item) {
        var result = item.type === "comment" ? stringifyComment(item) : fn(item);
        result && results.push(result);
        return results;
      }, []);
    }
    function stringifyBlock(node, chomp) {
      var children = node.declarations;
      var fn = stringifyDeclaration;
      if (node.rules) {
        children = node.rules;
        fn = stringifyRule;
      }
      children = stringifyChildren(children, fn);
      children && (children = _n + children + (chomp ? "" : _n));
      return "{" + children + indent() + "}";
    }
    function stringifyChildren(children, fn) {
      if (!children) {
        return "";
      }
      indent(1);
      var results = reduce(children, fn);
      indent(-1);
      if (!results.length) {
        return "";
      }
      return results.join(_n);
    }
    function stringifyDeclaration(node) {
      if (node.type === "property") {
        return stringifyProperty(node);
      }
      DEBUG && debug("stringifyDeclaration: unexpected node:", JSON.stringify(node));
    }
    function stringifyNode(node) {
      switch (node.type) {
        case "rule":
          return stringifyRule(node);
        case "media":
        case "keyframes":
          return stringifyAtGroup(node);
        case "comment":
          return stringifyComment(node);
        case "import":
        case "charset":
        case "namespace":
          return stringifyAtRule(node);
        case "font-face":
        case "supports":
        case "viewport":
        case "document":
        case "page":
          return stringifyAtGroup(node);
      }
      DEBUG && debug("stringifyNode: unexpected node: " + JSON.stringify(node));
    }
    function stringifyProperty(node) {
      var name = node.name ? node.name + ":" + _s : "";
      return indent() + name + node.value + ";";
    }
  }
});

// ../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/index.js
var require_mensch = __commonJS({
  "../../node_modules/.pnpm/mensch@0.3.4/node_modules/mensch/index.js"(exports, module2) {
    module2.exports = {
      lex: require_lexer(),
      parse: require_parser(),
      stringify: require_stringify3()
    };
  }
});

// ../../node_modules/.pnpm/slick@1.12.2/node_modules/slick/parser.js
var require_parser2 = __commonJS({
  "../../node_modules/.pnpm/slick@1.12.2/node_modules/slick/parser.js"(exports, module2) {
    "use strict";
    var escapeRe = /([-.*+?^${}()|[\]\/\\])/g;
    var unescapeRe = /\\/g;
    var escape = function(string) {
      return (string + "").replace(escapeRe, "\\$1");
    };
    var unescape = function(string) {
      return (string + "").replace(unescapeRe, "");
    };
    var slickRe = RegExp(`^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:(["']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:(["'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)`.replace(/<combinator>/, "[" + escape(">+~`!@$%^&={}\\;</") + "]").replace(/<unicode>/g, "(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g, "(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])"));
    var Part = function Part2(combinator) {
      this.combinator = combinator || " ";
      this.tag = "*";
    };
    Part.prototype.toString = function() {
      if (!this.raw) {
        var xpr = "", k, part;
        xpr += this.tag || "*";
        if (this.id)
          xpr += "#" + this.id;
        if (this.classes)
          xpr += "." + this.classList.join(".");
        if (this.attributes)
          for (k = 0; part = this.attributes[k++]; ) {
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : "") + "]";
          }
        if (this.pseudos)
          for (k = 0; part = this.pseudos[k++]; ) {
            xpr += ":" + part.name;
            if (part.value)
              xpr += "(" + part.value + ")";
          }
        this.raw = xpr;
      }
      return this.raw;
    };
    var Expression = function Expression2() {
      this.length = 0;
    };
    Expression.prototype.toString = function() {
      if (!this.raw) {
        var xpr = "";
        for (var j = 0, bit; bit = this[j++]; ) {
          if (j !== 1)
            xpr += " ";
          if (bit.combinator !== " ")
            xpr += bit.combinator + " ";
          xpr += bit;
        }
        this.raw = xpr;
      }
      return this.raw;
    };
    var replacer = function(rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {
      var expression, current;
      if (separator || !this.length) {
        expression = this[this.length++] = new Expression();
        if (separator)
          return "";
      }
      if (!expression)
        expression = this[this.length - 1];
      if (combinator || combinatorChildren || !expression.length) {
        current = expression[expression.length++] = new Part(combinator);
      }
      if (!current)
        current = expression[expression.length - 1];
      if (tagName) {
        current.tag = unescape(tagName);
      } else if (id) {
        current.id = unescape(id);
      } else if (className) {
        var unescaped = unescape(className);
        var classes = current.classes || (current.classes = {});
        if (!classes[unescaped]) {
          classes[unescaped] = escape(className);
          var classList = current.classList || (current.classList = []);
          classList.push(unescaped);
          classList.sort();
        }
      } else if (pseudoClass) {
        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
        (current.pseudos || (current.pseudos = [])).push({
          type: pseudoMarker.length == 1 ? "class" : "element",
          name: unescape(pseudoClass),
          escapedName: escape(pseudoClass),
          value: pseudoClassValue ? unescape(pseudoClassValue) : null,
          escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null
        });
      } else if (attributeKey) {
        attributeValue = attributeValue ? escape(attributeValue) : null;
        (current.attributes || (current.attributes = [])).push({
          operator: attributeOperator,
          name: unescape(attributeKey),
          escapedName: escape(attributeKey),
          value: attributeValue ? unescape(attributeValue) : null,
          escapedValue: attributeValue ? escape(attributeValue) : null
        });
      }
      return "";
    };
    var Expressions = function Expressions2(expression) {
      this.length = 0;
      var self2 = this;
      var original = expression, replaced;
      while (expression) {
        replaced = expression.replace(slickRe, function() {
          return replacer.apply(self2, arguments);
        });
        if (replaced === expression)
          throw new Error(original + " is an invalid expression");
        expression = replaced;
      }
    };
    Expressions.prototype.toString = function() {
      if (!this.raw) {
        var expressions = [];
        for (var i = 0, expression; expression = this[i++]; )
          expressions.push(expression);
        this.raw = expressions.join(", ");
      }
      return this.raw;
    };
    var cache = {};
    var parse = function(expression) {
      if (expression == null)
        return null;
      expression = ("" + expression).replace(/^\s+|\s+$/g, "");
      return cache[expression] || (cache[expression] = new Expressions(expression));
    };
    module2.exports = parse;
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/selector.js
var require_selector = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/selector.js"(exports, module2) {
    "use strict";
    var parser = require_parser2();
    module2.exports = exports = Selector;
    function Selector(text, styleAttribute) {
      this.text = text;
      this.spec = void 0;
      this.styleAttribute = styleAttribute || false;
    }
    Selector.prototype.parsed = function() {
      if (!this.tokens) {
        this.tokens = parse(this.text);
      }
      return this.tokens;
    };
    Selector.prototype.specificity = function() {
      var styleAttribute = this.styleAttribute;
      if (!this.spec) {
        this.spec = specificity(this.text, this.parsed());
      }
      return this.spec;
      function specificity(text, parsed) {
        var expressions = parsed || parse(text);
        var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
        var nots = [];
        for (var i = 0; i < expressions.length; i++) {
          var expression = expressions[i];
          var pseudos = expression.pseudos;
          if (expression.id) {
            spec[1]++;
          }
          if (expression.attributes) {
            spec[2] += expression.attributes.length;
          }
          if (expression.classList) {
            spec[2] += expression.classList.length;
          }
          if (expression.tag && expression.tag !== "*") {
            spec[3]++;
          }
          if (pseudos) {
            spec[3] += pseudos.length;
            for (var p = 0; p < pseudos.length; p++) {
              if (pseudos[p].name === "not") {
                nots.push(pseudos[p].value);
                spec[3]--;
              }
            }
          }
        }
        for (var ii = nots.length; ii--; ) {
          var not = specificity(nots[ii]);
          for (var jj = 4; jj--; ) {
            spec[jj] += not[jj];
          }
        }
        return spec;
      }
    };
    function parse(text) {
      try {
        return parser(text)[0];
      } catch (e) {
        return [];
      }
    }
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/property.js
var require_property = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/property.js"(exports, module2) {
    "use strict";
    module2.exports = exports = Property;
    var utils = require_utils2();
    function Property(prop, value, selector, priority, additionalPriority) {
      this.prop = prop;
      this.value = value;
      this.selector = selector;
      this.priority = priority || 0;
      this.additionalPriority = additionalPriority || [];
    }
    Property.prototype.compareFunc = function(property) {
      var a = [];
      a.push.apply(a, this.selector.specificity());
      a.push.apply(a, this.additionalPriority);
      a[0] += this.priority;
      var b = [];
      b.push.apply(b, property.selector.specificity());
      b.push.apply(b, property.additionalPriority);
      b[0] += property.priority;
      return utils.compareFunc(a, b);
    };
    Property.prototype.compare = function(property) {
      var winner = this.compareFunc(property);
      if (winner === 1) {
        return this;
      }
      return property;
    };
    Property.prototype.toString = function() {
      return this.prop + ": " + this.value.replace(/['"]+/g, "") + ";";
    };
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/utils.js"(exports) {
    "use strict";
    var mensch = require_mensch();
    var own = {}.hasOwnProperty;
    var Selector = require_selector();
    var Property = require_property();
    exports.Selector = Selector;
    exports.Property = Property;
    exports.extract = function extract(selectorText) {
      var attr = 0;
      var sels = [];
      var sel = "";
      for (var i = 0, l = selectorText.length; i < l; i++) {
        var c = selectorText.charAt(i);
        if (attr) {
          if (c === "]" || c === ")") {
            attr--;
          }
          sel += c;
        } else {
          if (c === ",") {
            sels.push(sel);
            sel = "";
          } else {
            if (c === "[" || c === "(") {
              attr++;
            }
            if (sel.length || c !== "," && c !== "\n" && c !== " ") {
              sel += c;
            }
          }
        }
      }
      if (sel.length) {
        sels.push(sel);
      }
      return sels;
    };
    exports.parseCSS = function(css) {
      var parsed = mensch.parse(css, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var ret = [];
      for (var i = 0, l = rules.length; i < l; i++) {
        if (rules[i].type == "rule") {
          var rule = rules[i];
          var selectors = rule.selectors;
          for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
            ret.push([selectors[ii], rule.declarations]);
          }
        }
      }
      return ret;
    };
    exports.getPreservedText = function(css, options, ignoredPseudos) {
      var parsed = mensch.parse(css, { position: true, comments: true });
      var rules = typeof parsed.stylesheet != "undefined" && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
      var preserved = [];
      var lastStart = null;
      for (var i = rules.length - 1; i >= 0; i--) {
        if (options.fontFaces && rules[i].type === "font-face" || options.mediaQueries && rules[i].type === "media" || options.keyFrames && rules[i].type === "keyframes" || options.pseudos && rules[i].selectors && this.matchesPseudo(rules[i].selectors[0], ignoredPseudos)) {
          preserved.unshift(mensch.stringify({ stylesheet: { rules: [rules[i]] } }, { comments: false, indentation: "  " }));
        }
        lastStart = rules[i].position.start;
      }
      if (preserved.length === 0) {
        return false;
      }
      return "\n" + preserved.join("\n") + "\n";
    };
    exports.normalizeLineEndings = function(text) {
      return text.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n");
    };
    exports.matchesPseudo = function(needle, haystack) {
      return haystack.find(function(element) {
        return needle.indexOf(element) > -1;
      });
    };
    exports.compareFunc = function(a, b) {
      var min = Math.min(a.length, b.length);
      for (var i = 0; i < min; i++) {
        if (a[i] === b[i]) {
          continue;
        }
        if (a[i] > b[i]) {
          return 1;
        }
        return -1;
      }
      return a.length - b.length;
    };
    exports.compare = function(a, b) {
      return exports.compareFunc(a, b) == 1 ? a : b;
    };
    exports.extend = function(obj, src) {
      for (var key in src) {
        if (own.call(src, key)) {
          obj[key] = src[key];
        }
      }
      return obj;
    };
    exports.getDefaultOptions = function(options) {
      var result = exports.extend({
        extraCss: "",
        insertPreservedExtraCss: true,
        applyStyleTags: true,
        removeStyleTags: true,
        preserveMediaQueries: true,
        preserveFontFaces: true,
        preserveKeyFrames: true,
        preservePseudos: true,
        applyWidthAttributes: true,
        applyHeightAttributes: true,
        applyAttributesTableElements: true,
        url: ""
      }, options);
      result.webResources = result.webResources || {};
      return result;
    };
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/cheerio.js
var require_cheerio3 = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/cheerio.js"(exports, module2) {
    "use strict";
    var cheerio = require_cheerio2();
    var utils = require_utils2();
    var cheerioLoad = function(html, options, encodeEntities) {
      options = utils.extend({ decodeEntities: false }, options || {});
      html = encodeEntities(html);
      return cheerio.load(html, options);
    };
    var createEntityConverters = function() {
      var codeBlockLookup = [];
      var encodeCodeBlocks = function(html) {
        var blocks = module2.exports.codeBlocks;
        Object.keys(blocks).forEach(function(key) {
          var re = new RegExp(blocks[key].start + "([\\S\\s]*?)" + blocks[key].end, "g");
          html = html.replace(re, function(match, subMatch) {
            codeBlockLookup.push(match);
            return "JUICE_CODE_BLOCK_" + (codeBlockLookup.length - 1) + "_";
          });
        });
        return html;
      };
      var decodeCodeBlocks = function(html) {
        for (var index = 0; index < codeBlockLookup.length; index++) {
          var re = new RegExp("JUICE_CODE_BLOCK_" + index + '_(="")?', "gi");
          html = html.replace(re, function() {
            return codeBlockLookup[index];
          });
        }
        return html;
      };
      return {
        encodeEntities: encodeCodeBlocks,
        decodeEntities: decodeCodeBlocks
      };
    };
    module2.exports = function(html, options, callback, callbackExtraArguments) {
      var entityConverters = createEntityConverters();
      var $ = cheerioLoad(html, options, entityConverters.encodeEntities);
      var args = [$];
      args.push.apply(args, callbackExtraArguments);
      var doc = callback.apply(void 0, args) || $;
      if (options && options.xmlMode) {
        return entityConverters.decodeEntities(doc.xml());
      }
      return entityConverters.decodeEntities(doc.html());
    };
    module2.exports.codeBlocks = {
      EJS: { start: "<%", end: "%>" },
      HBS: { start: "{{", end: "}}" }
    };
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/inline.js
var require_inline = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/lib/inline.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function makeJuiceClient(juiceClient) {
      juiceClient.ignoredPseudos = ["hover", "active", "focus", "visited", "link"];
      juiceClient.widthElements = ["TABLE", "TD", "TH", "IMG"];
      juiceClient.heightElements = ["TABLE", "TD", "TH", "IMG"];
      juiceClient.tableElements = ["TABLE", "TH", "TR", "TD", "CAPTION", "COLGROUP", "COL", "THEAD", "TBODY", "TFOOT"];
      juiceClient.nonVisualElements = ["HEAD", "TITLE", "BASE", "LINK", "STYLE", "META", "SCRIPT", "NOSCRIPT"];
      juiceClient.styleToAttribute = {
        "background-color": "bgcolor",
        "background-image": "background",
        "text-align": "align",
        "vertical-align": "valign"
      };
      juiceClient.excludedProperties = [];
      juiceClient.juiceDocument = juiceDocument;
      juiceClient.inlineDocument = inlineDocument;
      function inlineDocument($, css, options) {
        options = options || {};
        var rules = utils.parseCSS(css);
        var editedElements = [];
        var styleAttributeName = "style";
        if (options.styleAttributeName) {
          styleAttributeName = options.styleAttributeName;
        }
        rules.forEach(handleRule);
        editedElements.forEach(setStyleAttrs);
        if (options.inlinePseudoElements) {
          editedElements.forEach(inlinePseudoElements);
        }
        if (options.applyWidthAttributes) {
          editedElements.forEach(function(el) {
            setDimensionAttrs(el, "width");
          });
        }
        if (options.applyHeightAttributes) {
          editedElements.forEach(function(el) {
            setDimensionAttrs(el, "height");
          });
        }
        if (options.applyAttributesTableElements) {
          editedElements.forEach(setAttributesOnTableElements);
        }
        if (options.insertPreservedExtraCss && options.extraCss) {
          var preservedText = utils.getPreservedText(options.extraCss, {
            mediaQueries: options.preserveMediaQueries,
            fontFaces: options.preserveFontFaces,
            keyFrames: options.preserveKeyFrames
          });
          if (preservedText) {
            var $appendTo = null;
            if (options.insertPreservedExtraCss !== true) {
              $appendTo = $(options.insertPreservedExtraCss);
            } else {
              $appendTo = $("head");
              if (!$appendTo.length) {
                $appendTo = $("body");
              }
              if (!$appendTo.length) {
                $appendTo = $.root();
              }
            }
            $appendTo.first().append("<style>" + preservedText + "</style>");
          }
        }
        function handleRule(rule) {
          var sel = rule[0];
          var style = rule[1];
          var selector = new utils.Selector(sel);
          var parsedSelector = selector.parsed();
          var pseudoElementType = getPseudoElementType(parsedSelector);
          for (var i = 0; i < parsedSelector.length; ++i) {
            var subSel = parsedSelector[i];
            if (subSel.pseudos) {
              for (var j = 0; j < subSel.pseudos.length; ++j) {
                var subSelPseudo = subSel.pseudos[j];
                if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
                  return;
                }
              }
            }
          }
          if (pseudoElementType) {
            var last = parsedSelector[parsedSelector.length - 1];
            var pseudos = last.pseudos;
            last.pseudos = filterElementPseudos(last.pseudos);
            sel = parsedSelector.toString();
            last.pseudos = pseudos;
          }
          var els;
          try {
            els = $(sel);
          } catch (err) {
            return;
          }
          els.each(function() {
            var el = this;
            if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
              return;
            }
            if (pseudoElementType) {
              var pseudoElPropName = "pseudo" + pseudoElementType;
              var pseudoEl = el[pseudoElPropName];
              if (!pseudoEl) {
                pseudoEl = el[pseudoElPropName] = $("<span />").get(0);
                pseudoEl.pseudoElementType = pseudoElementType;
                pseudoEl.pseudoElementParent = el;
                el[pseudoElPropName] = pseudoEl;
              }
              el = pseudoEl;
            }
            if (!el.styleProps) {
              el.styleProps = {};
              if ($(el).attr(styleAttributeName)) {
                var cssText = "* { " + $(el).attr(styleAttributeName) + " } ";
                addProps(utils.parseCSS(cssText)[0][1], new utils.Selector("<style>", true));
              }
              editedElements.push(el);
            }
            function addProps(style2, selector2) {
              for (var i2 = 0, l = style2.length; i2 < l; i2++) {
                if (style2[i2].type == "property") {
                  var name = style2[i2].name;
                  var value = style2[i2].value;
                  var important = style2[i2].value.match(/!important$/) !== null;
                  if (important && !options.preserveImportant)
                    value = value.replace(/\s*!important$/, "");
                  var additionalPriority = [style2[i2].position.start.line, style2[i2].position.start.col];
                  var prop = new utils.Property(name, value, selector2, important ? 2 : 0, additionalPriority);
                  var existing = el.styleProps[name];
                  if (juiceClient.excludedProperties.indexOf(name) < 0) {
                    if (existing && existing.compare(prop) === prop || !existing) {
                      if (existing && existing.selector !== selector2) {
                        delete el.styleProps[name];
                      } else if (existing) {
                        prop.nextProp = existing;
                      }
                      el.styleProps[name] = prop;
                    }
                  }
                }
              }
            }
            addProps(style, selector);
          });
        }
        function setStyleAttrs(el) {
          var l = Object.keys(el.styleProps).length;
          var props = [];
          Object.keys(el.styleProps).forEach(function(key) {
            var np = el.styleProps[key];
            while (typeof np !== "undefined") {
              props.push(np);
              np = np.nextProp;
            }
          });
          props.sort(function(a, b) {
            return a.compareFunc(b);
          });
          var string = props.filter(function(prop) {
            return prop.prop !== "content";
          }).map(function(prop) {
            return prop.prop + ": " + prop.value.replace(/["]/g, "'") + ";";
          }).join(" ");
          if (string) {
            $(el).attr(styleAttributeName, string);
          }
        }
        function inlinePseudoElements(el) {
          if (el.pseudoElementType && el.styleProps.content) {
            var parsed = parseContent(el.styleProps.content.value);
            if (parsed.img) {
              el.name = "img";
              $(el).attr("src", parsed.img);
            } else {
              $(el).text(parsed);
            }
            var parent = el.pseudoElementParent;
            if (el.pseudoElementType === "before") {
              $(parent).prepend(el);
            } else {
              $(parent).append(el);
            }
          }
        }
        function setDimensionAttrs(el, dimension) {
          if (!el.name) {
            return;
          }
          var elName = el.name.toUpperCase();
          if (juiceClient[dimension + "Elements"].indexOf(elName) > -1) {
            for (var i in el.styleProps) {
              if (el.styleProps[i].prop === dimension) {
                if (el.styleProps[i].value.match(/px/)) {
                  var pxSize = el.styleProps[i].value.replace("px", "");
                  $(el).attr(dimension, pxSize);
                  return;
                }
                if (juiceClient.tableElements.indexOf(elName) > -1 && el.styleProps[i].value.match(/\%/)) {
                  $(el).attr(dimension, el.styleProps[i].value);
                  return;
                }
              }
            }
          }
        }
        function extractBackgroundUrl(value) {
          return value.indexOf("url(") !== 0 ? value : value.replace(/^url\((["'])?([^"']+)\1\)$/, "$2");
        }
        function setAttributesOnTableElements(el) {
          if (!el.name) {
            return;
          }
          var elName = el.name.toUpperCase();
          var styleProps = Object.keys(juiceClient.styleToAttribute);
          if (juiceClient.tableElements.indexOf(elName) > -1) {
            for (var i in el.styleProps) {
              if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
                var prop = juiceClient.styleToAttribute[el.styleProps[i].prop];
                var value = el.styleProps[i].value;
                if (prop === "background") {
                  value = extractBackgroundUrl(value);
                }
                if (/(linear|radial)-gradient\(/i.test(value)) {
                  continue;
                }
                $(el).attr(prop, value);
              }
            }
          }
        }
      }
      function parseContent(content) {
        if (content === "none" || content === "normal") {
          return "";
        }
        var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
        if (imageUrlMatch) {
          var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, "");
          return { img: url };
        }
        content = content.slice(1, content.length - 1);
        content = content.replace(/\\/g, "");
        return content;
      }
      function getPseudoElementType(selector) {
        if (selector.length === 0) {
          return;
        }
        var pseudos = selector[selector.length - 1].pseudos;
        if (!pseudos) {
          return;
        }
        for (var i = 0; i < pseudos.length; i++) {
          if (isPseudoElementName(pseudos[i])) {
            return pseudos[i].name;
          }
        }
      }
      function isPseudoElementName(pseudo) {
        return pseudo.name === "before" || pseudo.name === "after";
      }
      function filterElementPseudos(pseudos) {
        return pseudos.filter(function(pseudo) {
          return !isPseudoElementName(pseudo);
        });
      }
      function juiceDocument($, options) {
        options = utils.getDefaultOptions(options);
        var css = extractCssFromDocument($, options);
        css += "\n" + options.extraCss;
        inlineDocument($, css, options);
        return $;
      }
      function getStylesData($, options) {
        var results = [];
        var stylesList = $("style");
        var styleDataList, styleData, styleElement;
        stylesList.each(function() {
          styleElement = this;
          styleDataList = styleElement.childNodes;
          if (styleDataList.length !== 1) {
            return;
          }
          styleData = styleDataList[0].data;
          if (options.applyStyleTags && $(styleElement).attr("data-embed") === void 0) {
            results.push(styleData);
          }
          if (options.removeStyleTags && $(styleElement).attr("data-embed") === void 0) {
            var preservedText = utils.getPreservedText(styleElement.childNodes[0].nodeValue, {
              mediaQueries: options.preserveMediaQueries,
              fontFaces: options.preserveFontFaces,
              keyFrames: options.preserveKeyFrames,
              pseudos: options.preservePseudos
            }, juiceClient.ignoredPseudos);
            if (preservedText) {
              styleElement.childNodes[0].nodeValue = preservedText;
            } else {
              $(styleElement).remove();
            }
          }
          $(styleElement).removeAttr("data-embed");
        });
        return results;
      }
      function extractCssFromDocument($, options) {
        var results = getStylesData($, options);
        var css = results.join("\n");
        return css;
      }
      return juiceClient;
    };
  }
});

// ../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/juice@5.2.0/node_modules/juice/client.js"(exports, module2) {
    "use strict";
    var cheerio = require_cheerio3();
    var makeJuiceClient = require_inline();
    var juiceClient = makeJuiceClient(function(html, options) {
      return cheerio(html, { xmlMode: options && options.xmlMode }, juiceDocument, [options]);
    });
    var juiceDocument = function(html, options) {
      return juiceClient.juiceDocument(html, options);
    };
    juiceClient.inlineContent = function(html, css, options) {
      return cheerio(html, { xmlMode: options && options.xmlMode }, juiceClient.inlineDocument, [css, options]);
    };
    module2.exports = juiceClient;
  }
});

// ../../packages/core/dist/ThemeProcessor.js
var require_ThemeProcessor = __commonJS({
  "../../packages/core/dist/ThemeProcessor.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processHtml = void 0;
    var juice_1 = __importDefault(require_client());
    var DATA_TOOL = "WeMD\u7F16\u8F91\u5668";
    var SECTION_ID = "wemd";
    var BLOCK_TAGS = [
      "p",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "ul",
      "ol",
      "li",
      "blockquote",
      "table",
      "figure",
      "pre",
      "hr"
    ];
    var processHtml2 = (html, css, inlineStyles = true, inlinePseudoElements = false, replaceLocalImages = false) => {
      if (!html || !css) {
        return html || "";
      }
      if (replaceLocalImages) {
        const placeholderUrl = "https://img.wemd.app/wemd/local-image-placeholder.png";
        html = html.replace(/<img\s+([^>]*?)src="([^"]+)"([^>]*?)>/gi, (match, p1, src, p3) => {
          if (!src.startsWith("http://") && !src.startsWith("https://") && !src.startsWith("data:")) {
            return `<img ${p1}src="${placeholderUrl}"${p3} data-original-src="${src}" title="Local image - Upload required for WeChat">`;
          }
          return match;
        });
      }
      BLOCK_TAGS.forEach((tag) => {
        const regex = new RegExp(`<${tag}(\\s+[^>]*|)>`, "gi");
        html = html.replace(regex, (match, attributes) => {
          if (match.includes("data-tool="))
            return match;
          return `<${tag} data-tool="${DATA_TOOL}"${attributes}>`;
        });
      });
      html = html.replace(/<mjx-container (class="inline.+?)<\/mjx-container>/g, "<span $1</span>");
      html = html.replace(/\s<span class="inline/g, '&nbsp;<span class="inline');
      html = html.replace(/svg><\/span>\s/g, "svg></span>&nbsp;");
      html = html.replace(/mjx-container/g, "section");
      html = html.replace(/class="mjx-solid"/g, 'fill="none" stroke-width="70"');
      html = html.replace(/<mjx-assistive-mml.+?<\/mjx-assistive-mml>/g, "");
      html = html.replace(/<code([^>]*class="[^"]*\bhljs\b[^"]*"[^>]*)>([\s\S]*?)<\/code>/g, (match, attrs, inner) => {
        let protected_ = inner;
        protected_ = protected_.replace(/\t/g, "&nbsp;&nbsp;");
        protected_ = protected_.replace(/<\/span> <span/g, " </span><span");
        protected_ = protected_.replace(/\n( +)/g, (m, spaces) => {
          return "\n" + "&nbsp;".repeat(spaces.length);
        });
        protected_ = protected_.replace(/^( +)/, (m, spaces) => {
          return "&nbsp;".repeat(spaces.length);
        });
        return `<code${attrs}>${protected_}</code>`;
      });
      const hasMacBarPseudo = css.includes("pre.custom::before") || css.includes("pre::before");
      const hasMacBar = hasMacBarPseudo && css.includes("#ff5f56");
      if (hasMacBar && inlinePseudoElements) {
        let paddingTop = 36;
        const paddingMatch = css.match(/pre\s+code\.hljs\s*\{[^}]*padding:\s*(\d+)px/i);
        if (paddingMatch) {
          paddingTop = parseInt(paddingMatch[1], 10);
        }
        const marginTop = -(paddingTop - 12);
        const macBarHtml = `<span style="display:block;margin:${marginTop}px 0 16px 0;line-height:1;"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ff5f56;margin-right:8px;"></span><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ffbd2e;margin-right:8px;"></span><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#27c93f;"></span></span>`;
        html = html.replace(/<code([^>]*class="[^"]*\bhljs\b[^"]*"[^>]*)>/gi, `<code$1>${macBarHtml}`);
        css = css.replace(/#wemd[^{]*pre[^{]*::before\s*\{[^}]*#ff5f56[^}]*\}/gi, "");
      }
      if (inlinePseudoElements) {
        if (css.includes("blockquote::before") && css.includes('content: "\u201C"')) {
          const quoteColorMatch = css.match(/#wemd\s+blockquote::before\s*\{[^}]*color:\s*([^;}]+)/i);
          const quoteColor = quoteColorMatch ? quoteColorMatch[1].trim() : "inherit";
          html = html.replace(/<blockquote([^>]*)>([\s\S]*?)<\/blockquote>/gi, (match, attrs, content) => {
            const beforeHtml = `<span style="display:block;height:0;font-size:60px;color:${quoteColor};font-family:Georgia,serif;line-height:1;margin-left:-40px;margin-top:-6px;opacity:0.3;pointer-events:none;">\u201C</span>`;
            return `<blockquote${attrs} style="position:relative;">${beforeHtml}<section style="position:relative;z-index:1;">${content}</section></blockquote>`;
          });
          css = css.replace(/#wemd\s+blockquote::before\s*\{[^}]*content:\s*""[^}]*\}/gi, "");
        }
        if (css.includes("blockquote::before") && css.includes("border-top") && css.includes("border-left")) {
          const beforeMatch = css.match(/#wemd\s+blockquote::before\s*\{([^}]*border-top:[^}]*border-left:[^}]*)\}/i);
          const afterMatch = css.match(/#wemd\s+blockquote::after\s*\{([^}]*border-bottom:[^}]*border-right:[^}]*)\}/i);
          if (beforeMatch && afterMatch) {
            const beforeStyle = beforeMatch[1].trim().replace(/\n/g, "").replace(/\s+/g, " ");
            const afterStyle = afterMatch[1].trim().replace(/\n/g, "").replace(/\s+/g, " ");
            html = html.replace(/<blockquote([^>]*)>([\s\S]*?)<\/blockquote>/gi, (match, attrs, content) => {
              const beforeHtml = `<span style="display:block;position:absolute;top:0;left:0;width:20px;height:20px;${beforeStyle}"></span>`;
              const afterHtml = `<span style="display:block;position:absolute;bottom:0;right:0;width:20px;height:20px;${afterStyle}"></span>`;
              return `<blockquote${attrs} style="position:relative;">${beforeHtml}${content}${afterHtml}</blockquote>`;
            });
            css = css.replace(/#wemd\s+blockquote::before\s*\{[^}]*border-top:[^}]*border-left:[^}]*\}/gi, "");
            css = css.replace(/#wemd\s+blockquote::after\s*\{[^}]*border-bottom:[^}]*border-right:[^}]*\}/gi, "");
          }
        }
        if (css.includes("blockquote::before") && css.includes("margin: 0 auto 15px")) {
          const beforeMatch = css.match(/#wemd\s+blockquote::before\s*\{([^}]*background:[^}]*margin:\s*0\s+auto\s+15px[^}]*)\}/i);
          const afterMatch = css.match(/#wemd\s+blockquote::after\s*\{([^}]*background:[^}]*margin:\s*15px\s+auto\s+0[^}]*)\}/i);
          if (beforeMatch && afterMatch) {
            const beforeStyle = beforeMatch[1].trim().replace(/\n/g, "").replace(/\s+/g, " ");
            const afterStyle = afterMatch[1].trim().replace(/\n/g, "").replace(/\s+/g, " ");
            html = html.replace(/<blockquote([^>]*)>([\s\S]*?)<\/blockquote>/gi, (match, attrs, content) => {
              const beforeHtml = `<span style="display:block;width:40px;${beforeStyle}"></span>`;
              const afterHtml = `<span style="display:block;width:40px;${afterStyle}"></span>`;
              return `<blockquote${attrs} style="text-align:center;">${beforeHtml}${content}${afterHtml}</blockquote>`;
            });
            css = css.replace(/#wemd\s+blockquote::before\s*\{[^}]*margin:\s*0\s+auto\s+15px[^}]*\}/gi, "");
            css = css.replace(/#wemd\s+blockquote::after\s*\{[^}]*margin:\s*15px\s+auto\s+0[^}]*\}/gi, "");
          }
        }
      }
      const wrappedHtml = `<section id="${SECTION_ID}">${html}</section>`;
      if (!inlineStyles) {
        return wrappedHtml;
      }
      try {
        const res = juice_1.default.inlineContent(wrappedHtml, css, {
          inlinePseudoElements,
          preserveImportant: true
        });
        return res;
      } catch (e) {
        console.error("Juice inline error:", e);
        return wrappedHtml;
      }
    };
    exports.processHtml = processHtml2;
  }
});

// ../../packages/core/dist/themes/basic.js
var require_basic = __commonJS({
  "../../packages/core/dist/themes/basic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basicTheme = void 0;
    exports.basicTheme = `/* \u9ED8\u8BA4\u6837\u5F0F\uFF0C\u6700\u4F73\u5B9E\u8DF5 */

/* \u5168\u5C40\u5C5E\u6027 */
#wemd {
  font-size: 16px;
  color: #000000;
  padding: 0 10px;
  line-height: 1.6;
  word-spacing: 0px;
  letter-spacing: 0px;
  word-break: break-word;
  word-wrap: break-word;
  text-align: left;
  font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
}

/* \u6BB5\u843D */
#wemd p {
  font-size: 16px;
  margin-top: 10px;
  margin-bottom: 10px;
  line-height: 26px;
  color: #000000;
}

/* \u6807\u9898 */
#wemd h1,
#wemd h2,
#wemd h3,
#wemd h4,
#wemd h5,
#wemd h6 {
  margin-top: 30px;
  margin-bottom: 15px;
  padding: 0px;
  font-weight: bold;
  color: #000000;
}
#wemd h1 {
  font-size: 24px;
}
#wemd h2 {
  font-size: 22px;
}
#wemd h3 {
  font-size: 20px;
}
#wemd h4 {
  font-size: 18px;
}
#wemd h5 {
  font-size: 16px;
}
#wemd h6 {
  font-size: 16px;
}

#wemd h1 .prefix,
#wemd h2 .prefix,
#wemd h3 .prefix,
#wemd h4 .prefix,
#wemd h5 .prefix,
#wemd h6 .prefix {
  display: none;
}

#wemd h1 .suffix,
#wemd h2 .suffix,
#wemd h3 .suffix,
#wemd h4 .suffix,
#wemd h5 .suffix,
#wemd h6 .suffix {
  display: none;
}

/* \u5217\u8868 */
#wemd ul,
#wemd ol {
  margin-top: 8px;
  margin-bottom: 8px;
  padding-left: 25px;
  color: #000000;
}
#wemd ul {
  list-style-type: disc;
}
#wemd ul ul {
  list-style-type: square;
}

#wemd ol {
  list-style-type: decimal;
}

#wemd li section {
  margin-top: 5px;
  margin-bottom: 5px;
  line-height: 26px;
  text-align: left;
  color: #010101; /* \u4F7F\u7528\u63A5\u8FD1\u9ED1\u8272\u7684 HEX\uFF0C\u907F\u514D\u5FAE\u4FE1\u541E\u6389\u7EAF\u9ED1\u8272 */
  font-weight: 500;
}

/* \u5F15\u7528 */
#wemd blockquote {
  border: none;
}

#wemd .multiquote-1 {
  display: block;
  font-size: 0.9em;
  overflow: auto;
  overflow-scrolling: touch;
  border-left: 3px solid rgba(0, 0, 0, 0.4);
  background: rgba(0, 0, 0, 0.05);
  color: #6a737d;
  padding-top: 10px;
  padding-bottom: 10px;
  padding-left: 20px;
  padding-right: 10px;
  margin-bottom: 20px;
  margin-top: 20px;
}

#wemd .multiquote-1 p {
  margin: 0px;
  color: #000000;
  line-height: 26px;
}

#wemd .multiquote-2 {
  box-shadow: 1px 1px 10px rgba(0,0,0,0.2);
  padding: 20px;
  margin-bottom: 20px;
  margin-top: 20px;
}

#wemd .multiquote-3 {
  box-shadow: 1px 1px 10px rgba(0,0,0,0.2);
  padding: 20px;
  margin-bottom: 20px;
  margin-top: 20px;
}

#wemd .multiquote-3 p {
  text-align: center;
}

#wemd .multiquote-3 h3 {
  text-align: center;
}

#wemd .table-of-contents a {
  border: none;
  color: #000000;
  font-weight: normal;
}

/* \u94FE\u63A5 */
#wemd a {
  text-decoration: none;
  color: #1e6bb8;
  word-wrap: break-word;
  font-weight: bold;
  border-bottom: 1px solid #1e6bb8;
}

/* \u52A0\u7C97 */
#wemd strong {
  font-weight: bold;
  color: #000000;
}

/* \u659C\u4F53 */
#wemd em {
  font-style: italic;
  color: #000000;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
  font-weight: bold;
  color: #000000;
}

/* \u5220\u9664\u7EBF */
#wemd del {
  font-style: italic;
  color: #000000;
}

/* \u5206\u9694\u7EBF */
#wemd hr {
  height: 1px;
  margin: 0;
  margin-top: 10px;
  margin-bottom: 10px;
  border: none;
  border-top: 1px solid black;
}

/* \u4EE3\u7801\u5757\u5BB9\u5668 */
#wemd pre {
  margin-top: 10px;
  margin-bottom: 10px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

#wemd pre.custom {
  padding: 0;
  border-radius: 6px;
  overflow: hidden;
  overflow-x: auto;
}

#wemd pre code {
  display: block;
  font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;
  border-radius: 0px;
  font-size: 12px;
  white-space: pre;
  min-width: max-content;
  -webkit-overflow-scrolling: touch;
}

#wemd pre code span {
  line-height: 26px;
}

/* \u884C\u5185\u4EE3\u7801 */
#wemd p code,
#wemd li code {
  font-size: 14px;
  word-wrap: break-word;
  padding: 2px 4px;
  border-radius: 4px;
  margin: 0 2px;
  color: #1e6bb8;
  background-color: rgba(27,31,35,.05);
  font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;
  word-break: break-all;
}

/* \u56FE\u7247 */
#wemd img {
  display: block;
  margin: 0 auto;
  max-width: 100%;
}

/* \u56FE\u7247 */
#wemd figure {
  margin: 0;
  margin-top: 10px;
  margin-bottom: 10px;
}

/* \u56FE\u7247\u63CF\u8FF0\u6587\u5B57 */
#wemd figcaption {
  margin-top: 5px;
  text-align: center;
  color: #888;
  font-size: 14px;
}


/* \u8868\u683C\u5BB9\u5668 */
#wemd .table-container{
  overflow-x: auto;
}

/* \u8868\u683C */
#wemd table {
  display: table;
  text-align: left;
}
#wemd tbody {
  border: 0;
}

#wemd table tr {
  border: 0;
  border-top: 1px solid #ccc;
  background-color: #ffffff;
}

#wemd table tr:nth-child(2n) {
  background-color: #F8F8F8;
}

#wemd table tr th,
#wemd table tr td {
  font-size: 16px;
  border: 1px solid #ccc;
  padding: 5px 10px;
  text-align: left;
}

#wemd table tr th {
  font-weight: bold;
  background-color: #f0f0f0;
}

/* \u8868\u683C\u6700\u5C0F\u5217\u5BBD4\u4E2A\u6C49\u5B57 */
#wemd table tr th:nth-of-type(n),
#wemd table tr td:nth-of-type(n){
  min-width:85px;
}

#wemd .footnote-word {
  color: #1e6bb8;
  font-weight: bold;
}

#wemd .footnote-ref {
  color: #1e6bb8;
  font-weight: bold;
}

#wemd .footnote-item {
  display: flex;
}

#wemd .footnote-num {
  display: inline;
  width: 10%; /*\u795E\u5947\uFF0C50px\u5C31\u4E0D\u53EF\u4EE5*/
  background: none;
  font-size: 80%;
  opacity: 0.6;
  line-height: 26px;
  font-family: ptima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;
}

#wemd .footnote-item p {
  display: inline;
  font-size: 14px;
  width: 90%;
  padding: 0px;
  margin: 0;
  line-height: 26px;
  color: #000000;
  word-break:break-all;
  width: calc(100%-50)
}

#wemd sub, sup {
  line-height: 0;
}

#wemd .footnotes-sep:before {
  content: "\u53C2\u8003\u8D44\u6599";
  display: block;
}

/* \u89E3\u51B3\u516C\u5F0F\u95EE\u9898 */
#wemd .block-equation {
  display:block;
  text-align: center;
  overflow: auto;
  display: block;
  -webkit-overflow-scrolling: touch;
}

#wemd .block-equation svg {
  max-width: 300% !important;
  -webkit-overflow-scrolling: touch;
}

#wemd .inline-equation {
}

#wemd .inline-equation svg {
}

#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  white-space: normal;
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}

#wemd .nice-suffix-juejin-container {
  margin-top: 20px !important;
}

#wemd figure a {
  border: none;
}

#wemd figure a img {
  margin: 0px;
}

#wemd figure {
  display:flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

/* \u56FE\u7247\u94FE\u63A5\u5D4C\u5957 */
#wemd figure a {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* \u56FE\u7247\u94FE\u63A5\u5D4C\u5957\uFF0C\u56FE\u7247\u89E3\u91CA */
#wemd figure a + figcaption {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  margin-top: -35px;
  background: rgba(0,0,0,0.7);
  color: #ffffff;
  line-height: 35px;
  z-index: 20;
}

#wemd .callout {
  margin: 24px 0;
  padding: 18px 20px;
  border-radius: 16px;
  border: 1px solid #e2e8f0;
  background: #ffffff;
  box-shadow: 0 12px 25px rgba(15, 23, 42, 0.08);
}

#wemd .callout-title {
  font-weight: 600;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  letter-spacing: 0.05em;
}

#wemd .callout-icon {
  font-size: 18px;
}

#wemd .callout-note { border-left: 4px solid #6366f1; background: #f5f5ff; }
#wemd .callout-tip { border-left: 4px solid #10b981; background: #ecfdf5; }
#wemd .callout-important { border-left: 4px solid #8b5cf6; background: #f5f3ff; }
#wemd .callout-warning { border-left: 4px solid #f59e0b; background: #fffbeb; }
#wemd .callout-caution { border-left: 4px solid #ef4444; background: #fff5f5; }


#wemd .task-list-item {
  list-style: none;
  margin-left: -1.2em;
  margin-bottom: 6px;
  display: flex;
  gap: 8px;
  align-items: flex-start;
}

#wemd .task-list-item input[type='checkbox'] {
  margin-top: 4px;
  pointer-events: none;
}
`;
  }
});

// ../../packages/core/dist/themes/code-github.js
var require_code_github = __commonJS({
  "../../packages/core/dist/themes/code-github.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.codeGithubTheme = void 0;
    exports.codeGithubTheme = `/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/

/* \u4EE3\u7801\u5757\u6837\u5F0F - \u9700\u8981\u6DFB\u52A0 #wemd \u524D\u7F00\u4EE5\u5339\u914D\u5305\u88C5\u540E\u7684 HTML */
#wemd .hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
  color: #333;
  background: #f8f8f8;
}

#wemd .hljs-comment,
#wemd .hljs-quote {
  color: #998;
  font-style: italic;
}

#wemd .hljs-keyword,
#wemd .hljs-selector-tag,
#wemd .hljs-subst {
  color: #333;
  font-weight: bold;
}

#wemd .hljs-number,
#wemd .hljs-literal,
#wemd .hljs-variable,
#wemd .hljs-template-variable,
#wemd .hljs-tag .hljs-attr {
  color: #008080;
}

#wemd .hljs-string,
#wemd .hljs-doctag {
  color: #d14;
}

#wemd .hljs-title,
#wemd .hljs-section,
#wemd .hljs-selector-id {
  color: #900;
  font-weight: bold;
}

#wemd .hljs-subst {
  font-weight: normal;
}

#wemd .hljs-type,
#wemd .hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

#wemd .hljs-tag,
#wemd .hljs-name,
#wemd .hljs-attribute {
  color: #000080;
  font-weight: normal;
}

#wemd .hljs-regexp,
#wemd .hljs-link {
  color: #009926;
}

#wemd .hljs-symbol,
#wemd .hljs-bullet {
  color: #990073;
}

#wemd .hljs-built_in,
#wemd .hljs-builtin-name {
  color: #0086b3;
}

#wemd .hljs-meta {
  color: #999;
  font-weight: bold;
}

#wemd .hljs-deletion {
  background: #fdd;
}

#wemd .hljs-addition {
  background: #dfd;
}

#wemd .hljs-emphasis {
  font-style: italic;
}

#wemd .hljs-strong {
  font-weight: bold;
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/custom-default.js
var require_custom_default = __commonJS({
  "../../packages/core/dist/themes/custom-default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.customDefaultTheme = void 0;
    exports.customDefaultTheme = `/* \u81EA\u5B9A\u4E49\u6837\u5F0F,\u5B9E\u65F6\u751F\u6548,\u6D4F\u89C8\u5668\u5B9E\u65F6\u7F13\u5B58 */

/* \u5168\u5C40\u5C5E\u6027
 * \u9875\u8FB9\u8DDD padding: 30px;
 * \u5168\u6587\u5B57\u4F53 font-family: ptima-Regular;
 * \u82F1\u6587\u6362\u884C word-break: break-all;
 */
#wemd {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
  color: #2c3e50;
  line-height: 1.8;
  font-size: 16px;
  letter-spacing: 0.3px;
}

/* \u6BB5\u843D,\u4E0B\u65B9\u672A\u6807\u6CE8\u6807\u7B7E\u53C2\u6570\u5747\u540C\u6B64\u5904
 * \u4E0A\u8FB9\u8DDD margin-top: 5px;
 * \u4E0B\u8FB9\u8DDD margin-bottom: 5px;
 * \u884C\u9AD8 line-height: 26px;
 * \u8BCD\u95F4\u8DDD word-spacing: 3px;
 * \u5B57\u95F4\u8DDD letter-spacing: 3px;
 * \u5BF9\u9F50 text-align: left;
 * \u989C\u8272 color: #3e3e3e;
 * \u5B57\u4F53\u5927\u5C0F font-size: 16px;
 * \u9996\u884C\u7F29\u8FDB text-indent: 2em;
 */
#wemd p {
  margin: 20px 0;
  font-size: 16px;
  color: #34495e;
  line-height: 1.8;
  letter-spacing: 0.5px;
}

/* \u4E00\u7EA7\u6807\u9898 */
#wemd h1 {
  font-size: 28px;
  font-weight: 700;
  color: #1a1a1a;
  margin: 40px 0 24px;
  text-align: center;
  padding-bottom: 12px;
  border-bottom: 2px solid #07c160;
  letter-spacing: 1px;
}

/* \u4E00\u7EA7\u6807\u9898\u5185\u5BB9 */
#wemd h1 .content {
}

/* \u4E00\u7EA7\u6807\u9898\u524D\u7F00 */
#wemd h1 .prefix {
}

/* \u4E00\u7EA7\u6807\u9898\u540E\u7F00 */
#wemd h1 .suffix {
}

/* \u4E8C\u7EA7\u6807\u9898 */
#wemd h2 {
  font-size: 22px;
  font-weight: 600;
  color: #2c3e50;
  margin: 32px 0 16px;
  padding-left: 12px;
  border-left: 4px solid #07c160;
  line-height: 1.4;
  letter-spacing: 0.5px;
}

/* \u4E8C\u7EA7\u6807\u9898\u5185\u5BB9 */
#wemd h2 .content {
}

/* \u4E8C\u7EA7\u6807\u9898\u524D\u7F00 */
#wemd h2 .prefix {
}

/* \u4E8C\u7EA7\u6807\u9898\u540E\u7F00 */
#wemd h2 .suffix {
}

/* \u4E09\u7EA7\u6807\u9898 */
#wemd h3 {
  font-size: 19px;
  font-weight: 600;
  color: #34495e;
  margin: 24px 0 12px;
  padding-left: 10px;
  border-left: 3px solid #07c160;
  letter-spacing: 0.3px;
}

/* \u4E09\u7EA7\u6807\u9898\u5185\u5BB9 */
#wemd h3 .content {
}

/* \u4E09\u7EA7\u6807\u9898\u524D\u7F00 */
#wemd h3 .prefix {
}

/* \u4E09\u7EA7\u6807\u9898\u540E\u7F00 */
#wemd h3 .suffix {
}

/* \u56DB\u7EA7\u6807\u9898 */
#wemd h4 {
  font-size: 17px;
  font-weight: 600;
  color: #07c160;
  margin: 20px 0 10px;
  letter-spacing: 0.3px;
}

/* \u56DB\u7EA7\u6807\u9898\u5185\u5BB9 */
#wemd h4 .content {
}

/* \u56DB\u7EA7\u6807\u9898\u524D\u7F00 */
#wemd h4 .prefix {
}

/* \u56DB\u7EA7\u6807\u9898\u540E\u7F00 */
#wemd h4 .suffix {
}

/* \u4E94\u7EA7\u6807\u9898 */
#wemd h5 {
  font-size: 16px;
  font-weight: 600;
  color: #5a6c7d;
  margin: 18px 0 8px;
}

/* \u516D\u7EA7\u6807\u9898 */
#wemd h6 {
  font-size: 15px;
  font-weight: 600;
  color: #7f8c8d;
  margin: 16px 0 8px;
}

/* \u65E0\u5E8F\u5217\u8868\u6574\u4F53\u6837\u5F0F
 * list-style-type: square|circle|disc;
 */
#wemd ul {
  padding-left: 24px;
  list-style-type: disc;
  color: #34495e;
}

#wemd ul li {
  padding-left: 4px;
  color: #07c160;
}

#wemd ul li section {
  color: #34495e;
}

/* \u5D4C\u5957\u5217\u8868 */
#wemd ul ul {
  list-style-type: circle;
}

#wemd ul ul ul {
  list-style-type: square;
}

/* \u6709\u5E8F\u5217\u8868\u6574\u4F53\u6837\u5F0F
 * list-style-type: upper-roman|lower-greek|lower-alpha;
 */
#wemd ol {
  padding-left: 24px;
  list-style-type: decimal;
  color: #34495e;
}

#wemd ol li {
  padding-left: 4px;
}

/* \u5217\u8868\u5185\u5BB9,\u4E0D\u8981\u8BBE\u7F6Eli
 */
#wemd li section {
  margin: 8px 0;
  line-height: 1.8;
  font-size: 16px;
  color: #34495e;
}

/* \u4E00\u7EA7\u5F15\u7528
 * \u5DE6\u8FB9\u7F18\u989C\u8272 border-left-color: black;
 * \u80CC\u666F\u8272 background: gray;
 */
#wemd .multiquote-1 {
  border-left: 4px solid #07c160;
  background: #f6f8fa;
  padding: 16px 20px;
  margin: 20px 0;
  color: #475569;
  border-radius: 2px;
}

/* \u4E00\u7EA7\u5F15\u7528\u6587\u5B57 */
#wemd .multiquote-1 p {
  margin: 0;
  font-size: 15px;
  color: #475569;
  line-height: 1.8;
}

/* \u4E8C\u7EA7\u5F15\u7528
 */
#wemd .multiquote-2 {
  border-left: 3px solid #00a854;
  background: #fafafa;
  padding: 14px 18px;
  margin: 16px 0;
  border-radius: 2px;
}

/* \u4E8C\u7EA7\u5F15\u7528\u6587\u5B57 */
#wemd .multiquote-2 p {
  margin: 0;
  font-size: 15px;
  color: #64748b;
  line-height: 1.7;
}

/* \u4E09\u7EA7\u5F15\u7528
 */
#wemd .multiquote-3 {
  border-left: 2px solid #07c160;
  background: #fafafa;
  padding: 12px 16px;
  margin: 14px 0;
  border-radius: 2px;
}

/* \u4E09\u7EA7\u5F15\u7528\u6587\u5B57 */
#wemd .multiquote-3 p {
  margin: 0;
  font-size: 14px;
  color: #64748b;
}

/* \u94FE\u63A5 
 * border-bottom: 1px solid #009688;
 */
#wemd a {
  color: #07c160;
  text-decoration: none;
  border-bottom: 1px solid #07c160;
  font-weight: 500;
}

/* \u52A0\u7C97 */
#wemd strong {
  font-weight: 600;
  color: #07c160;
  letter-spacing: 0.2px;
}

/* \u659C\u4F53 */
#wemd em {
  font-style: italic;
  color: #07c160;
  font-weight: 500;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
  font-weight: 700;
  font-style: italic;
  color: #00a854;
}

/* \u5220\u9664\u7EBF */
#wemd del {
  text-decoration: line-through;
  color: #94a3b8;
  opacity: 0.7;
}

/* \u5206\u9694\u7EBF
* \u7C97\u7EC6\u3001\u6837\u5F0F\u548C\u989C\u8272
* border-top: 1px solid #3e3e3e;
*/
#wemd hr {
  border: none;
  height: 1px;
  background: #e2e8f0;
  margin: 28px 0;
}

/* \u56FE\u7247
* \u5BBD\u5EA6 width: 80%;
* \u5C45\u4E2D margin: 0 auto;
* \u5C45\u5DE6 margin: 0 0;
*/
#wemd img {
  display: block;
  margin: 24px auto;
  max-width: 100%;
  border-radius: 4px;
}

/* \u56FE\u7247\u63CF\u8FF0\u6587\u5B57 */
#wemd figcaption {
  text-align: center;
  font-size: 14px;
  color: #94a3b8;
  margin-top: 8px;
  letter-spacing: 0.2px;
}

/* \u884C\u5185\u4EE3\u7801 */
#wemd p code, #wemd li code {
  background: #f0fdf4;
  padding: 3px 6px;
  border-radius: 3px;
  color: #059669;
  font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, monospace;
  font-size: 0.9em;
  margin: 0 3px;
  border: 1px solid #bbf7d0;
}

/* 
 * \u4EE3\u7801\u5757\u4E0D\u6362\u884C display: -webkit-box !important;
 * \u4EE3\u7801\u5757\u6362\u884C display: block;
 */
#wemd pre code {
  display: block;
  background: #f8fafc;
  padding: 16px;
  border-radius: 4px;
  overflow-x: auto;
  font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, monospace;
  font-size: 14px;
  line-height: 1.6;
  color: #334155;
  border: 1px solid #e2e8f0;
}

/*
 * \u8868\u683C\u5185\u7684\u5355\u5143\u683C
 * \u5B57\u4F53\u5927\u5C0F font-size: 16px;
 * \u8FB9\u6846 border: 1px solid #ccc;
 * \u5185\u8FB9\u8DDD padding: 5px 10px;
 */
#wemd table tr th,
#wemd table tr td {
  border: 1px solid #e2e8f0;
  padding: 10px 14px;
  font-size: 15px;
  color: #334155;
  line-height: 1.6;
}

#wemd table tr th {
  background: #f0fdf4;
  color: #065f46;
  font-weight: 600;
  letter-spacing: 0.3px;
}

#wemd table tr:nth-child(2n) {
  background-color: #f8fafc;
}

/* 
 * \u67D0\u4E00\u5217\u8868\u683C\u5217\u5BBD\u63A7\u5236
 * n \u53EF\u4EE5\u4FEE\u6539\u4E3A\u5177\u4F53\u6570\u5B57,\u4E0D\u4FEE\u6539\u65F6\u8868\u793A\u6240\u6709\u5217
 * \u6700\u5C0F\u5217\u5BBD min-width: 85px;
 */
#wemd table tr th:nth-of-type(n),
#wemd table tr td:nth-of-type(n){
  min-width: 100px;
}

/* \u811A\u6CE8\u6587\u5B57 */
#wemd .footnote-word {
  color: #07c160;
  font-weight: 500;
  border-bottom: 1px dashed #07c160;
}

/* \u811A\u6CE8\u4E0A\u6807 */
#wemd .footnote-ref {
  color: #07c160;
  font-weight: 600;
}

/* "\u53C2\u8003\u8D44\u6599"\u56DB\u4E2A\u5B57 
 * \u5185\u5BB9 content: "\u53C2\u8003\u8D44\u6599";
 */
#wemd .footnotes-sep:before {
  content: "\u53C2\u8003\u8D44\u6599";
  font-weight: 600;
  margin-top: 36px;
  margin-bottom: 16px;
  display: block;
  font-size: 18px;
  color: #1a1a1a;
  letter-spacing: 0.5px;
}

/* \u53C2\u8003\u8D44\u6599\u7F16\u53F7 */
#wemd .footnote-num {
  display: inline-block;
  width: 24px;
  text-align: right;
  margin-right: 8px;
  color: #94a3b8;
  font-weight: 500;
}

/* \u53C2\u8003\u8D44\u6599\u6587\u5B57 */
#wemd .footnote-item p { 
  display: inline;
  font-size: 14px;
  color: #64748b;
  line-height: 1.8;
}

/* \u53C2\u8003\u8D44\u6599\u89E3\u91CA */
#wemd .footnote-item p em {
  font-style: normal;
  color: #94a3b8;
  margin-left: 6px;
}

/* \u884C\u95F4\u516C\u5F0F
 * \u6700\u5927\u5BBD\u5EA6 max-width: 300% !important;
 */
#wemd .block-equation svg {
  display: block;
  margin: 20px auto;
  max-width: 300% !important;
}

/* \u884C\u5185\u516C\u5F0F
 */
#wemd .inline-equation svg { 
  vertical-align: middle;
}

/* Callout \u63D0\u793A\u5757 */
#wemd .callout {
  margin: 28px 0;
  padding: 22px 24px;
  border-radius: 22px;
  border: 1px solid rgba(7, 193, 96, 0.15);
  background: #ffffff;
  box-shadow: 0 25px 45px rgba(15, 23, 42, 0.12);
  position: relative;
  overflow: hidden;
}

#wemd .callout::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 22px;
  pointer-events: none;
  background: linear-gradient(120deg, rgba(7,193,96,0.05), rgba(7,89,193,0.03));
}

#wemd .callout-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #0f172a;
  font-size: 16px;
  letter-spacing: 0.05em;
}

#wemd .callout-icon {
  font-size: 20px;
}

#wemd .callout-note {
  border-color: rgba(100, 116, 255, 0.25);
  background: linear-gradient(135deg, #f7f9ff, #edf2ff);
}

#wemd .callout-tip {
  border-color: rgba(139, 92, 246, 0.25);
  background: linear-gradient(135deg, #f5f3ff, #ede9fe);
}

#wemd .callout-important {
  border-color: rgba(14, 165, 233, 0.25);
  background: linear-gradient(135deg, #f0f9ff, #e0f2ff);
}

#wemd .callout-warning {
  border-color: rgba(249, 158, 0, 0.25);
  background: linear-gradient(135deg, #fff8ed, #fff3dc);
}

#wemd .callout-caution {
  border-color: rgba(239, 68, 68, 0.25);
  background: linear-gradient(135deg, #fff5f5, #ffe7e7);
}


/* \u9AD8\u4EAE\u6587\u672C */
#wemd mark {
  background: linear-gradient(135deg, #fff9c4, #fff59d);
  color: #1a1a1a;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 500;
}

/* \u4E0A\u6807 */
#wemd sup {
  font-size: 0.75em;
  vertical-align: super;
  color: #059669;
}

/* \u4E0B\u6807 */
#wemd sub {
  font-size: 0.75em;
  vertical-align: sub;
  color: #059669;
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/academic-paper.js
var require_academic_paper = __commonJS({
  "../../packages/core/dist/themes/academic-paper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.academicPaperTheme = void 0;
    exports.academicPaperTheme = `/* \u5B66\u672F\u8BBA\u6587\u98CE\u683C */
#wemd {
    padding: 30px 20px;
    max-width: 677px;
    margin: 0 auto;
    /* \u6DF7\u5408\u5B57\u4F53\u6808\uFF1A\u897F\u6587Times + \u4E2D\u6587\u5B8B\u4F53 */
    font-family: "Times New Roman", "Songti SC", "SimSun", serif;
    color: #000;
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* \u6B63\u6587 - \u79FB\u9664\u9996\u884C\u7F29\u8FDB\uFF0C\u6539\u7528\u6BB5\u95F4\u8DDD\u9002\u5E94\u79FB\u52A8\u7AEF */
#wemd p {
    margin: 16px 0;
    line-height: 1.7;
    text-align: justify;
    text-indent: 0;
    color: #1a1a1a;
    font-size: 16px;
}

/* \u4E00\u7EA7\u6807\u9898 - \u5C45\u4E2D\u8BBA\u6587\u9898 */
#wemd h1 {
    margin: 40px 0 30px;
    text-align: center;
    line-height: 1.4;
}

#wemd h1 .content {
    font-size: 22px;
    font-weight: bold;
    color: #000;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 - \u7AE0\u8282 Section */
#wemd h2 {
    margin: 30px 0 15px;
    text-align: left;
    border-bottom: 2px solid #000;
    /* \u52A0\u7C97\u5E95\u7EBF */
    padding-bottom: 8px;
}

#wemd h2 .content {
    font-size: 18px;
    font-weight: bold;
    color: #000;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 - Subsection */
#wemd h3 {
    margin: 20px 0 10px;
}

#wemd h3 .content {
    font-size: 16px;
    font-weight: bold;
    color: #800000;
    /* \u6817\u8272\uFF0C\u533A\u5206\u5C42\u7EA7 */
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 */
#wemd h4 {
    margin: 15px 0 5px;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: bold;
    font-style: italic;
    /* \u659C\u4F53\u6807\u9898 */
    color: #333;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5F15\u7528 - \u7B80\u6D01\u8FB9\u6846 */
#wemd .multiquote-1 {
    margin: 20px 0;
    padding: 16px 20px;
    background: #fafafa;
    border: 1px solid #ddd;
    border-left: 4px solid #666;
}

#wemd .multiquote-1 p {
    color: #555;
    font-size: 15px;
    margin: 0;
    line-height: 1.6;
    text-indent: 0;
}

#wemd .multiquote-2 {
    margin: 18px 0 18px 20px;
    padding: 14px 18px;
    background: #fafafa;
    border: 1px solid #ddd;
}

#wemd .multiquote-2 p {
    color: #555;
    font-size: 15px;
    margin: 0;
}

#wemd .multiquote-3 {
    margin: 16px 0 16px 20px;
    padding: 12px 16px;
    background: #fcfcfc;
    border: 1px solid #e0e0e0;
}

#wemd .multiquote-3 p {
    color: #555;
    font-size: 15px;
    margin: 0;
}

/* \u5217\u8868 */
#wemd ul {
    list-style: disc;
    padding-left: 20px;
    margin: 16px 0;
}

#wemd ul ul {
    list-style-type: square;
    margin-top: 5px;
}

#wemd ol {
    list-style: decimal;
    padding-left: 20px;
    margin: 16px 0;
}

#wemd ol ol {
    list-style-type: lower-alpha;
}

#wemd li section {
    color: #333;
    line-height: 1.6;
}

/* \u94FE\u63A5 - \u7ECF\u5178\u6DF1\u84DD */
#wemd a {
    color: #000080;
    text-decoration: underline;
}

/* \u52A0\u7C97 */
#wemd strong {
    color: #000;
    font-weight: bold;
}

/* \u659C\u4F53 */
#wemd em {
    font-style: italic;
    color: #000;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    font-weight: bold;
    font-style: italic;
    color: #000;
}

/* \u9AD8\u4EAE - \u5B66\u672F\u6807\u8BB0\u98CE\u683C */
#wemd mark {
    background: #fff3cd;
    color: #000;
    padding: 0 2px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #666;
    opacity: 0.7;
}

/* \u56FE\u7247 - \u7B80\u6D01\u65E0\u88C5\u9970 */
#wemd img {
    display: block;
    margin: 30px auto;
    width: 100%;
    border: 1px solid #ddd;
}

#wemd figcaption {
    margin-top: 8px;
    text-align: center;
    color: #666;
    font-size: 14px;
    font-style: italic;
}

/* 
 * \u884C\u5185\u4EE3\u7801 - LaTeX 	exttt \u98CE\u683C (\u4FEE\u590D\u91CD\u70B9)
 * \u7EAF\u9ED1\u6587\u5B57 + \u6781\u6DE1\u7070\u5E95 + \u7B49\u5BBD\u5B57\u4F53
 */
#wemd p code,
#wemd li code {
    color: #000;
    /* \u7EAF\u9ED1 */
    background: #f4f4f4;
    /* \u6781\u6DE1\u7070 */
    border: 1px solid #eee;
    /* \u6781\u7EC6\u8FB9\u6846 */
    padding: 1px 4px;
    margin: 0 2px;
    border-radius: 2px;
    font-size: 14px;
    font-family: "Courier New", Courier, monospace;
    /* \u5F3A\u5236\u7B49\u5BBD */
}

/* \u4EE3\u7801\u5757 - \u7B80\u5355\u7684\u5B66\u672F\u98CE\u683C */
/* \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    background: #f9f9f9;
    border: 1px solid #ccc;
    /* color \u7531 .hljs \u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
    font-family: "Courier New", monospace;
    font-size: 13px;
    padding: 12px;
    border-radius: 0;
    /* \u76F4\u89D2 */
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u989C\u8272 */
#wemd pre code:not(.hljs) {
    color: #333;
}

/* \u8868\u683C - \u7ECF\u5178\u4E09\u7EBF\u8868 */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 14px;
    border-top: 2px solid #000;
    border-bottom: 2px solid #000;
}

#wemd table tr th {
    border-bottom: 1px solid #000;
    padding: 10px 5px;
    font-weight: bold;
    text-align: center;
    background: #fff;
}

#wemd table tr td {
    padding: 10px 5px;
    border: none;
    text-align: center;
    color: #333;
}

/* \u9694\u884C\u5FAE\u5E95\u8272 */
#wemd table tr:nth-child(even) td {
    background-color: #fafafa;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #000080;
}

#wemd .footnotes-sep {
    border-top: 1px solid #ccc;
    padding-top: 10px;
    margin-top: 40px;
    width: 20%;
    /* \u77ED\u7EBF */
}

#wemd .footnote-num {
    font-weight: bold;
    color: #000;
    margin-right: 4px;
    vertical-align: super;
    font-size: 10px;
}

#wemd .footnote-item p {
    color: #666;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u5B66\u672F\u98CE\u683C */
#wemd .callout {
    margin: 20px 0;
    padding: 16px 20px;
    border: 1px solid #ddd;
    border-radius: 0;
    background: #fafafa;
}

#wemd .callout-title {
    font-weight: bold;
    margin-bottom: 8px;
    font-size: 14px;
    text-transform: uppercase;
    color: #000;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { 
    border-left: 4px solid #666; 
    background: #f5f5f5;
}

#wemd .callout-tip { 
    border-left: 4px solid #555; 
    background: #f5f5f5;
}

#wemd .callout-important { 
    border-left: 4px solid #888; 
    background: #f5f5f5;
}

#wemd .callout-warning { 
    border-left: 4px solid #999; 
    background: #f5f5f5;
}

#wemd .callout-caution { 
    border-left: 4px solid #000; 
    background: #f5f5f5;
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/aurora-glass.js
var require_aurora_glass = __commonJS({
  "../../packages/core/dist/themes/aurora-glass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auroraGlassTheme = void 0;
    exports.auroraGlassTheme = `/* \u6781\u5149\u73BB\u7483\u98CE\u683C */
#wemd {
  padding: 24px 20px;
  max-width: 677px;
  margin: 0 auto;
  font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
  color: #333;
  /* \u80CC\u666F\u900F\u660E\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
  background-color: transparent;
  word-break: break-word;
}

/* \u6BB5\u843D - \u589E\u52A0\u547C\u5438\u611F */
#wemd p {
  margin-top: 22px;
  margin-bottom: 22px;
  line-height: 1.9;
  letter-spacing: 0.6px;
  text-align: justify;
  color: #444;
  font-size: 16px;
}

/* 
 * \u4E00\u7EA7\u6807\u9898 - \u6E10\u53D8\u6D41\u5149\u6587\u5B57
 * \u4F7F\u7528 background-clip \u5B9E\u73B0\u6587\u5B57\u6E10\u53D8
 */
#wemd h1 {
  margin-top: 60px;
  margin-bottom: 50px;
  text-align: center;
}

#wemd h1 .content {
  font-size: 26px;
  font-weight: 800;
  display: inline-block;
  /* \u6838\u5FC3\u6E10\u53D8\u8272\uFF1A\u84DD -> \u7D2B -> \u7C89 */
  background-image: linear-gradient(135deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  /* \u6587\u5B57\u900F\u660E\uFF0C\u900F\u51FA\u80CC\u666F */
  line-height: 1.4;
  padding-bottom: 10px;
  /* \u5E95\u90E8\u52A0\u4E00\u6761\u6781\u7EC6\u7684\u6E10\u53D8\u7EBF */
  border-bottom: 2px solid #eee;
  border-image: linear-gradient(135deg, #4158D0 0%, #C850C0 100%) 1;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
  display: none;
}

/* 
 * \u4E8C\u7EA7\u6807\u9898 - \u60AC\u6D6E\u6E10\u53D8\u6309\u94AE
 * \u770B\u8D77\u6765\u50CF\u4E00\u4E2A\u7CBE\u81F4\u7684 APP \u56FE\u6807\u6216\u6309\u94AE
 */
#wemd h2 {
  margin-top: 60px;
  margin-bottom: 30px;
  text-align: left;
}

#wemd h2 .content {
  display: inline-block;
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  /* \u767D\u5B57 */
  /* \u540C\u6837\u7684\u6781\u5149\u6E10\u53D8\u80CC\u666F */
  background-image: linear-gradient(90deg, #4158D0 0%, #C850C0 100%);
  padding: 8px 18px;
  border-radius: 20px 20px 20px 4px;
  /* \u4E0D\u5BF9\u79F0\u5706\u89D2\uFF0C\u66F4\u7075\u52A8 */
  box-shadow: 0 8px 16px rgba(200, 80, 192, 0.3);
  /* \u5F69\u8272\u5F25\u6563\u6295\u5F71 */
  line-height: 1.2;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
  display: none;
}

/* 
 * \u4E09\u7EA7\u6807\u9898 - \u6E10\u53D8\u4E0B\u5212\u7EBF
 */
#wemd h3 {
  margin-top: 35px;
  margin-bottom: 15px;
}

#wemd h3 .content {
  font-size: 17px;
  font-weight: 700;
  color: #333;
  display: inline-block;
  position: relative;
  /* \u4F7F\u7528 background \u6A21\u62DF\u53EA\u6709\u4E00\u534A\u9AD8\u5EA6\u7684\u4E0B\u5212\u7EBF */
  background: linear-gradient(90deg, rgba(65, 88, 208, 0.2) 0%, rgba(200, 80, 192, 0.2) 100%);
  background-size: 100% 40%;
  /* \u5BBD\u5EA6100%\uFF0C\u9AD8\u5EA640% */
  background-repeat: no-repeat;
  background-position: 0 90%;
  /* \u4F4D\u4E8E\u5E95\u90E8 */
  padding: 0 4px;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
  display: none;
}

/* 
 * \u56DB\u7EA7\u6807\u9898 - \u6781\u7B80\u5706\u70B9
 */
#wemd h4 {
  margin-top: 24px;
  margin-bottom: 12px;
  text-align: left;
}

#wemd h4 .content {
  display: inline-block;
  font-size: 16px;
  font-weight: 700;
  color: #4158D0;
  background-color: #f0f2ff;
  padding: 4px 12px;
  border-radius: 12px;
  line-height: 1.4;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
  display: none;
}

/* 
 * \u5217\u8868 - \u70AB\u5F69\u5706\u70B9
 */
#wemd ul {
  list-style-type: disc;
  padding-left: 20px;
  margin: 20px 0;
  color: #C850C0;
  /* \u5217\u8868\u7B26\u53F7\u7C89\u7D2B\u8272 */
}

#wemd ul li {
  margin-bottom: 10px;
  line-height: 1.8;
}

#wemd li section {
  color: #444;
  /* \u6B63\u6587\u6DF1\u7070 */
  font-size: 16px;
}

/* \u6709\u5E8F\u5217\u8868 - \u6E10\u53D8\u8272\u6570\u5B57 (\u901A\u8FC7\u989C\u8272\u6A21\u62DF) */
#wemd ol {
  list-style-type: decimal;
  padding-left: 20px;
  margin: 20px 0;
  color: #4158D0;
  /* \u6570\u5B57\u6DF1\u84DD */
  font-weight: bold;
}

#wemd ul ul {
  list-style-type: circle;
  color: #4158D0;
  margin-top: 8px;
}

#wemd ol ol {
  list-style-type: lower-roman;
  color: #C850C0;
}

#wemd ol li {
  margin-bottom: 10px;
  line-height: 1.8;
}

#wemd ol li section {
  color: #444;
  font-weight: normal;
  font-size: 16px;
}

/* 
 * \u5F15\u7528 - \u78E8\u7802\u73BB\u7483\u5361\u7247
 * \u767D\u5E95 + \u67D4\u548C\u5F69\u8272\u6295\u5F71 + \u7EC6\u5FAE\u8FB9\u6846
 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
  margin: 36px 0;
  padding: 24px;
  background-color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.8);
  /* \u5173\u952E\uFF1A\u53CC\u91CD\u6295\u5F71\uFF0C\u4E00\u5C42\u767D\u5149\uFF0C\u4E00\u5C42\u5F69\u5149 */
  box-shadow: -4px -4px 10px rgba(255, 255, 255, 0.8), 4px 4px 20px rgba(65, 88, 208, 0.1);
  border-radius: 16px;
  /* \u9876\u90E8\u6E10\u53D8\u88C5\u9970\u6761 */
  border-top: 4px solid #C850C0;
  overflow: visible !important;
}

#wemd .multiquote-1 p,
#wemd .multiquote-2 p,
#wemd .multiquote-3 p {
  margin: 0;
  color: #555;
  font-size: 15px;
  line-height: 1.8;
}

/* \u94FE\u63A5 - \u6E10\u53D8\u865A\u7EBF */
#wemd a {
  color: #C850C0;
  text-decoration: none;
  border-bottom: 1px dashed #C850C0;
  font-weight: 600;
  padding-bottom: 1px;
}

/* 
 * \u52A0\u7C97 - \u6E10\u53D8\u6587\u5B57
 * \u4E0E H1 \u547C\u5E94\uFF0C\u975E\u5E38\u9AD8\u7EA7
 */
#wemd strong {
  font-weight: 700;
  background-image: linear-gradient(135deg, #4158D0 0%, #C850C0 100%);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  /* \u6587\u5B57\u900F\u660E\uFF0C\u663E\u793A\u6E10\u53D8 */
  /* \u517C\u5BB9\u6027\u56DE\u9000\uFF1A\u5982\u679C\u4E0D\u652F\u6301\u6E10\u53D8\u6587\u5B57\uFF0C\u4F1A\u663E\u793A\u4E0A\u9762\u7684 color (\u8FD9\u91CC\u8BBE\u4E3A transparent \u9700\u6CE8\u610F) */
  /* \u4E3A\u4E86\u517C\u5BB9\uFF0C\u6211\u4EEC\u53EF\u4EE5\u8BBE\u4E00\u4E2A color fallback\uFF0C\u4F46\u5728 CSS \u4E2D\u5F88\u96BE\u8986\u76D6 transparent */
  /* \u5FAE\u4FE1\u73AF\u5883\u5B8C\u5168\u652F\u6301 background-clip: text */
  margin: 0 1px;
}

/* \u659C\u4F53 */
#wemd em {
  color: #C850C0;
  font-style: italic;
}

#wemd em strong {
  color: #C850C0;
}

/* \u9AD8\u4EAE - \u6E10\u53D8\u80CC\u666F */
#wemd mark {
    background: linear-gradient(135deg, rgba(65, 88, 208, 0.15), rgba(200, 80, 192, 0.15));
    color: #4158D0;
    padding: 2px 4px;
    border-radius: 3px;
}

/* \u5220\u9664\u7EBF - \u6E10\u53D8\u8272 */
#wemd del {
    text-decoration: line-through;
    color: #999;
    text-decoration-color: #C850C0;
}

/* \u5206\u9694\u7EBF - \u6E10\u53D8\u5149\u675F */
#wemd hr {
  margin: 60px auto;
  border: 0;
  height: 2px;
  background-image: linear-gradient(90deg, rgba(247, 249, 252, 0) 0%, #C850C0 50%, rgba(247, 249, 252, 0) 100%);
  width: 80%;
}

/* \u56FE\u7247 - \u60AC\u6D6E\u6295\u5F71 */
#wemd img {
  display: block;
  margin: 40px auto;
  width: 100%;
  border-radius: 12px;
  /* \u67D4\u548C\u7684\u5F69\u8272\u6295\u5F71 */
  box-shadow: 0 15px 35px rgba(65, 88, 208, 0.12);
}

/* \u884C\u5185\u4EE3\u7801 - \u6C14\u6CE1\u98CE\u683C */
#wemd p code,
#wemd li code {
  color: #4158D0;
  background: #f0f2ff;
  border: 1px solid rgba(65, 88, 208, 0.1);
  padding: 3px 6px;
  margin: 0 4px;
  border-radius: 6px;
  font-size: 14px;
  font-family: sans-serif;
}

/* \u4EE3\u7801\u5757 - \u6781\u7B80\u6DF1\u8272\u5706\u89D2 */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
  display: block;
  padding: 20px;
  background: #282c34;
  /* \u7ECF\u5178\u7684 Atom One Dark */
  color: #abb2bf;
  /* \u9ED8\u8BA4\u6587\u5B57\u989C\u8272 */
  font-size: 13px;
  line-height: 1.6;
  border-radius: 12px;
  font-family: sans-serif;
  overflow-x: auto;
  white-space: pre;
  min-width: max-content;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
}

/* \u4F18\u5316\u6DF1\u8272\u80CC\u666F\u4E0B\u7684\u8BED\u6CD5\u9AD8\u4EAE\u989C\u8272 */
#wemd pre code.hljs .hljs-comment,
#wemd pre code.hljs .hljs-quote {
  color: #5c6370;
}

#wemd pre code.hljs .hljs-keyword,
#wemd pre code.hljs .hljs-selector-tag {
  color: #c678dd;
  font-weight: bold;
}

#wemd pre code.hljs .hljs-string,
#wemd pre code.hljs .hljs-doctag {
  color: #98c379;
}

#wemd pre code.hljs .hljs-number,
#wemd pre code.hljs .hljs-literal {
  color: #d19a66;
}

#wemd pre code.hljs .hljs-title,
#wemd pre code.hljs .hljs-section {
  color: #61afef;
  font-weight: bold;
}

#wemd pre code.hljs .hljs-built_in,
#wemd pre code.hljs .hljs-builtin-name {
  color: #e06c75;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u7070\u8272 */
#wemd pre code:not(.hljs) {
  color: #abb2bf;
  background: #282c34;
}

/* \u8868\u683C - \u6E05\u65B0\u98CE\u683C */
#wemd table {
  width: 100%;
  border-collapse: collapse;
  margin: 40px 0;
  font-size: 14px;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.03);
  border: 1px solid #f0f0f0;
}

#wemd table tr th {
  background: #f4f6f9;
  color: #4158D0;
  font-weight: 700;
  border: 1px solid #f0f0f0;
  padding: 12px 10px;
  text-align: left;
}

#wemd table tr td {
  border: 1px solid #f0f0f0;
  padding: 12px 10px;
  color: #555;
  background: #fff;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
  color: #4158D0;
}

#wemd .footnotes-sep {
  border-top: 1px solid #eee;
  padding-top: 20px;
  margin-top: 60px;
  font-size: 12px;
  color: #ccc;
  text-align: center;
}

#wemd .footnote-num {
  font-weight: bold;
  color: #fff;
  background: #C850C0;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  display: inline-block;
  text-align: center;
  line-height: 16px;
  font-size: 11px;
  margin-right: 4px;
}

#wemd .footnote-item p {
  color: #999;
  font-size: 12px;
  margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
  max-width: 100% !important;
}

#wemd .inline-equation svg {
  max-width: 100%;
  vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u6781\u5149\u73BB\u7483\u98CE\u683C */
#wemd .callout {
  margin: 30px 0;
  padding: 20px;
  background: rgba(255, 255, 255, 0.8);
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 8px 20px rgba(65, 88, 208, 0.1);
}

#wemd .callout-title {
  font-weight: 700;
  margin-bottom: 10px;
  background: linear-gradient(135deg, #4158D0, #C850C0);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  font-size: 16px;
}

#wemd .callout-icon {
  margin-right: 6px;
}

#wemd .callout-note {
  border-left: 4px solid #6366f1;
}

#wemd .callout-tip {
  border-left: 4px solid #C850C0;
}

#wemd .callout-important {
  border-left: 4px solid #4158D0;
}

#wemd .callout-warning {
  border-left: 4px solid #FFCC70;
}

#wemd .callout-caution {
  border-left: 4px solid #ef4444;
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/bauhaus.js
var require_bauhaus = __commonJS({
  "../../packages/core/dist/themes/bauhaus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bauhausTheme = void 0;
    exports.bauhausTheme = `/* \u5305\u8C6A\u65AF\u98CE\u683C */
#wemd {
    padding: 30px 22px;
    max-width: 677px;
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, "Microsoft YaHei", sans-serif;
    color: #111;
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    /* \u9876\u90E8\u7EA2\u84DD\u6761\u88C5\u9970 */
    border-top: 8px solid #D32F2F;
    border-bottom: 8px solid #1976D2;
    word-break: break-word;
}

#wemd p {
    margin: 24px 0;
    line-height: 1.8;
    text-align: justify;
    color: #333;
    font-size: 16px;
}

/* \u4E00\u7EA7\u6807\u9898 - \u7EA2\u8272\u51E0\u4F55\u5757 */
#wemd h1 {
    margin: 60px 0 40px;
    text-align: left;
}

#wemd h1 .content {
    font-size: 26px;
    font-weight: 900;
    color: #fff;
    background: #D32F2F;
    padding: 15px 25px;
    display: inline-block;
    /* \u7B80\u5355\u7684\u76F4\u89D2\u77E9\u5F62+\u786C\u9634\u5F71\uFF0C\u517C\u5BB9\u6027\u6700\u597D\u4E14\u6709\u529B */
    box-shadow: 6px 6px 0 #111;
    border: 2px solid #111;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 - \u84DD\u8272\u5706\u5F62\u5F15\u5BFC */
#wemd h2 {
    margin: 50px 0 25px;
    text-align: left;
    display: flex;
    align-items: center;
}

#wemd h2 .content {
    font-size: 20px;
    font-weight: bold;
    color: #111;
    position: relative;
    padding-left: 20px;
    border-left: 10px solid #1976D2;
    /* \u84DD\u8272\u7AD6\u6761 */
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 - \u9EC4\u8272\u4E0B\u5212\u7EBF */
#wemd h3 {
    margin: 30px 0 15px;
}

#wemd h3 .content {
    font-size: 18px;
    font-weight: bold;
    color: #111;
    border-bottom: 5px solid #FBC02D;
    display: inline-block;
    padding-bottom: 2px;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 */
#wemd h4 {
    margin: 20px 0 10px;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: bold;
    color: #1976D2;
    background: #eee;
    padding: 4px 8px;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5F15\u7528 - \u51E0\u4F55\u6846 */
#wemd .multiquote-1 {
    margin: 30px 0;
    padding: 20px;
    background: #f9f9f9;
    border: 2px solid #111;
    box-shadow: 5px 5px 0 #D32F2F;
}

#wemd .multiquote-1 p {
    color: #333;
    margin: 0;
    line-height: 1.7;
}

#wemd .multiquote-2 {
    margin: 28px 0;
    padding: 20px;
    background: #fff;
    border: 2px solid #111;
    box-shadow: 4px 4px 0 #1976D2;
}

#wemd .multiquote-2 p {
    color: #333;
    margin: 0;
}

#wemd .multiquote-3 {
    margin: 26px 0;
    padding: 18px;
    background: #fff;
    border: 2px solid #111;
    box-shadow: 3px 3px 0 #FBC02D;
}

#wemd .multiquote-3 p {
    color: #333;
    margin: 0;
}

/* \u5217\u8868 */
#wemd ul {
    list-style: square;
    padding-left: 20px;
    margin: 20px 0;
    color: #D32F2F;
}

/* \u6709\u5E8F\u5217\u8868 - \u7C97\u9ED1\u6570\u5B57 */
#wemd ol {
    list-style: decimal;
    padding-left: 20px;
    margin: 20px 0;
    color: #D32F2F;
    font-weight: bold;
}

#wemd ul ul {
    list-style-type: circle;
    color: #1976D2;
    margin-top: 8px;
}

#wemd ol ol {
    list-style-type: lower-alpha;
    color: #D32F2F;
}

#wemd li section {
    color: #333;
    font-weight: normal;
}

/* \u94FE\u63A5 - \u84DD\u8272\u80CC\u666F\u9AD8\u4EAE */
#wemd a {
    color: #111;
    text-decoration: none;
    background-color: rgba(25, 118, 210, 0.2);
    border-bottom: 1px solid #1976D2;
    padding: 0 2px;
    font-weight: bold;
}

/* \u52A0\u7C97 - \u7EA2\u8272 */
#wemd strong {
    color: #D32F2F;
    font-weight: 900;
}

/* \u659C\u4F53 - \u84DD\u8272 */
#wemd em {
    font-style: italic;
    color: #1976D2;
    font-weight: bold;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    color: #D32F2F;
    font-weight: 900;
}

/* \u9AD8\u4EAE - \u9EC4\u8272\u5757 */
#wemd mark {
    background: #FBC02D;
    color: #000;
    padding: 2px 6px;
    font-weight: bold;
}

/* \u5220\u9664\u7EBF - \u7C97\u7EA2\u7EBF */
#wemd del {
    text-decoration: line-through;
    text-decoration-thickness: 2px;
    text-decoration-color: #D32F2F;
    color: #666;
}

/* \u5206\u5272\u7EBF - \u7C97\u9ED1\u7EBF */
#wemd hr {
    margin: 40px 0;
    border: none;
    height: 4px;
    background: #000;
}

/* 
 * \u884C\u5185\u4EE3\u7801 - \u9EC4\u8272\u9AD8\u4EAE (\u4FEE\u590D\u91CD\u70B9) 
 * \u4EAE\u9EC4\u80CC\u666F + \u9ED1\u8272\u6587\u5B57 + \u7C97\u4F53
 */
#wemd p code,
#wemd li code {
    background: #FBC02D;
    /* \u5305\u8C6A\u65AF\u9EC4 */
    color: #000;
    /* \u7EAF\u9ED1\u5B57 */
    padding: 2px 6px;
    margin: 0 4px;
    font-size: 14px;
    font-weight: bold;
    font-family: sans-serif;
    /* \u51E0\u4F55\u611F */
}

/* \u56FE\u7247 - \u9ED1\u6846\u786C\u9634\u5F71 */
#wemd img {
    display: block;
    margin: 40px auto;
    width: 100%;
    border: 3px solid #111;
    box-shadow: 6px 6px 0 #1976D2;
    /* \u84DD\u8272\u786C\u9634\u5F71 */
}

#wemd figcaption {
    margin-top: 10px;
    text-align: center;
    color: #111;
    font-size: 14px;
    font-weight: bold;
    background: #FBC02D;
    padding: 4px 8px;
    display: inline-block;
}

/* \u4EE3\u7801\u5757 - \u6781\u7B80\u9ED1 */
#wemd pre code.hljs {
    background: #111;
    color: #f5f5f5; /* \u9ED8\u8BA4\u4EAE\u8272\u6587\u5B57 */
    padding: 20px;
    border-radius: 0;
    font-family: monospace;
    border: 2px solid #111;
}

/* \u8BED\u6CD5\u9AD8\u4EAE\u989C\u8272\u8986\u76D6 - \u786E\u4FDD\u5728\u9ED1\u8272\u80CC\u666F\u4E0A\u53EF\u8BFB */
#wemd pre code.hljs .hljs-keyword,
#wemd pre code.hljs .hljs-selector-tag,
#wemd pre code.hljs .hljs-built_in,
#wemd pre code.hljs .hljs-name,
#wemd pre code.hljs .hljs-tag {
    color: #FBC02D; /* \u5305\u8C6A\u65AF\u9EC4 */
}

#wemd pre code.hljs .hljs-string,
#wemd pre code.hljs .hljs-title,
#wemd pre code.hljs .hljs-section,
#wemd pre code.hljs .hljs-attribute,
#wemd pre code.hljs .hljs-literal,
#wemd pre code.hljs .hljs-template-tag,
#wemd pre code.hljs .hljs-template-variable,
#wemd pre code.hljs .hljs-type {
    color: #D32F2F; /* \u5305\u8C6A\u65AF\u7EA2 */
}

#wemd pre code.hljs .hljs-comment,
#wemd pre code.hljs .hljs-quote {
    color: #888; /* \u7070\u8272\u6CE8\u91CA */
}

#wemd pre code.hljs .hljs-number,
#wemd pre code.hljs .hljs-regexp,
#wemd pre code.hljs .hljs-variable,
#wemd pre code.hljs .hljs-params {
    color: #1976D2; /* \u5305\u8C6A\u65AF\u84DD */
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u9EC4\u8272 */
#wemd pre code:not(.hljs) {
    color: #FBC02D;
    background: #111;
    border: 2px solid #111;
}

/* \u8868\u683C - \u7C97\u7EBF\u7F51\u683C */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 30px 0;
    border: 2px solid #111;
}

#wemd table tr th {
    background: #1976D2;
    color: #fff;
    border: 1px solid #111;
    padding: 10px;
}

#wemd table tr td {
    border: 1px solid #111;
    padding: 10px;
    color: #333;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #1976D2;
    font-weight: bold;
}

#wemd .footnotes-sep {
    border-top: 2px solid #111;
    margin-top: 40px;
    padding-top: 20px;
}

#wemd .footnote-num {
    font-weight: 900;
    color: #fff;
    background: #D32F2F;
    padding: 2px 6px;
    margin-right: 6px;
}

#wemd .footnote-item p {
    color: #333;
    font-size: 14px;
}

/* \u63D0\u793A\u5757 - \u5305\u8C6A\u65AF\u98CE\u683C */
#wemd .callout {
    margin: 30px 0;
    padding: 20px;
    background: #f9f9f9;
    border: 2px solid #111;
    box-shadow: 5px 5px 0 #FBC02D;
    border-radius: 0;
}

#wemd .callout-title {
    font-weight: 900;
    margin-bottom: 10px;
    text-transform: uppercase;
    color: #111;
    font-size: 16px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { 
    border-left: 10px solid #1976D2; 
}

#wemd .callout-tip { 
    border-left: 10px solid #FBC02D; 
}

#wemd .callout-important { 
    border-left: 10px solid #1976D2; 
}

#wemd .callout-warning { 
    border-left: 10px solid #FBC02D; 
}

#wemd .callout-caution { 
    border-left: 10px solid #D32F2F; 
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/cyberpunk-neon.js
var require_cyberpunk_neon = __commonJS({
  "../../packages/core/dist/themes/cyberpunk-neon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cyberpunkNeonTheme = void 0;
    exports.cyberpunkNeonTheme = `/* \u8D5B\u535A\u670B\u514B\u98CE\u683C */
#wemd {
    padding: 24px 20px;
    max-width: 677px;
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, "Microsoft YaHei", sans-serif;
    color: #333;
    /* \u6DF1\u8272\u6587\u5B57\uFF0C\u517C\u5BB9\u5FAE\u4FE1 */
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u4EAE\u8272/\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* \u6B63\u6587 */
#wemd p {
    margin: 22px 0;
    line-height: 1.75;
    text-align: justify;
    color: #444;
    font-size: 16px;
}

/* \u4E00\u7EA7\u6807\u9898 - \u6545\u969C\u6846\u7EBF */
#wemd h1 {
    margin: 50px 0 40px;
    text-align: center;
}

#wemd h1 .content {
    font-size: 26px;
    font-weight: 900;
    color: #12161F;
    /* \u6DF1\u8272\u6587\u5B57 */
    display: inline-block;
    border: 2px solid #00F3FF;
    /* \u9752\u8272\u5B9E\u7EBF\u6846 */
    padding: 12px 24px;
    background: rgba(0, 243, 255, 0.1);
    /* \u786C\u9634\u5F71\u6A21\u62DF\u6545\u969C\u9519\u4F4D */
    box-shadow: 4px 4px 0px #FF00C1;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 - \u80FD\u91CF\u6761 */
#wemd h2 {
    margin: 45px 0 25px;
    text-align: left;
}

#wemd h2 .content {
    display: inline-block;
    font-size: 20px;
    font-weight: bold;
    color: #12161F;
    /* \u6DF1\u8272\u5B57 */
    background: linear-gradient(90deg, #00F3FF, #00F3FF);
    /* \u7EAF\u9752\u8272\u80CC\u666F */
    padding: 6px 16px;
    /* \u8D5B\u535A\u5207\u89D2 */
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    border-radius: 4px;
    /* \u517C\u5BB9\u56DE\u9000 */
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 - \u7B80\u5355\u9AD8\u4EAE */
#wemd h3 {
    margin: 30px 0 15px;
}

#wemd h3 .content {
    font-size: 18px;
    font-weight: bold;
    color: #FF00C1;
    /* \u7C89\u8272\u6807\u9898 */
    padding-left: 10px;
    border-left: 4px solid #FF00C1;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 - \u7EC8\u7AEF\u63D0\u793A\u7B26 */
#wemd h4 {
    margin: 24px 0 10px;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: bold;
    color: #00F3FF;
}

/* \u6A21\u62DF > \u7B26\u53F7 */
#wemd h4 .content:before {
    content: "> ";
    color: #FF00C1;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5F15\u7528 - \u7EC8\u7AEF\u6570\u636E\u5757 */
#wemd .multiquote-1 {
    margin: 30px 0;
    padding: 20px;
    background-color: rgba(0, 243, 255, 0.05);
    border: 1px solid rgba(0, 243, 255, 0.3);
    border-left: 4px solid #00F3FF;
}

#wemd .multiquote-1 p {
    color: #444;
    font-size: 14px;
    margin: 0;
    font-family: monospace;
}

#wemd .multiquote-2 {
    margin: 28px 0;
    padding: 18px;
    background: rgba(255, 184, 77, 0.05);
    border: 1px solid rgba(255, 184, 77, 0.3);
    border-left: 4px solid #FFB84D;
}

#wemd .multiquote-2 p {
    color: #444;
    font-size: 14px;
    margin: 0;
    font-family: monospace;
}

#wemd .multiquote-3 {
    margin: 26px 0;
    padding: 16px;
    background: rgba(255, 0, 193, 0.05);
    border: 1px solid rgba(255, 0, 193, 0.3);
    border-left: 4px solid #FF00C1;
}

#wemd .multiquote-3 p {
    color: #444;
    font-size: 14px;
    margin: 0;
    font-family: monospace;
}

/* \u5217\u8868 */
#wemd ul {
    list-style: disc;
    padding-left: 20px;
    color: #00F3FF;
    margin: 20px 0;
}

#wemd ol {
    list-style: decimal;
    padding-left: 20px;
    color: #FF00C1;
    font-weight: bold;
    margin: 20px 0;
}

#wemd ul ul {
    list-style-type: square;
    color: #FFB84D;
    margin-top: 8px;
}

#wemd ol ol {
    list-style-type: lower-alpha;
    color: #00F3FF;
}

#wemd li section {
    color: #444;
    font-weight: normal;
}

/* \u94FE\u63A5 - \u80FD\u91CF\u94FE\u63A5 */
#wemd a {
    color: #00F3FF;
    text-decoration: none;
    border-bottom: 1px dashed #00F3FF;
    transition: all 0.2s;
}

/* \u52A0\u7C97 - \u6545\u969C\u7C89\u9AD8\u4EAE */
#wemd strong {
    color: #FF00C1;
    font-weight: bold;
    text-shadow: 0 0 2px rgba(255, 0, 193, 0.4);
}

/* \u659C\u4F53 - \u7C89\u8272\u53D1\u5149 */
#wemd em {
    font-style: italic;
    color: #FF00C1;
    text-shadow: 0 0 3px rgba(255, 0, 193, 0.5);
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    color: #00F3FF;
    font-weight: bold;
    text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
}

/* \u9AD8\u4EAE - \u9713\u8679\u80CC\u666F */
#wemd mark {
    background: rgba(255, 0, 193, 0.2);
    color: #FF00C1;
    padding: 2px 4px;
    border: 1px solid rgba(255, 0, 193, 0.3);
    box-shadow: 0 0 5px rgba(255, 0, 193, 0.2);
}

/* \u5220\u9664\u7EBF - \u53D1\u5149\u7EBF */
#wemd del {
    text-decoration: line-through;
    text-decoration-color: #FF00C1;
    color: #666;
}

/* \u5206\u5272\u7EBF - \u9713\u8679\u7EBF */
#wemd hr {
    margin: 50px 0;
    border: none;
    height: 2px;
    background: linear-gradient(90deg, transparent, #00F3FF, transparent);
    box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
}

/* 
 * \u884C\u5185\u4EE3\u7801 - \u9ED1\u5BA2\u7EC8\u7AEF\u6307\u4EE4 (\u4FEE\u590D\u91CD\u70B9) 
 * \u7EAF\u9ED1\u5E95 + \u9752\u8272\u5B57 + \u7B49\u5BBD\u5B57\u4F53 + \u5FAE\u53D1\u5149
 */
#wemd p code,
#wemd li code {
    color: #00F3FF;
    /* \u9713\u8679\u9752 */
    background: #000000;
    /* \u7EAF\u9ED1\u80CC\u666F */
    border: 1px solid rgba(0, 243, 255, 0.3);
    /* \u5FAE\u5F31\u7684\u9752\u8272\u8FB9\u6846 */
    padding: 2px 6px;
    margin: 0 4px;
    border-radius: 4px;
    font-size: 14px;
    font-family: "Courier New", Courier, monospace;
    /* \u5F3A\u5236\u7B49\u5BBD */
    letter-spacing: 0px;
}

/* \u4EE3\u7801\u5757 - \u8D5B\u535A\u670B\u514B\u7EC8\u7AEF\u98CE\u683C */
/* \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    background: #161B22;
    /* \u7A0D\u5FAE\u4EAE\u4E00\u70B9\u7684\u6DF1\u8272\u80CC\u666F\uFF0C\u63D0\u9AD8\u53EF\u8BFB\u6027 */
    border: 1px solid #00F3FF;
    /* \u9713\u8679\u9752\u8272\u8FB9\u6846 */
    border-left: 3px solid #00F3FF;
    /* \u5DE6\u4FA7\u9713\u8679\u6761 */
    font-family: "Courier New", "Consolas", "Monaco", monospace;
    padding: 16px;
    border-radius: 4px;
    font-size: 13px;
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
    /* \u5FAE\u5999\u7684\u53D1\u5149\u6548\u679C */
    box-shadow: 
        0 0 10px rgba(0, 243, 255, 0.2),
        inset 0 0 20px rgba(0, 243, 255, 0.05);
    /* \u5916\u53D1\u5149 + \u5185\u53D1\u5149 */
    position: relative;
}

/* \u4EE3\u7801\u5757\u6545\u969C\u6548\u679C - \u6A21\u62DF\u626B\u63CF\u7EBF\uFF08\u964D\u4F4E\u900F\u660E\u5EA6\uFF0C\u4E0D\u5F71\u54CD\u53EF\u8BFB\u6027\uFF09 */
#wemd pre code.hljs::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        transparent 50%,
        rgba(0, 243, 255, 0.015) 50%
    );
    /* \u964D\u4F4E\u626B\u63CF\u7EBF\u900F\u660E\u5EA6\uFF0C\u4ECE 0.03 \u6539\u4E3A 0.015 */
    background-size: 100% 4px;
    pointer-events: none;
    border-radius: 4px;
}

/* \u589E\u5F3A\u8BED\u6CD5\u9AD8\u4EAE\u989C\u8272\u7684\u5BF9\u6BD4\u5EA6\uFF0C\u786E\u4FDD\u5728\u6DF1\u8272\u80CC\u666F\u4E0B\u6E05\u6670\u53EF\u89C1 */
/* \u57FA\u7840\u6587\u5B57\u989C\u8272 - \u786E\u4FDD\u9ED8\u8BA4\u6587\u5B57\u8DB3\u591F\u4EAE */
#wemd pre code.hljs {
    color: #E6EDF3;
    /* \u975E\u5E38\u4EAE\u7684\u7070\u767D\u8272\u4F5C\u4E3A\u9ED8\u8BA4\u6587\u5B57\u989C\u8272 */
}

#wemd pre code.hljs .hljs-comment,
#wemd pre code.hljs .hljs-quote {
    color: #8B949E;
    /* \u6CE8\u91CA\u7528\u4E2D\u7B49\u4EAE\u5EA6\u7684\u7070\u8272 */
    opacity: 0.9;
}

#wemd pre code.hljs .hljs-keyword,
#wemd pre code.hljs .hljs-selector-tag,
#wemd pre code.hljs .hljs-subst {
    color: #FF7B72;
    /* \u4EAE\u7EA2\u6A59\u8272\u5173\u952E\u5B57 */
    font-weight: bold;
}

#wemd pre code.hljs .hljs-string,
#wemd pre code.hljs .hljs-doctag {
    color: #FFA657;
    /* \u4EAE\u6A59\u8272\u5B57\u7B26\u4E32 */
}

#wemd pre code.hljs .hljs-number,
#wemd pre code.hljs .hljs-literal,
#wemd pre code.hljs .hljs-variable,
#wemd pre code.hljs .hljs-template-variable {
    color: #79C0FF;
    /* \u4EAE\u84DD\u8272\u6570\u5B57\u548C\u53D8\u91CF */
}

#wemd pre code.hljs .hljs-title,
#wemd pre code.hljs .hljs-section,
#wemd pre code.hljs .hljs-selector-id {
    color: #D2A8FF;
    /* \u4EAE\u7D2B\u8272\u51FD\u6570\u540D */
    font-weight: bold;
}

#wemd pre code.hljs .hljs-type,
#wemd pre code.hljs .hljs-class .hljs-title {
    color: #FFA657;
    /* \u6A59\u8272\u7C7B\u578B\uFF0C\u63D0\u9AD8\u5BF9\u6BD4\u5EA6 */
    font-weight: bold;
}

#wemd pre code.hljs .hljs-tag,
#wemd pre code.hljs .hljs-name,
#wemd pre code.hljs .hljs-attribute {
    color: #79C0FF;
    /* \u4EAE\u84DD\u8272\u6807\u7B7E */
}

#wemd pre code.hljs .hljs-regexp,
#wemd pre code.hljs .hljs-link {
    color: #56D4DD;
    /* \u4EAE\u9752\u8272\u6B63\u5219\u8868\u8FBE\u5F0F */
}

#wemd pre code.hljs .hljs-symbol,
#wemd pre code.hljs .hljs-bullet {
    color: #FF7B72;
    /* \u4EAE\u7EA2\u6A59\u8272\u7B26\u53F7 */
}

#wemd pre code.hljs .hljs-built_in,
#wemd pre code.hljs .hljs-builtin-name {
    color: #58A6FF;
    /* \u4EAE\u84DD\u8272\u5185\u7F6E\u51FD\u6570 */
    font-weight: bold;
}

#wemd pre code.hljs .hljs-meta {
    color: #8B949E;
    /* \u5143\u6570\u636E\u7528\u7070\u8272 */
    font-weight: bold;
}

#wemd pre code.hljs .hljs-deletion {
    background: rgba(255, 123, 114, 0.2);
    /* \u5220\u9664\u7EBF\u80CC\u666F */
    color: #FF7B72;
}

#wemd pre code.hljs .hljs-addition {
    background: rgba(121, 192, 255, 0.2);
    /* \u6DFB\u52A0\u7EBF\u80CC\u666F */
    color: #79C0FF;
}

#wemd pre code.hljs .hljs-emphasis {
    font-style: italic;
    color: #E6EDF3;
}

#wemd pre code.hljs .hljs-strong {
    font-weight: bold;
    color: #FF7B72;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u9713\u8679\u9752\u8272 */
#wemd pre code:not(.hljs) {
    color: #00F3FF;
    background: #161B22;
    border: 1px solid #00F3FF;
    border-left: 3px solid #00F3FF;
    box-shadow: 
        0 0 10px rgba(0, 243, 255, 0.2),
        inset 0 0 20px rgba(0, 243, 255, 0.05);
}

/* \u8868\u683C - \u6570\u636E\u9762\u677F */
#wemd table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin: 30px 0;
    font-size: 14px;
    border: 1px solid rgba(0, 243, 255, 0.3);
    background: transparent;
}

#wemd table tr th {
    background: rgba(0, 243, 255, 0.1);
    color: #00F3FF;
    border-bottom: 1px solid rgba(0, 243, 255, 0.3);
    padding: 10px;
    font-weight: bold;
    text-align: left;
}

#wemd table tr td {
    border-bottom: 1px solid rgba(0, 243, 255, 0.2);
    padding: 10px;
    color: #444;
    background: transparent;
}

#wemd figcaption {
    margin-top: 10px;
    text-align: center;
    color: #00F3FF;
    font-size: 13px;
    font-family: monospace;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #FF00C1;
}

#wemd .footnotes-sep {
    border-top: 1px solid #30363D;
    padding-top: 20px;
    margin-top: 40px;
    font-size: 12px;
    color: #555;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #0d1117;
    background: #00F3FF;
    margin-right: 4px;
    font-size: 11px;
    padding: 1px 4px;
}

#wemd .footnote-item p {
    color: #666;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F - \u4FDD\u6301\u9ED8\u8BA4\u989C\u8272\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u4EAE\u8272/\u6DF1\u8272\u6A21\u5F0F */
#wemd .block-equation svg,
#wemd .katex-block svg,
#wemd mjx-container[display="true"] svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg,
#wemd .katex-inline svg,
#wemd mjx-container:not([display="true"]) svg {
    max-width: 100%;
    vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u8D5B\u535A\u670B\u514B\u98CE\u683C */
#wemd .callout {
    margin: 30px 0;
    padding: 20px;
    background: rgba(0, 243, 255, 0.05);
    border: 1px solid rgba(0, 243, 255, 0.2);
    border-radius: 4px;
    color: #444;
}

#wemd .callout-title {
    font-weight: bold;
    margin-bottom: 10px;
    color: #00F3FF;
    text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
    font-size: 16px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { 
    border-left: 3px solid #00F3FF;
    box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
}

#wemd .callout-tip { 
    border-left: 3px solid #FF00C1;
    box-shadow: 0 0 10px rgba(255, 0, 193, 0.2);
}

#wemd .callout-important { 
    border-left: 3px solid #00F3FF;
    box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
}

#wemd .callout-warning { 
    border-left: 3px solid #FFB84D;
    box-shadow: 0 0 10px rgba(255, 184, 77, 0.2);
}

#wemd .callout-caution { 
    border-left: 3px solid #FF00C1;
    box-shadow: 0 0 10px rgba(255, 0, 193, 0.2);
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/knowledge-base.js
var require_knowledge_base = __commonJS({
  "../../packages/core/dist/themes/knowledge-base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.knowledgeBaseTheme = void 0;
    exports.knowledgeBaseTheme = `/* \u77E5\u8BC6\u5E93\u98CE\u683C */
#wemd {
    padding: 30px 24px;
    max-width: 677px;
    margin: 0 auto;
    /* \u4F7F\u7528\u7CFB\u7EDF\u65E0\u886C\u7EBF\u5B57\u4F53\uFF0C\u4FDD\u6301\u5E72\u51C0\u5229\u843D */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "PingFang SC", sans-serif;
    color: #37352F;
    /* \u7ECF\u5178\u7684\u7B14\u8BB0\u6DF1\u7070\u8272 */
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* \u6BB5\u843D - \u7D27\u51D1\u4F46\u8212\u9002 */
#wemd p {
    margin-top: 16px;
    margin-bottom: 16px;
    line-height: 1.75;
    letter-spacing: 0.2px;
    text-align: justify;
    color: #37352F;
    font-size: 16px;
}

/* 
 * \u4E00\u7EA7\u6807\u9898 - \u9875\u9762\u6807\u9898\u611F
 * \u5C31\u50CF\u7B14\u8BB0\u9875\u9762\u7684\u6700\u9876\u7AEF\u6807\u9898
 */
#wemd h1 {
    margin-top: 50px;
    margin-bottom: 40px;
    text-align: left;
    border-bottom: 1px solid #E3E2E0;
    /* \u6781\u7EC6\u7684\u5206\u5272\u7EBF */
    padding-bottom: 20px;
}

#wemd h1 .content {
    font-size: 28px;
    font-weight: 700;
    color: #37352F;
    display: inline-block;
    line-height: 1.2;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* 
 * \u4E8C\u7EA7\u6807\u9898 - \u533A\u5757\u5206\u5272
 * \u5E26\u6709\u6D45\u7070\u8272\u80CC\u666F\u6761\uFF0C\u7C7B\u4F3C Notion \u7684 H1 block
 */
#wemd h2 {
    margin-top: 40px;
    margin-bottom: 20px;
    text-align: left;
}

#wemd h2 .content {
    display: block;
    /* \u5360\u6EE1\u6574\u884C */
    font-size: 22px;
    font-weight: 600;
    color: #37352F;
    padding: 8px 12px;
    background-color: #F7F6F3;
    /* \u7ECF\u5178\u7684\u6D45\u7070\u5E95\u8272 */
    border-radius: 4px;
    line-height: 1.3;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* 
 * \u4E09\u7EA7\u6807\u9898 - \u91CD\u70B9\u6807\u8BB0
 * \u50CF\u662F\u7ED9\u6587\u5B57\u52A0\u4E86\u989C\u8272\u6807\u8BB0
 */
#wemd h3 {
    margin-top: 30px;
    margin-bottom: 12px;
}

#wemd h3 .content {
    font-size: 18px;
    font-weight: 600;
    color: #37352F;
    display: inline-block;
    /* \u5E95\u90E8\u5C40\u90E8\u9AD8\u4EAE */
    border-bottom: 3px solid #FDECC8;
    /* \u5976\u9EC4\u8272 */
    padding-bottom: 2px;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 - \u5C0F\u8282 */
#wemd h4 {
    margin-top: 24px;
    margin-bottom: 8px;
    text-align: left;
}

#wemd h4 .content {
    display: inline-block;
    font-size: 16px;
    font-weight: 600;
    color: #EB5757;
    /* \u9192\u76EE\u7684\u7EA2\u8272\uFF0C\u7528\u4E8E\u8B66\u793A\u6216\u5F3A\u8C03 */
    line-height: 1.4;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* 
 * \u5217\u8868 - \u7ED3\u6784\u5316\u7F29\u8FDB
 */
#wemd ul {
    list-style-type: disc;
    padding-left: 24px;
    margin: 16px 0;
    color: #37352F;
}

#wemd ul li {
    margin-bottom: 8px;
    line-height: 1.7;
}

#wemd li section {
    color: #37352F;
    font-size: 16px;
}

/* \u6709\u5E8F\u5217\u8868 */
#wemd ol {
    list-style-type: decimal;
    padding-left: 24px;
    margin: 16px 0;
    color: #37352F;
    font-weight: 600;
}

#wemd ul ul {
    list-style-type: circle;
    margin-top: 6px;
}

#wemd ol ol {
    list-style-type: lower-alpha;
}

#wemd ol li {
    margin-bottom: 8px;
    line-height: 1.7;
}

#wemd ol li section {
    color: #37352F;
    font-weight: normal;
    font-size: 16px;
}

/* 
 * \u5F15\u7528 - Callout \u63D0\u793A\u6846\u98CE\u683C
 * \u8FD9\u662F\u8FD9\u6B3E\u4E3B\u9898\u7684\u7075\u9B42
 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
    margin: 24px 0;
    padding: 16px 16px 16px 20px;
    background-color: #F1F1EF;
    /* \u9ED8\u8BA4\u6D45\u7070\u80CC\u666F */
    border: none;
    /* \u65E0\u8FB9\u6846 */
    border-radius: 4px;
    border-left: 4px solid #37352F;
    /* \u5DE6\u4FA7\u6DF1\u8272\u5F3A\u63D0\u793A */
    overflow: visible !important;
}

/* \u9488\u5BF9\u4E0D\u540C\u5C42\u7EA7\u5F15\u7528\uFF0C\u7ED9\u4E88\u4E0D\u540C\u989C\u8272\uFF0C\u6A21\u62DF Info/Warning */
#wemd .multiquote-2 {
    background-color: #E7F3F8;
    /* \u6D45\u84DD\u80CC\u666F (Info) */
    border-left-color: #2D9CDB;
}

#wemd .multiquote-3 {
    background-color: #FDF5F2;
    /* \u6D45\u6A59\u80CC\u666F (Warning) */
    border-left-color: #F2994A;
}

#wemd .multiquote-1 p,
#wemd .multiquote-2 p,
#wemd .multiquote-3 p {
    margin: 0;
    color: #37352F;
    font-size: 15px;
    line-height: 1.6;
}

/* \u94FE\u63A5 - \u7B80\u6D01\u4E0B\u5212\u7EBF */
#wemd a {
    color: #37352F;
    text-decoration: none;
    border-bottom: 1px solid #999;
    /* \u7070\u8272\u4E0B\u5212\u7EBF */
    font-weight: 500;
    transition: border-color 0.2s;
}

/* 
 * \u52A0\u7C97 - \u9EC4\u8272\u9AD8\u5149\u7B14
 * \u5B8C\u5168\u590D\u523B Notion \u7684 Highlight \u6548\u679C
 */
#wemd strong {
    color: #37352F;
    font-weight: 600;
    background-color: #FDECC8;
    /* \u9AD8\u4EAE\u9EC4 */
    padding: 2px 4px;
    margin: 0 2px;
    border-radius: 3px;
}

/* \u659C\u4F53 */
#wemd em {
    color: #37352F;
    font-style: italic;
    opacity: 0.7;
}

#wemd em strong {
    color: #37352F;
    opacity: 1;
}

/* \u9AD8\u4EAE - \u9EC4\u8272\u6807\u8BB0 */
#wemd mark {
    background: #FDECC8;
    color: #37352F;
    padding: 2px 4px;
    border-radius: 3px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #999;
}

/* \u5206\u9694\u7EBF */
#wemd hr {
    margin: 40px auto;
    border: 0;
    height: 1px;
    background-color: #E3E2E0;
    /* \u6781\u6D45\u7070 */
    width: 100%;
}

/* \u56FE\u7247 - \u5E72\u51C0\u65E0\u9634\u5F71 */
#wemd img {
    display: block;
    margin: 30px auto;
    width: 100%;
    border-radius: 4px;
    box-shadow: none;
    /* \u7B14\u8BB0\u98CE\u683C\u901A\u5E38\u4E0D\u9700\u8981\u9634\u5F71 */
    border: 1px solid #E3E2E0;
    /* \u53EA\u6709\u4E00\u5708\u7EC6\u7EBF */
}

#wemd figcaption {
    margin-top: 8px;
    text-align: center;
    color: #999;
    font-size: 14px;
}

/* 
 * \u884C\u5185\u4EE3\u7801 - \u7ECF\u5178\u7684\u7EA2\u5B57\u7070\u5E95
 */
#wemd p code,
#wemd li code {
    color: #EB5757;
    /* \u7EA2\u8272\u6587\u5B57 */
    background: rgba(135, 131, 120, 0.15);
    /* \u534A\u900F\u660E\u7070\u5E95 */
    border: none;
    padding: 3px 6px;
    margin: 0 4px;
    border-radius: 4px;
    font-size: 14px;
    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
}

/* \u4EE3\u7801\u5757 - \u6781\u7B80\u7070 */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    display: block;
    padding: 20px;
    background: #F7F6F3;
    /* color \u7531 .hljs \u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
    font-size: 13px;
    line-height: 1.6;
    border-radius: 4px;
    font-family: "SFMono-Regular", Consolas, Menlo, monospace;
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
    border: none;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u6DF1\u7070\u8272 */
#wemd pre code:not(.hljs) {
    color: #37352F;
    background: #F7F6F3;
}

/* \u8868\u683C - \u6570\u636E\u5E93\u98CE\u683C (Database) */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 30px 0;
    font-size: 14px;
    border: 1px solid #E3E2E0;
    border-radius: 0;
}

#wemd table tr th {
    background: #F7F6F3;
    color: #37352F;
    font-weight: 600;
    border: 1px solid #E3E2E0;
    padding: 10px 12px;
    text-align: left;
}

#wemd table tr td {
    border: 1px solid #E3E2E0;
    padding: 10px 12px;
    color: #37352F;
    background: #fff;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #37352F;
    text-decoration: underline;
}

#wemd .footnotes-sep {
    border-top: 1px solid #E3E2E0;
    padding-top: 20px;
    margin-top: 50px;
    font-size: 12px;
    color: #999;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #37352F;
    margin-right: 4px;
}

#wemd .footnote-item p {
    color: #666;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
}


/* \u63D0\u793A\u5757 - \u77E5\u8BC6\u5E93\u98CE\u683C */
#wemd .callout {
    margin: 24px 0;
    padding: 16px 16px 16px 20px;
    border-radius: 4px;
    border-left: 4px solid #37352F;
}

#wemd .callout-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: #37352F;
    font-size: 15px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { 
    background: #F1F1EF;
    border-left-color: #37352F;
}

#wemd .callout-tip { 
    background: #FDF5F2;
    border-left-color: #F2994A;
}

#wemd .callout-important { 
    background: #E7F3F8;
    border-left-color: #2D9CDB;
}

#wemd .callout-warning { 
    background: #FFF4E5;
    border-left-color: #FF9800;
}

#wemd .callout-caution { 
    background: #FFEBEE;
    border-left-color: #F44336;
}

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/luxury-gold.js
var require_luxury_gold = __commonJS({
  "../../packages/core/dist/themes/luxury-gold.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.luxuryGoldTheme = void 0;
    exports.luxuryGoldTheme = `/* \u9ED1\u91D1\u5962\u534E\u98CE\u683C */
#wemd {
    padding: 40px 22px;
    max-width: 677px;
    margin: 0 auto;
    /* \u5F3A\u5236\u5B8B\u4F53/\u886C\u7EBF\u4F53\uFF0C\u79FB\u52A8\u7AEF\u663E\u793A\u4F18\u96C5\u5B57\u4F53\u7684\u5173\u952E */
    font-family: "Songti SC", "SimSun", "STSong", "Georgia", serif;
    color: #222;
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* \u6B63\u6587 - \u758F\u6717\u7684\u884C\u95F4\u8DDD */
#wemd p {
    margin: 30px 0;
    line-height: 2.0;
    text-align: justify;
    color: #444;
    font-size: 16px;
}

/* \u4E00\u7EA7\u6807\u9898 - \u6781\u7B80\u7559\u767D */
#wemd h1 {
    margin: 70px 0 50px;
    text-align: center;
}

#wemd h1 .content {
    font-size: 26px;
    font-weight: normal;
    color: #000;
    display: block;
    letter-spacing: 3px;
    border-bottom: 1px solid #000;
    /* \u7EAF\u9ED1\u7EC6\u7EBF */
    padding-bottom: 20px;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 - \u91D1\u8272\u8FB9\u6846\u76D2\u5B50 */
#wemd h2 {
    margin: 50px 0 30px;
    text-align: center;
}

#wemd h2 .content {
    display: inline-block;
    font-size: 19px;
    font-weight: normal;
    color: #9E8045;
    /* \u590D\u53E4\u91D1 */
    border-top: 1px solid #9E8045;
    border-bottom: 1px solid #9E8045;
    padding: 10px 24px;
    letter-spacing: 1px;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 - \u7EAF\u9ED1\u5927\u5199\u611F */
#wemd h3 {
    margin: 40px 0 20px;
    text-align: center;
}

#wemd h3 .content {
    font-size: 17px;
    font-weight: bold;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 1px;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 - \u91D1\u8272\u5C0F\u6807 */
#wemd h4 {
    margin: 30px 0 15px;
    text-align: center;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: normal;
    color: #9E8045;
    border-bottom: 1px solid #eee;
    padding-bottom: 4px;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5F15\u7528 - \u5C45\u4E2D\u886C\u7EBF\u659C\u4F53 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
    margin: 40px 0;
    padding: 20px 30px;
    background: #fff;
    /* \u4FDD\u6301\u7EAF\u767D */
    border: none;
    text-align: center;
    border-left: none;
    /* \u53BB\u6389\u9ED8\u8BA4\u5DE6\u8FB9\u6846 */
}

#wemd .multiquote-1 p {
    color: #666;
    font-style: italic;
    font-family: serif;
    font-size: 15px;
    line-height: 1.8;
}

#wemd .multiquote-2 {
    margin: 38px 0;
    padding: 18px 28px;
    background: #fff;
    border: none;
    text-align: center;
    border-left: 2px solid #9E8045;
}

#wemd .multiquote-2 p {
    color: #666;
    font-style: italic;
    font-family: serif;
    font-size: 15px;
}

#wemd .multiquote-3 {
    margin: 36px 0;
    padding: 16px 26px;
    background: #fafafa;
    border: none;
    text-align: center;
    border-left: 1px solid #9E8045;
}

#wemd .multiquote-3 p {
    color: #666;
    font-style: italic;
    font-family: serif;
    font-size: 15px;
}

/* \u5217\u8868 - \u7CBE\u81F4\u7684\u91D1\u70B9 */
#wemd ul {
    list-style: square;
    /* \u65B9\u5757\u6BD4\u5706\u70B9\u66F4\u65F6\u5C1A */
    padding-left: 20px;
    margin: 20px 0;
    color: #9E8045;
}

#wemd ul li {
    margin-bottom: 10px;
}

#wemd li section {
    color: #444;
}

/* \u6709\u5E8F\u5217\u8868 */
#wemd ol {
    list-style: decimal;
    padding-left: 20px;
    margin: 20px 0;
    color: #9E8045;
}

#wemd ul ul {
    list-style-type: circle;
    color: #9E8045;
    margin-top: 8px;
}

#wemd ol ol {
    list-style-type: lower-roman;
    color: #9E8045;
}

#wemd ol li {
    margin-bottom: 10px;
}

#wemd ol li section {
    color: #444;
}

/* \u94FE\u63A5 - \u91D1\u8272\u7EC6\u7EBF */
#wemd a {
    color: #000;
    border-bottom: 1px solid #9E8045;
    text-decoration: none;
    transition: opacity 0.2s;
}

/* \u52A0\u7C97 - \u91D1\u8272\u9AD8\u4EAE */
#wemd strong {
    color: #9E8045;
    font-weight: bold;
    margin: 0 2px;
}

/* \u659C\u4F53 */
#wemd em {
    color: #9E8045;
    font-style: italic;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    color: #9E8045;
    font-weight: bold;
}

/* \u9AD8\u4EAE - \u6DE1\u91D1\u80CC\u666F */
#wemd mark {
    background: rgba(158, 128, 69, 0.15);
    color: #9E8045;
    padding: 2px 6px;
    border-bottom: 1px solid rgba(158, 128, 69, 0.3);
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #999;
    text-decoration-color: #9E8045;
}

/* \u5206\u9694\u7EBF - \u6781\u7B80\u77ED\u7EBF */
#wemd hr {
    margin: 60px auto;
    height: 1px;
    background: #9E8045;
    width: 40px;
    border: none;
}

/* \u56FE\u7247 - \u7EAF\u51C0\u7559\u767D */
#wemd img {
    display: block;
    margin: 50px auto;
    width: 100%;
    /* \u6781\u6DE1\u7684\u9634\u5F71\uFF0C\u51E0\u4E4E\u770B\u4E0D\u89C1\uFF0C\u589E\u52A0\u4E00\u70B9\u7ACB\u4F53\u611F */
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.06);
}

#wemd figcaption {
    color: #999;
    font-size: 12px;
    margin-top: 15px;
    text-align: center;
    font-style: italic;
    font-family: serif;
}

/* 
 * \u884C\u5185\u4EE3\u7801 - \u9999\u69DF\u91D1\u540A\u724C\u98CE\u683C (\u4FEE\u590D\u91CD\u70B9) 
 * \u6781\u6DE1\u7684\u91D1\u8272\u80CC\u666F + \u7EC6\u8FB9\u6846\uFF0C\u7CBE\u81F4\u611F\u62C9\u6EE1
 */
#wemd p code,
#wemd li code {
    color: #9E8045;
    /* \u6DF1\u91D1\u8272\u6587\u5B57 */
    background: rgba(158, 128, 69, 0.06);
    /* 6%\u900F\u660E\u5EA6\u7684\u91D1\u8272\u80CC\u666F */
    border: 1px solid rgba(158, 128, 69, 0.2);
    /* 20%\u900F\u660E\u5EA6\u7684\u91D1\u8272\u8FB9\u6846 */
    padding: 2px 6px;
    margin: 0 4px;
    border-radius: 2px;
    font-size: 14px;
    font-family: serif;
    /* \u4FDD\u6301\u886C\u7EBF\u4F53\u98CE\u683C */
}

/* \u4EE3\u7801\u5757 - \u6781\u7B80\u9ED1\u767D */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    display: block;
    padding: 20px;
    background: #fcfcfc;
    /* \u63A5\u8FD1\u7EAF\u767D */
    /* color \u7531 .hljs \u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
    font-size: 13px;
    line-height: 1.6;
    border: 1px solid #eee;
    font-family: serif;
    /* \u7279\u610F\u4F7F\u7528\u886C\u7EBF\u4F53\u663E\u793A\u4EE3\u7801\uFF0C\u6781\u5177\u827A\u672F\u611F */
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u6DF1\u7070\u8272 */
#wemd pre code:not(.hljs) {
    color: #333;
    background: #fcfcfc;
    border: 1px solid #eee;
}

/* \u8868\u683C - \u6781\u7B80\u7EBF\u6761 */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 40px 0;
    font-size: 14px;
    border-top: 1px solid #000;
    border-bottom: 1px solid #000;
}

#wemd table tr th {
    color: #9E8045;
    font-weight: normal;
    border-bottom: 1px solid #eee;
    padding: 12px 10px;
    text-align: center;
}

#wemd table tr td {
    border-bottom: 1px solid #eee;
    padding: 12px 10px;
    color: #555;
    text-align: center;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #9E8045;
}

#wemd .footnotes-sep {
    border-top: 1px solid #eee;
    padding-top: 20px;
    margin-top: 60px;
    font-size: 12px;
    color: #ccc;
    text-align: center;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #9E8045;
    margin-right: 4px;
}

#wemd .footnote-item p {
    color: #999;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u9ED1\u91D1\u5962\u534E\u98CE\u683C */
#wemd .callout {
    margin: 40px 0;
    padding: 20px 30px;
    background: #fff;
    border: 1px solid rgba(158, 128, 69, 0.3);
    border-radius: 2px;
}

#wemd .callout-title {
    font-weight: normal;
    margin-bottom: 10px;
    color: #9E8045;
    font-family: serif;
    letter-spacing: 1px;
    font-size: 15px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { border-left: 3px solid #9E8045; }
#wemd .callout-tip { border-left: 3px solid #9E8045; }
#wemd .callout-important { border-left: 3px solid #9E8045; }
#wemd .callout-warning { border-left: 3px solid #D98C45; }
#wemd .callout-caution { border-left: 3px solid #B33D25; }

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/morandi-forest.js
var require_morandi_forest = __commonJS({
  "../../packages/core/dist/themes/morandi-forest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.morandiForestTheme = void 0;
    exports.morandiForestTheme = `/* \u83AB\u5170\u8FEA\u68EE\u6797\u98CE\u683C */
#wemd {
  padding: 30px 22px;
  max-width: 677px;
  margin: 0 auto;
  font-family: "Optima", "Georgia", "PingFang SC", "Microsoft YaHei", serif;
  color: #2F3E32;
  background-color: transparent;
  /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
  word-break: break-word;
}

/* \u6BB5\u843D */
#wemd p {
  margin-top: 26px;
  margin-bottom: 26px;
  line-height: 2.0;
  letter-spacing: 0.5px;
  text-align: justify;
  color: #3A4D39;
  font-size: 16px;
}

/* \u4E00\u7EA7\u6807\u9898 */
#wemd h1 {
  margin-top: 60px;
  margin-bottom: 50px;
  text-align: center;
}

#wemd h1 .content {
  display: inline-block;
  font-size: 24px;
  font-weight: normal;
  color: #1A261D;
  padding: 12px 24px;
  border: 1px solid #739072;
  border-radius: 2px;
  background-color: #F1F4F0;
  letter-spacing: 2px;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
  display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 */
#wemd h2 {
  margin-top: 50px;
  margin-bottom: 24px;
  text-align: left;
  border-bottom: 1px solid #E8EBE9;
  padding-bottom: 10px;
}

#wemd h2 .content {
  display: inline-block;
  font-size: 19px;
  font-weight: 700;
  color: #4F6F52;
  padding-left: 12px;
  border-left: 5px solid #4F6F52;
  line-height: 1.2;
  letter-spacing: 1px;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
  display: none;
}

/* \u4E09\u7EA7\u6807\u9898 */
#wemd h3 {
  margin-top: 40px;
  margin-bottom: 20px;
  text-align: center;
}

#wemd h3 .content {
  font-size: 17px;
  font-weight: bold;
  color: #739072;
  display: inline-block;
  border-bottom: 2px dotted #739072;
  padding-bottom: 4px;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
  display: none;
}

/* \u56DB\u7EA7\u6807\u9898 */
#wemd h4 {
  margin-top: 30px;
  margin-bottom: 15px;
  text-align: left;
}

#wemd h4 .content {
  display: inline-block;
  font-size: 15px;
  font-weight: 700;
  color: #fff;
  background-color: #86A789;
  padding: 4px 10px;
  border-radius: 4px;
  line-height: 1.4;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
  display: none;
}

/* \u5217\u8868 */
#wemd ul {
  list-style-type: disc;
  padding-left: 20px;
  margin: 20px 0;
  color: #86A789;
}

#wemd ul li {
  margin-bottom: 12px;
  line-height: 1.8;
}

#wemd li section {
  color: #3A4D39;
  font-size: 16px;
}

/* \u6709\u5E8F\u5217\u8868 */
#wemd ol {
  list-style-type: decimal;
  padding-left: 20px;
  margin: 20px 0;
  color: #4F6F52;
  font-weight: bold;
}

#wemd ul ul {
  list-style-type: circle;
  color: #4F6F52;
  margin-top: 8px;
}

#wemd ol ol {
  list-style-type: lower-alpha;
  color: #739072;
}

#wemd ol li {
  margin-bottom: 12px;
  line-height: 1.8;
}

#wemd ol li section {
  color: #3A4D39;
  font-weight: normal;
  font-size: 16px;
}

/* \u5F15\u7528 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
  margin: 36px 0;
  padding: 24px;
  background-color: #F6F8F6;
  border: 1px dashed #739072;
  border-radius: 8px;
  overflow: visible !important;
}

#wemd .multiquote-1 p,
#wemd .multiquote-2 p,
#wemd .multiquote-3 p {
  margin: 0;
  color: #556B58;
  font-size: 15px;
  line-height: 1.8;
  font-family: "KaiTi", "STKaiti", serif;
}

/* \u94FE\u63A5 */
#wemd a {
  color: #4F6F52;
  text-decoration: none;
  border-bottom: 1px solid #4F6F52;
  font-weight: 600;
  padding-bottom: 0px;
}

/* \u52A0\u7C97 */
#wemd strong {
  color: #1A261D;
  font-weight: 700;
  background: linear-gradient(to top, rgba(134, 167, 137, 0.4) 50%, transparent 50%);
  margin: 0 2px;
  padding: 0 2px;
}

/* \u659C\u4F53 */
#wemd em {
  color: #739072;
  font-style: italic;
}

#wemd em strong {
  color: #4F6F52;
}

/* \u9AD8\u4EAE - \u6D45\u7EFF\u80CC\u666F */
#wemd mark {
  background: linear-gradient(to top, rgba(134, 167, 137, 0.3) 50%, transparent 50%);
  color: #1A261D;
  padding: 0 2px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
  text-decoration: line-through;
  color: #889E8B;
}

/* 
 * \u5206\u9694\u7EBF 
 * \u4FEE\u590D\u4E86\u8FD9\u91CC\u65E0\u6548\u7684\u989C\u8272\u4EE3\u7801 #D2DSD4
 */
#wemd hr {
  margin: 60px auto;
  border: 0;
  height: 1px;
  background-color: #D2D4D4;
  /* \u5DF2\u4FEE\u6B63 */
  width: 60%;
}

/* \u56FE\u7247 */
#wemd img {
  display: block;
  margin: 40px auto;
  width: 100%;
  border-radius: 2px;
  box-shadow: 0 8px 20px rgba(79, 111, 82, 0.15);
  padding: 6px;
  background: #fff;
  border: 1px solid #eee;
}

#wemd figcaption {
  font-size: 13px;
  color: #889E8B;
  margin-top: 10px;
  font-family: serif;
}

/* \u884C\u5185\u4EE3\u7801 */
#wemd p code,
#wemd li code {
  color: #4F6F52;
  background: #EDF1EE;
  border: none;
  padding: 3px 6px;
  margin: 0 4px;
  border-radius: 4px;
  font-size: 14px;
  font-family: sans-serif;
}

/* \u4EE3\u7801\u5757 */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
  display: block;
  padding: 20px;
  background: #F0F2F0;
  /* color \u7531 .hljs \u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
  font-size: 13px;
  line-height: 1.6;
  border-radius: 6px;
  font-family: sans-serif;
  overflow-x: auto;
  white-space: pre;
  min-width: max-content;
  border: 1px solid #DCE3DD;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u6DF1\u7EFF\u8272 */
#wemd pre code:not(.hljs) {
  color: #3A4D39;
  background: #F0F2F0;
  border: 1px solid #DCE3DD;
}

/* 
 * \u8868\u683C 
 * \u4FEE\u590D\u4E86\u8FD9\u91CC\u65E0\u6548\u7684\u989C\u8272\u4EE3\u7801 #D2DSD4
 */
#wemd table {
  width: 100%;
  border-collapse: collapse;
  margin: 40px 0;
  font-size: 14px;
  border: 1px solid #D2D4D4;
  /* \u5DF2\u4FEE\u6B63 */
}

#wemd table tr th {
  background: #EDF1EE;
  color: #4F6F52;
  font-weight: 700;
  border: 1px solid #D2D4D4;
  /* \u5DF2\u4FEE\u6B63 */
  padding: 12px 10px;
  text-align: left;
}

#wemd table tr td {
  border: 1px solid #D2D4D4;
  /* \u5DF2\u4FEE\u6B63 */
  padding: 12px 10px;
  color: #555;
  background: #fff;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
  color: #4F6F52;
}

#wemd .footnotes-sep {
  border-top: 1px solid #E8EBE9;
  padding-top: 20px;
  margin-top: 60px;
  font-size: 12px;
  color: #B0BEB3;
  text-align: center;
}

#wemd .footnote-num {
  font-weight: bold;
  color: #739072;
  margin-right: 4px;
}

#wemd .footnote-item p {
  color: #889E8B;
  font-size: 12px;
  margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
  max-width: 100% !important;
}

#wemd .inline-equation svg {
  max-width: 100%;
  vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u83AB\u5170\u8FEA\u68EE\u6797\u98CE\u683C */
#wemd .callout {
  margin: 30px 0;
  padding: 20px;
  background: #F6F8F6;
  border: 1px dashed #739072;
  border-radius: 8px;
}

#wemd .callout-title {
  font-weight: 700;
  margin-bottom: 10px;
  color: #4F6F52;
  font-size: 15px;
}

#wemd .callout-icon {
  margin-right: 6px;
}

#wemd .callout-note { border-left: 4px solid #739072; }
#wemd .callout-tip { border-left: 4px solid #86A789; }
#wemd .callout-important { border-left: 4px solid #4F6F52; }
#wemd .callout-warning { border-left: 4px solid #D98C45; }
#wemd .callout-caution { border-left: 4px solid #B33D25; }

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/neo-brutalism.js
var require_neo_brutalism = __commonJS({
  "../../packages/core/dist/themes/neo-brutalism.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.neoBrutalismTheme = void 0;
    exports.neoBrutalismTheme = `/* \u65B0\u7C97\u91CE\u4E3B\u4E49\u98CE\u683C */
#wemd {
    padding: 30px 20px;
    max-width: 677px;
    margin: 0 auto;
    font-family: -apple-system, "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
    color: #000;
    /* \u7EAF\u9ED1\u6587\u5B57\uFF0C\u6781\u81F4\u5BF9\u6BD4 */
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    background-color: transparent;
    word-break: break-word;
}

/* \u6BB5\u843D - \u9AD8\u5BF9\u6BD4\u5EA6 */
#wemd p {
    margin-top: 24px;
    margin-bottom: 24px;
    line-height: 1.8;
    letter-spacing: 0.5px;
    text-align: justify;
    color: #111;
    font-size: 16px;
    font-weight: 400;
}

/* 
 * \u4E00\u7EA7\u6807\u9898 - \u50CF\u4E00\u4E2A\u9192\u76EE\u7684\u6807\u7B7E\u76D2\u5B50
 * \u8BBE\u8BA1\uFF1A\u7C97\u8FB9\u6846 + \u8367\u5149\u9EC4\u80CC\u666F + \u786C\u9634\u5F71
 */
#wemd h1 {
    margin-top: 60px;
    margin-bottom: 50px;
    text-align: center;
}

#wemd h1 .content {
    display: inline-block;
    font-size: 24px;
    font-weight: 900;
    color: #000;
    background-color: #CCFF00;
    /* \u8367\u5149\u9EC4\u9AD8\u4EAE */
    border: 3px solid #000;
    /* \u7C97\u9ED1\u8FB9\u6846 */
    padding: 12px 20px;
    /* \u5173\u952E\uFF1A\u9ED1\u8272\u786C\u9634\u5F71 */
    box-shadow: 6px 6px 0px #000;
    line-height: 1.3;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* 
 * \u4E8C\u7EA7\u6807\u9898 - \u4E0B\u5212\u7EBF\u9AD8\u4EAE
 * \u8BBE\u8BA1\uFF1A\u6587\u5B57\u4E0B\u65B9\u7684\u539A\u5B9E\u8272\u5757
 */
#wemd h2 {
    margin-top: 60px;
    margin-bottom: 30px;
    text-align: left;
    border-bottom: 3px solid #000;
    /* \u901A\u680F\u7C97\u9ED1\u7EBF */
    padding-bottom: 10px;
}

#wemd h2 .content {
    display: inline-block;
    font-size: 20px;
    font-weight: 800;
    color: #fff;
    background-color: #6A00FF;
    /* \u7535\u5149\u7D2B\u80CC\u666F */
    padding: 8px 16px;
    border: 2px solid #000;
    /* \u5DE6\u4E0A\u504F\u79FB\u7684\u9634\u5F71\u6548\u679C */
    box-shadow: 4px -4px 0px #000;
    line-height: 1.2;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* 
 * \u4E09\u7EA7\u6807\u9898 - \u51E0\u4F55\u5F15\u5BFC
 */
#wemd h3 {
    margin-top: 40px;
    margin-bottom: 20px;
}

#wemd h3 .content {
    display: inline-block;
    font-size: 18px;
    font-weight: 800;
    color: #000;
    padding-left: 12px;
    border-left: 8px solid #CCFF00;
    /* \u6781\u7C97\u7684\u9EC4\u7EBF */
    line-height: 1.2;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* 
 * \u56DB\u7EA7\u6807\u9898 - \u53CD\u8272\u9ED1\u76D2
 */
#wemd h4 {
    margin-top: 30px;
    margin-bottom: 15px;
    text-align: left;
}

#wemd h4 .content {
    display: inline-block;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    background-color: #000;
    /* \u7EAF\u9ED1\u80CC\u666F */
    padding: 6px 12px;
    border-radius: 0;
    /* \u76F4\u89D2 */
    line-height: 1.4;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* 
 * \u5217\u8868 - \u5F3A\u70C8\u7684\u51E0\u4F55\u611F
 * \u5FC5\u987B\u4F7F\u7528\u6B63\u65B9\u5F62
 */
#wemd ul {
    list-style-type: square;
    padding-left: 20px;
    margin: 20px 0;
    color: #6A00FF;
    /* \u7D2B\u8272\u65B9\u5757 */
}

#wemd ul li {
    margin-bottom: 12px;
    line-height: 1.75;
}

#wemd li section {
    color: #000;
    font-size: 16px;
    font-weight: 500;
}

/* \u6709\u5E8F\u5217\u8868 - \u7C97\u9ED1\u4F53\u6570\u5B57 */
#wemd ol {
    list-style-type: decimal;
    padding-left: 20px;
    margin: 20px 0;
    color: #000;
    font-weight: 900;
    /* \u6700\u7C97\u5B57\u4F53 */
}

#wemd ol li {
    margin-bottom: 12px;
    line-height: 1.75;
    border-bottom: 1px solid #eee;
    /* \u589E\u52A0\u5206\u5272\u7EBF */
    padding-bottom: 8px;
}

#wemd ol li section {
    color: #222;
    font-weight: normal;
    font-size: 16px;
    padding-left: 5px;
}

#wemd ul ul {
    list-style-type: circle;
    color: #CCFF00;
    margin-top: 10px;
}

#wemd ol ol {
    list-style-type: upper-alpha;
    color: #6A00FF;
    font-weight: 900;
}

/* 
 * \u5F15\u7528 - \u89C6\u7A97\u98CE\u683C (Window Style)
 * \u8FD9\u662F\u4E00\u4E2A\u5E26\u7C97\u8FB9\u6846\u548C\u786C\u9634\u5F71\u7684\u76D2\u5B50
 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
    margin: 40px 0;
    padding: 24px;
    background-color: #f4f4f4;
    /* \u6D45\u7070\u80CC\u666F */
    border: 2px solid #000;
    /* \u7C97\u9ED1\u8FB9\u6846 */
    /* \u7ECF\u5178\u7684\u6CE2\u666E\u98CE\u786C\u9634\u5F71 */
    box-shadow: 6px 6px 0px #6A00FF;
    overflow: visible !important;
}

#wemd .multiquote-1 p,
#wemd .multiquote-2 p,
#wemd .multiquote-3 p {
    margin: 0;
    color: #000;
    font-size: 15px;
    line-height: 1.8;
    font-weight: 500;
}

#wemd .multiquote-2 {
    margin: 38px 0;
    padding: 22px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: 5px 5px 0px #CCFF00;
}

#wemd .multiquote-3 {
    margin: 36px 0;
    padding: 20px;
    background: #fafafa;
    border: 2px solid #000;
    box-shadow: 4px 4px 0px #FF6B9D;
}

/* \u94FE\u63A5 - \u8367\u5149\u7B14\u6D82\u62B9\u6548\u679C */
#wemd a {
    color: #000;
    /* \u94FE\u63A5\u6587\u5B57\u9ED1\u8272 */
    text-decoration: none;
    border-bottom: 2px solid #000;
    background: linear-gradient(180deg, transparent 60%, #CCFF00 0);
    /* \u4E0B\u534A\u90E8\u5206\u9EC4\u8272\u9AD8\u4EAE */
    font-weight: 700;
    padding: 0 2px;
    transition: all 0.2s;
}

/* 
 * \u52A0\u7C97 - \u6545\u969C\u98CE\u6548\u679C
 * \u7D2B\u8272\u80CC\u666F + \u767D\u5B57
 */
#wemd strong {
    color: #fff;
    background-color: #6A00FF;
    font-weight: 700;
    padding: 2px 6px;
    margin: 0 2px;
    border: 1px solid #000;
    /* \u52A0\u4E2A\u7EC6\u9ED1\u8FB9 */
}

/* \u659C\u4F53 */
#wemd em {
    color: #6A00FF;
    font-style: italic;
    font-weight: bold;
}

#wemd em strong {
    color: #fff;
}

/* \u9AD8\u4EAE - \u8367\u5149\u9EC4\u5757 */
#wemd mark {
    background: #CCFF00;
    color: #000;
    padding: 2px 6px;
    border: 2px solid #000;
    font-weight: bold;
}

/* \u5220\u9664\u7EBF - \u7C97\u7EBF */
#wemd del {
    text-decoration: line-through;
    text-decoration-thickness: 3px;
    text-decoration-color: #FF6B9D;
    color: #666;
}

/* \u5206\u9694\u7EBF - \u7C97\u9ED1\u6761 */
#wemd hr {
    margin: 60px auto;
    border: 0;
    height: 4px;
    background: #000;
    width: 100%;
}

/* 
 * \u56FE\u7247 - \u62CD\u7ACB\u5F97\u6548\u679C
 * \u7C97\u6846 + \u786C\u9634\u5F71
 */
#wemd img {
    display: block;
    margin: 40px auto;
    width: 100%;
    border: 2px solid #000;
    box-shadow: 8px 8px 0px #000;
    /* \u7EAF\u9ED1\u786C\u9634\u5F71 */
    padding: 0;
    background: #fff;
}

/* \u9488\u5BF9\u56FE\u7247\u4E0B\u65B9\u7684\u6CE8\u91CA\u6587\u5B57 */
#wemd figcaption {
    margin-top: 12px;
    text-align: center;
    color: #000;
    font-size: 14px;
    font-weight: bold;
    background: #CCFF00;
    padding: 4px 10px;
    border: 2px solid #000;
    display: inline-block;
    box-shadow: 3px 3px 0 #000;
}

/* \u884C\u5185\u4EE3\u7801 - \u590D\u53E4\u7EC8\u7AEF\u98CE */
#wemd p code,
#wemd li code {
    color: #000;
    background: #fff;
    border: 1px solid #000;
    padding: 2px 6px;
    margin: 0 4px;
    font-size: 14px;
    font-family: "Menlo", monospace;
    font-weight: bold;
    box-shadow: 2px 2px 0 #ccc;
}

/* \u4EE3\u7801\u5757 - \u7EAF\u9ED1\u786C\u6838\u6A21\u5F0F */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    display: block;
    padding: 16px;
    background: #000;
    /* \u7EAF\u9ED1 */
    color: #CCFF00;
    /* \u9ED8\u8BA4\u8367\u5149\u7EFF\u6587\u5B57 */
    font-size: 13px;
    line-height: 1.5;
    border-radius: 0;
    /* \u76F4\u89D2 */
    font-family: "Menlo", "Courier New", monospace;
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
    border: 2px solid #000;
    box-shadow: 6px 6px 0px #ddd;
}

/* \u4F18\u5316\u6DF1\u8272\u80CC\u666F\u4E0B\u7684\u8BED\u6CD5\u9AD8\u4EAE\u989C\u8272 - \u4F7F\u7528\u9AD8\u5BF9\u6BD4\u5EA6\u4EAE\u8272 */
#wemd pre code.hljs .hljs-comment,
#wemd pre code.hljs .hljs-quote {
    color: #888;
}

#wemd pre code.hljs .hljs-keyword,
#wemd pre code.hljs .hljs-selector-tag {
    color: #FF6B9D;
    font-weight: bold;
}

#wemd pre code.hljs .hljs-string,
#wemd pre code.hljs .hljs-doctag {
    color: #FFD93D;
}

#wemd pre code.hljs .hljs-number,
#wemd pre code.hljs .hljs-literal {
    color: #6BCF7F;
}

#wemd pre code.hljs .hljs-title,
#wemd pre code.hljs .hljs-section {
    color: #4D9DE0;
    font-weight: bold;
}

#wemd pre code.hljs .hljs-built_in,
#wemd pre code.hljs .hljs-builtin-name {
    color: #E85D75;
    font-weight: bold;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u8367\u5149\u7EFF */
#wemd pre code:not(.hljs) {
    color: #CCFF00;
    background: #000;
    border: 2px solid #000;
    box-shadow: 6px 6px 0px #ddd;
}

/* \u8868\u683C - Excel \u7C97\u6846\u98CE\u683C */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 40px 0;
    font-size: 14px;
    border: 2px solid #000;
    box-shadow: 6px 6px 0px #000;
}

#wemd table tr th {
    background: #6A00FF;
    /* \u7D2B\u8272\u8868\u5934 */
    color: #fff;
    font-weight: 900;
    border: 1px solid #000;
    padding: 12px;
    text-align: left;
    text-transform: uppercase;
}

#wemd table tr td {
    border: 1px solid #000;
    padding: 12px;
    color: #000;
    background: #fff;
}

/* \u9694\u884C\u53D8\u8272 - \u9EC4\u8272 */
#wemd table tr:nth-child(even) td {
    background-color: #faffd1;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #6A00FF;
    font-weight: bold;
}

#wemd .footnotes-sep {
    border-top: 2px solid #000;
    padding-top: 20px;
    margin-top: 60px;
    font-size: 14px;
    font-weight: 900;
    color: #000;
    text-transform: uppercase;
}

#wemd .footnote-num {
    font-weight: 900;
    color: #fff;
    background: #000;
    padding: 1px 4px;
    margin-right: 4px;
    font-size: 12px;
}

#wemd .footnote-item p {
    color: #333;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u65B0\u7C97\u91CE\u4E3B\u4E49\u98CE\u683C */
#wemd .callout {
    margin: 40px 0;
    padding: 20px;
    background: #f4f4f4;
    border: 2px solid #000;
    box-shadow: 6px 6px 0px #6A00FF;
    border-radius: 0;
}

#wemd .callout-title {
    font-weight: 900;
    margin-bottom: 10px;
    text-transform: uppercase;
    color: #000;
    font-size: 16px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { border-left: 8px solid #6A00FF; }
#wemd .callout-tip { border-left: 8px solid #CCFF00; }
#wemd .callout-important { border-left: 8px solid #6A00FF; }
#wemd .callout-warning { border-left: 8px solid #CCFF00; }
#wemd .callout-caution { border-left: 8px solid #FF6B9D; }

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/receipt.js
var require_receipt = __commonJS({
  "../../packages/core/dist/themes/receipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiptTheme = void 0;
    exports.receiptTheme = `/* \u8D2D\u7269\u5C0F\u7968\u98CE\u683C */
#wemd {
    padding: 40px 20px;
    max-width: 677px;
    margin: 0 auto;
    /* \u5F3A\u5236\u7B49\u5BBD/\u886C\u7EBF\u5B57\u4F53\uFF0C\u6A21\u62DF\u6253\u5370\u673A */
    font-family: "Courier New", "SimSun", "Songti SC", monospace;
    color: #111;
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    /* \u9876\u90E8\u6495\u7EB8\u6548\u679C */
    border-top: 5px dashed #111;
    border-bottom: 5px dashed #111;
    word-break: break-word;
}

/* \u6B63\u6587 */
#wemd p {
    margin: 18px 0;
    line-height: 1.6;
    text-align: justify;
    color: #222;
    font-size: 15px;
}

/* 
 * \u4E00\u7EA7\u6807\u9898 - \u5E97\u94FA\u62DB\u724C\u98CE\u683C
 * \u6539\u4E3A\uFF1A\u4E0A\u4E0B\u53CC\u865A\u7EBF\u5305\u88F9\uFF0C\u5C45\u4E2D\uFF0C\u52A0\u5927\u5B57\u91CD
 */
#wemd h1 {
    margin: 40px 0 30px;
    text-align: center;
    border-top: 2px dashed #000;
    border-bottom: 2px dashed #000;
    padding: 15px 0;
}

#wemd h1 .content {
    font-size: 26px;
    font-weight: 900;
    color: #000;
    letter-spacing: 2px;
    display: block;
    /* \u5360\u6EE1\u6574\u884C */
    border: none;
    /* \u53BB\u9664\u4E4B\u524D\u7684\u4E0B\u5212\u7EBF */
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 - \u5206\u7C7B\u680F */
#wemd h2 {
    margin: 30px 0 20px;
    text-align: center;
}

#wemd h2 .content {
    display: block;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    /* \u53CD\u767D\u6587\u5B57 */
    background: #000;
    /* \u9ED1\u8272\u80CC\u666F\u6761 */
    padding: 8px;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 - \u52A0\u7C97\u9879\u76EE */
#wemd h3 {
    margin: 25px 0 10px;
}

#wemd h3 .content {
    font-size: 16px;
    font-weight: bold;
    border-bottom: 2px solid #000;
    padding-bottom: 2px;
    display: inline-block;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 - \u7B80\u5355\u6807\u7B7E */
#wemd h4 {
    margin: 20px 0 10px;
    text-align: left;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: bold;
    color: #000;
    text-decoration: underline;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5F15\u7528 - \u5907\u6CE8\u6846 */
#wemd .multiquote-1 {
    margin: 25px 0;
    padding: 15px;
    border: 1px dotted #000;
    /* \u70B9\u72B6\u8FB9\u6846 */
    font-size: 14px;
    text-align: left;
    background: #f8f8f8;
}

#wemd .multiquote-1 p {
    font-family: monospace;
    color: #444;
}

#wemd .multiquote-2 {
    margin: 22px 0;
    padding: 13px;
    border: 1px dashed #000;
    background: #fafafa;
}

#wemd .multiquote-2 p {
    font-family: monospace;
    color: #444;
}

#wemd .multiquote-3 {
    margin: 20px 0;
    padding: 11px;
    border: 1px dotted #666;
    background: #fcfcfc;
}

#wemd .multiquote-3 p {
    font-family: monospace;
    color: #444;
}

/* \u5217\u8868 */
#wemd ul {
    list-style: none;
    padding-left: 10px;
    margin: 20px 0;
}

#wemd ul li {
    margin-bottom: 8px;
    border-bottom: 1px dotted #ccc;
    /* \u4E0B\u5212\u7EBF\u8F85\u52A9\u9605\u8BFB */
    padding-bottom: 4px;
}

#wemd ul li::before {
    content: "[*] ";
    /* \u6A21\u62DF\u5B57\u7B26\u5217\u8868 */
    font-weight: bold;
    margin-right: 5px;
}

#wemd ol {
    list-style: decimal;
    padding-left: 25px;
    margin: 20px 0;
    font-weight: bold;
}

#wemd li section {
    font-weight: normal;
    color: #222;
}

#wemd ul ul {
    list-style: none;
    margin-top: 6px;
}

#wemd ul ul li::before {
    content: "[-] ";
    font-weight: bold;
}

#wemd ol ol {
    list-style-type: lower-alpha;
}

/* \u94FE\u63A5 */
#wemd a {
    color: #000;
    text-decoration: underline;
    font-weight: bold;
}

/* \u52A0\u7C97 */
#wemd strong {
    font-weight: 900;
    background: #ddd;
    /* \u6A21\u62DF\u7070\u8272\u9AD8\u4EAE\u6253\u5370 */
    padding: 0 4px;
}

/* \u659C\u4F53 */
#wemd em {
    font-style: italic;
    color: #000;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    font-weight: 900;
    font-style: italic;
}

/* \u9AD8\u4EAE - \u7070\u8272\u80CC\u666F */
#wemd mark {
    background: #ddd;
    color: #000;
    padding: 0 4px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #666;
}

/* \u5206\u5272\u7EBF - \u865A\u7EBF */
#wemd hr {
    margin: 30px 0;
    border: none;
    border-top: 2px dashed #000;
}

/* \u884C\u5185\u4EE3\u7801 - \u53CD\u8272\u6253\u5370\u5757 */
#wemd p code,
#wemd li code {
    background: #000;
    color: #fff;
    font-family: monospace;
    padding: 2px 6px;
    margin: 0 4px;
    font-size: 14px;
    border-radius: 0;
}

/* \u56FE\u7247 - \u6296\u52A8\u8FB9\u6846 */
#wemd img {
    display: block;
    margin: 30px auto;
    width: 100%;
    border: 2px dashed #000;
    padding: 8px;
    background: #fff;
}

#wemd figcaption {
    margin-top: 8px;
    text-align: center;
    color: #000;
    font-size: 13px;
    font-family: monospace;
    border-top: 1px dashed #000;
    padding-top: 6px;
}

/* 
 * \u4EE3\u7801\u5757 - \u66B4\u529B\u4FEE\u590D\u7248
 * 1. !important \u5F3A\u5236\u8986\u76D6\u7F16\u8F91\u5668\u7684\u6DF1\u8272\u4E3B\u9898
 * 2. \u53BB\u9664\u5706\u89D2\u548C\u9634\u5F71
 * 3. \u6A21\u62DF\u865A\u7EBF\u7EB8\u5F20
 */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    background: #f4f4f4 !important;
    /* \u5F3A\u5236\u6D45\u7070\u80CC\u666F */
    /* color \u7531 .hljs \u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
    border: 2px dashed #000 !important;
    /* \u5F3A\u5236\u865A\u7EBF\u6846 */
    border-radius: 0 !important;
    /* \u5F3A\u5236\u76F4\u89D2 */
    box-shadow: none !important;
    /* \u53BB\u6389\u7ACB\u4F53\u9634\u5F71 */
    font-family: "Courier New", monospace;
    font-size: 13px;
    padding: 15px;
    line-height: 1.5;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u9ED1\u8272 */
#wemd pre code:not(.hljs) {
    color: #000 !important;
    background: #f4f4f4 !important;
    border: 2px dashed #000 !important;
    border-radius: 0 !important;
    box-shadow: none !important;
}

/* \u5C1D\u8BD5\u9690\u85CF Mac \u7EA2\u7EFF\u706F (\u5982\u679C\u7F16\u8F91\u5668\u662F\u7528\u4F2A\u5143\u7D20\u5B9E\u73B0\u7684) */
#wemd pre code::before {
    content: "" !important;
    display: none !important;
}

/* \u8868\u683C - \u4EF7\u683C\u5355 */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 14px;
    font-family: monospace;
}

#wemd table tr th {
    border-bottom: 2px dashed #000;
    padding: 8px 5px;
    text-align: right;
    font-weight: 900;
    text-transform: uppercase;
}

#wemd table tr th:first-child {
    text-align: left;
}

#wemd table tr td {
    border-bottom: 1px dotted #000;
    padding: 8px 5px;
    text-align: right;
    color: #000;
}

#wemd table tr td:first-child {
    text-align: left;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #000;
    text-decoration: underline;
}

#wemd .footnotes-sep {
    border-top: 2px dashed #000;
    margin-top: 30px;
    padding-top: 15px;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #000;
    margin-right: 4px;
}

#wemd .footnote-item p {
    color: #444;
    font-size: 13px;
    font-family: monospace;
}

/* \u63D0\u793A\u5757 - \u8D2D\u7269\u5C0F\u7968\u98CE\u683C */
#wemd .callout {
    margin: 25px 0;
    padding: 15px;
    border: 1px dotted #000;
    background: #f8f8f8;
    border-radius: 0;
}

#wemd .callout-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: #000;
    font-family: monospace;
    text-transform: uppercase;
    font-size: 14px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { border-left: 2px dashed #000; }
#wemd .callout-tip { border-left: 2px dashed #000; }
#wemd .callout-important { border-left: 2px dashed #000; }
#wemd .callout-warning { border-left: 2px dashed #000; }
#wemd .callout-caution { border-left: 2px dashed #000; }

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/sunset-film.js
var require_sunset_film = __commonJS({
  "../../packages/core/dist/themes/sunset-film.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sunsetFilmTheme = void 0;
    exports.sunsetFilmTheme = `/* \u843D\u65E5\u80F6\u7247\u98CE\u683C */
#wemd {
    padding: 30px 22px;
    max-width: 677px;
    margin: 0 auto;
    /* \u5F3A\u5236\u4F7F\u7528\u886C\u7EBF\u4F53\uFF0C\u8425\u9020\u7535\u5F71\u5B57\u5E55\u611F */
    font-family: "Songti SC", "SimSun", "STSong", "Georgia", serif;
    color: #4A3B32;
    /* \u6DF1\u5496\u5561\u8272\u6587\u5B57\uFF0C\u6BD4\u9ED1\u8272\u66F4\u67D4\u548C */
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* \u6BB5\u843D - \u50CF\u662F\u5728\u8BFB\u4E00\u5C01\u65E7\u4FE1 */
#wemd p {
    margin-top: 26px;
    margin-bottom: 26px;
    line-height: 1.9;
    letter-spacing: 0.8px;
    /* \u5B57\u95F4\u8DDD\u7A0D\u5927 */
    text-align: justify;
    color: #5D4037;
    font-size: 16px;
}

/* 
 * \u4E00\u7EA7\u6807\u9898 - \u7535\u5F71\u7247\u540D\u98CE\u683C
 * \u4E0A\u4E0B\u53CC\u7EBF\u88C5\u9970
 */
#wemd h1 {
    margin-top: 60px;
    margin-bottom: 50px;
    text-align: center;
    border-top: 4px double #B33D25;
    /* \u53CC\u5B9E\u7EBF */
    border-bottom: 1px solid #B33D25;
    padding: 20px 0;
}

#wemd h1 .content {
    font-size: 26px;
    font-weight: 900;
    color: #B33D25;
    display: inline-block;
    line-height: 1.2;
    letter-spacing: 3px;
}

#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* 
 * \u4E8C\u7EA7\u6807\u9898 - \u90AE\u7968/\u6807\u7B7E\u98CE\u683C
 * \u5B9E\u5FC3\u80CC\u666F + \u767D\u5B57
 */
#wemd h2 {
    margin-top: 50px;
    margin-bottom: 30px;
    text-align: left;
}

#wemd h2 .content {
    display: inline-block;
    font-size: 19px;
    font-weight: bold;
    color: #FFFBF0;
    /* \u7C73\u767D\u5B57 */
    background-color: #B33D25;
    /* \u9676\u571F\u7EA2\u5E95 */
    padding: 8px 16px;
    border-radius: 2px;
    box-shadow: 4px 4px 0px rgba(179, 61, 37, 0.2);
    /* \u6DE1\u6DE1\u7684\u590D\u53E4\u9634\u5F71 */
    line-height: 1.2;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* 
 * \u4E09\u7EA7\u6807\u9898 - \u50CF\u4E66\u672C\u7684\u5C0F\u8282
 * \u5496\u5561\u8272\u6587\u5B57 + \u5DE6\u4FA7\u88C5\u9970
 */
#wemd h3 {
    margin-top: 40px;
    margin-bottom: 20px;
}

#wemd h3 .content {
    font-size: 18px;
    font-weight: bold;
    color: #8D5B4C;
    display: inline-block;
    padding-left: 10px;
    border-left: 4px solid #D98C45;
    /* \u7425\u73C0\u9EC4 */
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* 
 * \u56DB\u7EA7\u6807\u9898 - \u6781\u7B80\u4E0B\u5212\u7EBF
 */
#wemd h4 {
    margin-top: 30px;
    margin-bottom: 15px;
    text-align: left;
}

#wemd h4 .content {
    display: inline-block;
    font-size: 16px;
    font-weight: bold;
    color: #B33D25;
    border-bottom: 2px solid #F2C94C;
    /* \u4EAE\u9EC4\u7EBF\u6761 */
    padding-bottom: 2px;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* \u5217\u8868 - \u7ECF\u5178\u7684\u5B9E\u5FC3\u65B9\u70B9 */
#wemd ul {
    list-style-type: square;
    padding-left: 20px;
    margin: 20px 0;
    color: #D98C45;
}

#wemd ul li {
    margin-bottom: 12px;
    line-height: 1.8;
}

#wemd li section {
    color: #5D4037;
    font-size: 16px;
}

/* \u6709\u5E8F\u5217\u8868 */
#wemd ol {
    list-style-type: decimal;
    padding-left: 20px;
    margin: 20px 0;
    color: #B33D25;
    font-weight: bold;
    font-family: serif;
    /* \u6570\u5B57\u4E5F\u7528\u886C\u7EBF\u4F53\uFF0C\u5F88\u6709\u5473\u9053 */
}

#wemd ol li {
    margin-bottom: 12px;
    line-height: 1.8;
}

#wemd ol li section {
    color: #5D4037;
    font-weight: normal;
    font-size: 16px;
}

#wemd ul ul {
    list-style-type: circle;
    color: #8D5B4C;
    margin-top: 8px;
}

#wemd ol ol {
    list-style-type: lower-roman;
    color: #B33D25;
}

/* 
 * \u5F15\u7528 - \u6CDB\u9EC4\u7684\u65E7\u62A5\u7EB8
 * \u6DF1\u7C73\u8272\u80CC\u666F + \u68D5\u8272\u8FB9\u6846
 */
#wemd .multiquote-1,
#wemd .multiquote-2,
#wemd .multiquote-3 {
    margin: 36px 0;
    padding: 24px;
    background-color: #F7EED6;
    /* \u6CDB\u9EC4\u80CC\u666F */
    border-left: 3px solid #8D5B4C;
    /* \u5496\u5561\u8272\u8FB9\u6846 */
    border-radius: 2px;
    overflow: visible !important;
}

#wemd .multiquote-1 p,
#wemd .multiquote-2 p,
#wemd .multiquote-3 p {
    margin: 0;
    color: #6D4C41;
    font-size: 15px;
    line-height: 1.8;
    font-style: italic;
}

#wemd .multiquote-2 {
    margin: 34px 0;
    padding: 22px;
    background: #FFF8E7;
    border-left: 3px solid #D98C45;
    border-radius: 2px;
}

#wemd .multiquote-3 {
    margin: 32px 0;
    padding: 20px;
    background: #FFFBF0;
    border-left: 2px solid #D98C45;
    border-radius: 2px;
}

/* \u94FE\u63A5 - \u50CF\u662F\u624B\u5199\u7684\u4E0B\u5212\u7EBF */
#wemd a {
    color: #B33D25;
    text-decoration: none;
    border-bottom: 1px solid #B33D25;
    font-weight: bold;
    transition: opacity 0.2s;
}

/* 
 * \u52A0\u7C97 - \u91CD\u70B9\u6807\u8BB0
 * \u50CF\u662F\u7528\u6DF1\u8272\u9A6C\u514B\u7B14\u5212\u8FC7
 */
#wemd strong {
    color: #B33D25;
    font-weight: 900;
    margin: 0 2px;
}

/* \u659C\u4F53 */
#wemd em {
    color: #D98C45;
    font-style: italic;
    font-weight: bold;
}

#wemd em strong {
    color: #B33D25;
}

/* \u9AD8\u4EAE - \u6696\u9EC4\u80CC\u666F */
#wemd mark {
    background: rgba(242, 201, 76, 0.3);
    color: #B33D25;
    padding: 2px 4px;
    border-radius: 2px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #8D5B4C;
}

/* \u5206\u9694\u7EBF - \u865A\u7EBF\u526A\u88C1\u7EBF */
#wemd hr {
    margin: 60px auto;
    border: 0;
    height: 1px;
    border-top: 2px dashed #D98C45;
    /* \u526A\u88C1\u7EBF\u98CE\u683C */
    width: 100%;
}

/* 
 * \u56FE\u7247 - \u8001\u7167\u7247\u98CE\u683C
 * \u52A0\u4E0A\u767D\u8272\u8FB9\u6846\u548C\u9634\u5F71
 */
#wemd img {
    display: block;
    margin: 40px auto;
    width: 95%;
    /* \u7A0D\u5FAE\u7559\u70B9\u767D\u8FB9 */
    border: 8px solid #fff;
    /* \u6A21\u62DF\u7167\u7247\u767D\u8FB9 */
    box-shadow: 0 10px 25px rgba(93, 64, 55, 0.15);
    background: #fff;
}

#wemd figcaption {
    font-size: 13px;
    color: #8D5B4C;
    margin-top: 15px;
    font-style: italic;
    font-family: serif;
}

/* \u884C\u5185\u4EE3\u7801 - \u5496\u5561\u8272\u5757 */
#wemd p code,
#wemd li code {
    color: #5D4037;
    background: #EFE6D5;
    border: none;
    padding: 2px 6px;
    margin: 0 4px;
    border-radius: 3px;
    font-size: 14px;
    font-family: serif;
    /* \u4EE3\u7801\u4E5F\u7528\u886C\u7EBF\u4F53\uFF0C\u4FDD\u6301\u590D\u53E4\u611F */
}

/* \u4EE3\u7801\u5757 - \u590D\u53E4\u6253\u5B57\u673A\u914D\u8272 */
/* \u4EE3\u7801\u5757 - \u6CE8\u610F\uFF1A\u4E0D\u8981\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272 */
#wemd pre code.hljs {
    display: block;
    padding: 20px;
    background: #4A3B32;
    /* \u6DF1\u5496\u5561\u80CC\u666F */
    color: #E6CBB5;
    /* \u9ED8\u8BA4\u5976\u8336\u8272\u6587\u5B57 */
    font-size: 13px;
    line-height: 1.6;
    border-radius: 4px;
    font-family: "Courier New", Courier, monospace;
    /* \u6253\u5B57\u673A\u5B57\u4F53 */
    overflow-x: auto;
    white-space: pre;
  min-width: max-content;
    border: 4px solid #F7EED6;
}

/* \u4F18\u5316\u6DF1\u8272\u80CC\u666F\u4E0B\u7684\u8BED\u6CD5\u9AD8\u4EAE\u989C\u8272 - \u4F7F\u7528\u6696\u8272\u8C03\u9AD8\u5BF9\u6BD4\u5EA6\u989C\u8272 */
#wemd pre code.hljs .hljs-comment,
#wemd pre code.hljs .hljs-quote {
    color: #A68B7A;
}

#wemd pre code.hljs .hljs-keyword,
#wemd pre code.hljs .hljs-selector-tag {
    color: #FFB84D;
    font-weight: bold;
}

#wemd pre code.hljs .hljs-string,
#wemd pre code.hljs .hljs-doctag {
    color: #FFD4A3;
}

#wemd pre code.hljs .hljs-number,
#wemd pre code.hljs .hljs-literal {
    color: #C9A961;
}

#wemd pre code.hljs .hljs-title,
#wemd pre code.hljs .hljs-section {
    color: #F7EED6;
    font-weight: bold;
}

#wemd pre code.hljs .hljs-built_in,
#wemd pre code.hljs .hljs-builtin-name {
    color: #E6CBB5;
    font-weight: bold;
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u5976\u8336\u8272 */
#wemd pre code:not(.hljs) {
    color: #E6CBB5;
    background: #4A3B32;
    border: 4px solid #F7EED6;
}

/* \u8868\u683C - \u590D\u53E4\u8D26\u5355 */
#wemd table {
    width: 100%;
    border-collapse: collapse;
    margin: 40px 0;
    font-size: 14px;
    border: 2px solid #8D5B4C;
}

#wemd table tr th {
    background: #EFE6D5;
    color: #4A3B32;
    font-weight: bold;
    border: 1px solid #8D5B4C;
    padding: 12px 10px;
    text-align: center;
}

#wemd table tr td {
    border: 1px solid #8D5B4C;
    padding: 12px 10px;
    color: #5D4037;
    background: #FFFBF0;
}

/* \u811A\u6CE8 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #B33D25;
}

#wemd .footnotes-sep {
    border-top: 1px solid #D98C45;
    padding-top: 20px;
    margin-top: 60px;
    font-size: 12px;
    color: #8D5B4C;
    text-align: center;
    font-family: serif;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #FFFBF0;
    background-color: #D98C45;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    display: inline-block;
    text-align: center;
    line-height: 16px;
    font-size: 11px;
    margin-right: 4px;
}

#wemd .footnote-item p {
    color: #8D5B4C;
    font-size: 12px;
    margin: 4px 0;
}

/* \u516C\u5F0F */
#wemd .block-equation svg {
    max-width: 100% !important;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
}

/* \u63D0\u793A\u5757 - \u843D\u65E5\u80F6\u7247\u98CE\u683C */
#wemd .callout {
    margin: 36px 0;
    padding: 24px;
    background: #F7EED6;
    border-left: 3px solid #8D5B4C;
    border-radius: 2px;
}

#wemd .callout-title {
    font-weight: bold;
    margin-bottom: 10px;
    color: #B33D25;
    font-family: serif;
    font-size: 15px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

#wemd .callout-note { border-left-color: #8D5B4C; }
#wemd .callout-tip { border-left-color: #D98C45; }
#wemd .callout-important { border-left-color: #8D5B4C; }
#wemd .callout-warning { border-left-color: #D98C45; }
#wemd .callout-caution { border-left-color: #B33D25; }

/* Imageflow CSS */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/template.js
var require_template = __commonJS({
  "../../packages/core/dist/themes/template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.templateTheme = void 0;
    exports.templateTheme = `/*
 * ============================================
 * WeMD \u4E3B\u9898\u6A21\u677F
 * ============================================
 * 
 * \u4F7F\u7528\u8BF4\u660E\uFF1A
 * 1. \u4FEE\u6539\u4E0B\u65B9\u7684\u6837\u5F0F\u5B9A\u4E49\uFF0C\u521B\u5EFA\u4F60\u7684\u81EA\u5B9A\u4E49\u4E3B\u9898
 * 2. \u6240\u6709\u9009\u62E9\u5668\u5FC5\u987B\u4EE5 #wemd \u5F00\u5934
 * 3. \u4EE3\u7801\u5757\u4F7F\u7528 #wemd pre code.hljs\uFF0C\u4E0D\u8981\u8BBE\u7F6E\u5168\u5C40 color
 * 
 * ============================================
 * \u{1F319} \u6DF1\u8272\u6A21\u5F0F\u8BF4\u660E\uFF08\u5FAE\u4FE1\u517C\u5BB9\uFF09
 * ============================================
 * 
 * \u2705 \u652F\u6301\u81EA\u52A8\u8F6C\u6362\u7684\u989C\u8272\u683C\u5F0F\uFF1A
 *   - HEX: #333333, #fff
 *   - RGB: rgb(51, 51, 51), rgba(0, 0, 0, 0.5)
 *   - HSL: hsl(0, 0%, 20%), hsla(0, 0%, 0%, 0.5)
 *   - \u6E10\u53D8: linear-gradient(), radial-gradient() \u4E2D\u7684\u8272\u503C
 * 
 * \u{1F504} \u667A\u80FD\u8F6C\u6362\u89C4\u5219\uFF08\u8272\u5F69\u8BED\u4E49\u4FDD\u5168\uFF09\uFF1A
 *   - \u7070\u5EA6\u80CC\u666F \u2192 \u6620\u5C04\u5230\u6DF1\u8272\u533A\u95F4 (10%-20% \u4EAE\u5EA6)
 *   - \u9AD8\u9971\u548C\u8272\u5F69 (S>15%) \u2192 \u4FDD\u6301\u9C9C\u8273\uFF0C\u4EAE\u5EA6\u94B3\u5236\u5728 35%-55%
 *   - \u6DF1\u8272\u9634\u5F71/\u8FB9\u6846 (L<20) \u2192 \u951A\u5B9A\u4E3A\u6697\u8272\uFF0C\u4E0D\u53CD\u8F6C
 *   - \u6587\u5B57\u989C\u8272 \u2192 \u52A8\u6001\u5BF9\u6BD4\u5EA6\u8C03\u6574\u4EE5\u4FDD\u8BC1\u53EF\u8BFB\u6027
 * 
 * \u26A0\uFE0F \u4E0D\u4F1A\u88AB\u8F6C\u6362\uFF1A
 *   - CSS \u53D8\u91CF: var(--xxx)
 *   - \u56FE\u7247: url()
 *   - \u989C\u8272\u540D\u79F0: white, black\uFF08\u8BF7\u4F7F\u7528 HEX \u683C\u5F0F\uFF09
 * 
 * \u{1F4A1} \u8BBE\u8BA1\u5EFA\u8BAE\uFF1A
 *   - \u80CC\u666F\u8272\u7528\u900F\u660E\u6216\u6D45\u7070\uFF0C\u5229\u4E8E\u81EA\u52A8\u9002\u914D
 *   - \u5F69\u8272\u88C5\u9970\u4FDD\u6301\u539F\u503C\uFF0C\u7B97\u6CD5\u81EA\u52A8\u4FDD\u62A4
 *   - \u6DF1\u8272\u6295\u5F71\u548C\u7C97\u8FB9\u6846\u4F7F\u7528\u7EAF\u9ED1 #000\uFF0C\u53EF\u4FDD\u6301\u5C42\u7EA7\u611F
 */

/* ============================================
 * 1. \u5168\u5C40\u5BB9\u5668\u6837\u5F0F
 * ============================================
 */
#wemd {
    padding: 30px 20px;
    max-width: 677px;
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, "Microsoft YaHei", sans-serif;
    color: #333;
    background-color: transparent;
    /* \u900F\u660E\u80CC\u666F\uFF0C\u517C\u5BB9\u5FAE\u4FE1\u6DF1\u8272\u6A21\u5F0F */
    word-break: break-word;
}

/* ============================================
 * 2. \u6BB5\u843D\u6837\u5F0F
 * ============================================
 */
#wemd p {
    margin: 16px 0;
    /* \u6BB5\u843D\u95F4\u8DDD\uFF1A\u4E0A\u4E0B\u5404 16px */
    line-height: 1.7;
    /* \u884C\u9AD8\uFF1A1.7 \u500D\uFF0C\u8212\u9002\u9605\u8BFB */
    text-align: justify;
    /* \u6587\u672C\u5BF9\u9F50\uFF1A\u4E24\u7AEF\u5BF9\u9F50 */
    color: #333;
    /* \u6587\u5B57\u989C\u8272 */
    font-size: 16px;
    /* \u5B57\u4F53\u5927\u5C0F */
}

/* ============================================
 * 3. \u6807\u9898\u6837\u5F0F
 * ============================================
 * \u6CE8\u610F\uFF1A\u6807\u9898\u5185\u90E8\u7ED3\u6784\u4E3A\uFF1A
 * <h1>
 *   <span class="prefix"></span>
 *   <span class="content">\u6807\u9898\u6587\u5B57</span>
 *   <span class="suffix"></span>
 * </h1>
 * 
 * \u53EF\u4EE5\u901A\u8FC7 .prefix \u548C .suffix \u6DFB\u52A0\u88C5\u9970\u5143\u7D20
 */

/* \u4E00\u7EA7\u6807\u9898 */
#wemd h1 {
    margin: 40px 0 30px;
    /* \u5916\u8FB9\u8DDD\uFF1A\u4E0A 40px\uFF0C\u4E0B 30px */
    text-align: center;
    /* \u5C45\u4E2D\u5BF9\u9F50 */
}

#wemd h1 .content {
    font-size: 24px;
    /* \u5B57\u4F53\u5927\u5C0F */
    font-weight: bold;
    /* \u5B57\u4F53\u7C97\u7EC6\uFF1A\u52A0\u7C97 */
    color: #000;
    /* \u6587\u5B57\u989C\u8272 */
}

/* \u9690\u85CF\u524D\u7F00\u548C\u540E\u7F00\uFF08\u5982\u679C\u4E0D\u9700\u8981\u88C5\u9970\uFF09 */
#wemd h1 .prefix,
#wemd h1 .suffix {
    display: none;
}

/* \u4E8C\u7EA7\u6807\u9898 */
#wemd h2 {
    margin: 30px 0 20px;
}

#wemd h2 .content {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}

#wemd h2 .prefix,
#wemd h2 .suffix {
    display: none;
}

/* \u4E09\u7EA7\u6807\u9898 */
#wemd h3 {
    margin: 25px 0 15px;
}

#wemd h3 .content {
    font-size: 18px;
    font-weight: bold;
    color: #666;
}

#wemd h3 .prefix,
#wemd h3 .suffix {
    display: none;
}

/* \u56DB\u7EA7\u6807\u9898 */
#wemd h4 {
    margin: 20px 0 10px;
}

#wemd h4 .content {
    font-size: 16px;
    font-weight: bold;
    color: #666;
}

#wemd h4 .prefix,
#wemd h4 .suffix {
    display: none;
}

/* ============================================
 * 4. \u5F15\u7528\u6837\u5F0F
 * ============================================
 * \u652F\u6301\u591A\u7EA7\u5F15\u7528\uFF1A.multiquote-1, .multiquote-2, .multiquote-3
 */
#wemd .multiquote-1 {
    margin: 20px 0;
    /* \u5916\u8FB9\u8DDD */
    padding: 16px 20px;
    /* \u5185\u8FB9\u8DDD */
    background: #f5f5f5;
    /* \u80CC\u666F\u8272 */
    border-left: 4px solid #ddd;
    /* \u5DE6\u8FB9\u6846 */
    border-radius: 4px;
    /* \u5706\u89D2 */
}

#wemd .multiquote-1 p {
    margin: 0;
    /* \u6BB5\u843D\u65E0\u5916\u8FB9\u8DDD */
    color: #666;
    /* \u6587\u5B57\u989C\u8272 */
    font-size: 15px;
}

/* \u4E8C\u7EA7\u5F15\u7528 */
#wemd .multiquote-2 {
    margin: 18px 0;
    padding: 14px 18px;
    background: #fafafa;
    border-left: 3px solid #ccc;
}

#wemd .multiquote-2 p {
    margin: 0;
    color: #777;
    font-size: 14px;
}

/* \u4E09\u7EA7\u5F15\u7528 */
#wemd .multiquote-3 {
    margin: 16px 0;
    padding: 12px 16px;
    background: #fafafa;
    border-left: 2px solid #bbb;
}

#wemd .multiquote-3 p {
    margin: 0;
    color: #888;
    font-size: 14px;
}

/* ============================================
 * 5. \u5217\u8868\u6837\u5F0F
 * ============================================
 */
#wemd ul,
#wemd ol {
    margin: 15px 0;
    padding-left: 25px;
    /* \u5DE6\u5185\u8FB9\u8DDD\uFF0C\u4E3A\u5217\u8868\u7B26\u53F7\u7559\u7A7A\u95F4 */
}

#wemd ul {
    list-style-type: disc;
    /* \u65E0\u5E8F\u5217\u8868\uFF1A\u5B9E\u5FC3\u5706\u70B9 */
}

#wemd ol {
    list-style-type: decimal;
    /* \u6709\u5E8F\u5217\u8868\uFF1A\u6570\u5B57 */
}

/* \u5217\u8868\u9879\u5185\u5BB9
 * \u6CE8\u610F\uFF1A\u5217\u8868\u9879\u5185\u90E8\u4F7F\u7528 <section> \u5305\u88F9\u5185\u5BB9
 */
#wemd li section {
    margin: 5px 0;
    /* \u5217\u8868\u9879\u95F4\u8DDD */
    color: #333;
    /* \u6587\u5B57\u989C\u8272 */
    line-height: 1.6;
}

#wemd ul ul {
    list-style-type: circle;
    margin-top: 6px;
}

#wemd ol ol {
    list-style-type: lower-alpha;
}

/* ============================================
 * 6. \u94FE\u63A5\u6837\u5F0F
 * ============================================
 */
#wemd a {
    color: #1e6bb8;
    /* \u94FE\u63A5\u989C\u8272 */
    text-decoration: none;
    /* \u53BB\u9664\u4E0B\u5212\u7EBF */
    border-bottom: 1px solid #1e6bb8;
    /* \u5E95\u90E8\u8FB9\u6846\u4F5C\u4E3A\u4E0B\u5212\u7EBF */
    font-weight: bold;
    /* \u52A0\u7C97 */
}

/* ============================================
 * 7. \u6587\u672C\u6837\u5F0F
 * ============================================
 */
/* \u52A0\u7C97 */
#wemd strong {
    font-weight: bold;
    color: #000;
}

/* \u659C\u4F53 */
#wemd em {
    font-style: italic;
    color: #333;
}

/* \u52A0\u7C97\u659C\u4F53 */
#wemd em strong {
    font-weight: bold;
    font-style: italic;
    color: #000;
}

/* \u9AD8\u4EAE */
#wemd mark {
    background: #fff3cd;
    color: #000;
    padding: 2px 4px;
    border-radius: 3px;
}

/* \u5220\u9664\u7EBF */
#wemd del {
    text-decoration: line-through;
    color: #999;
}

/* ============================================
 * 8. \u884C\u5185\u4EE3\u7801\u6837\u5F0F
 * ============================================
 * \u6CE8\u610F\uFF1A\u884C\u5185\u4EE3\u7801\u5728\u6BB5\u843D\u548C\u5217\u8868\u9879\u4E2D
 */
#wemd p code,
#wemd li code {
    color: #e83e8c;
    /* \u6587\u5B57\u989C\u8272 */
    background: #f8f9fa;
    /* \u80CC\u666F\u8272 */
    padding: 2px 6px;
    /* \u5185\u8FB9\u8DDD */
    margin: 0 2px;
    /* \u5916\u8FB9\u8DDD */
    border-radius: 3px;
    /* \u5706\u89D2 */
    font-size: 14px;
    font-family: "Courier New", Courier, monospace;
    /* \u7B49\u5BBD\u5B57\u4F53 */
}

/* ============================================
 * 9. \u4EE3\u7801\u5757\u6837\u5F0F\uFF08\u91CD\u8981\uFF01\uFF09
 * ============================================
 * 
 * \u26A0\uFE0F \u91CD\u8981\u63D0\u793A\uFF1A
 * 1. \u5FC5\u987B\u4F7F\u7528 #wemd pre code.hljs \u9009\u62E9\u5668\uFF0C\u4E0D\u8981\u4F7F\u7528 #wemd pre code
 * 2. \u4E0D\u8981\u8BBE\u7F6E\u5168\u5C40 color \u5C5E\u6027\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236\u6587\u5B57\u989C\u8272
 * 3. \u5982\u679C\u8BBE\u7F6E\u4E86 color\uFF0C\u4F1A\u8986\u76D6\u8BED\u6CD5\u9AD8\u4EAE\u7684\u989C\u8272\uFF0C\u5BFC\u81F4\u4EE3\u7801\u770B\u4E0D\u6E05
 * 4. \u4F7F\u7528 #wemd pre code:not(.hljs) \u4F5C\u4E3A\u540E\u5907\u6837\u5F0F\uFF08\u65E0\u8BED\u6CD5\u9AD8\u4EAE\u65F6\uFF09
 * 
 * \u793A\u4F8B\uFF08\u6B63\u786E\uFF09\uFF1A
 * #wemd pre code.hljs {
 *     background: #f5f5f5;
 *     // \u4E0D\u8BBE\u7F6E color
 * }
 * 
 * \u793A\u4F8B\uFF08\u9519\u8BEF\uFF09\uFF1A
 * #wemd pre code {
 *     color: #333;  // \u274C \u8FD9\u4F1A\u8986\u76D6\u8BED\u6CD5\u9AD8\u4EAE
 * }
 */
#wemd pre code.hljs {
    display: block;
    padding: 16px;
    /* \u5185\u8FB9\u8DDD */
    background: #f5f5f5;
    /* \u80CC\u666F\u8272 */
    /* \u26A0\uFE0F \u6CE8\u610F\uFF1A\u4E0D\u8981\u5728\u8FD9\u91CC\u8BBE\u7F6E color\uFF0C\u8BA9\u8BED\u6CD5\u9AD8\u4EAE\u4E3B\u9898\u63A7\u5236 */
    font-size: 13px;
    line-height: 1.6;
    border-radius: 4px;
    /* \u5706\u89D2 */
    font-family: "Courier New", "Consolas", "Monaco", monospace;
    /* \u7B49\u5BBD\u5B57\u4F53 */
    overflow-x: auto;
    /* \u6A2A\u5411\u6EDA\u52A8 */
    white-space: pre;
  min-width: max-content;
    /* \u4FDD\u7559\u7A7A\u767D\u548C\u6362\u884C */
    border: 1px solid #ddd;
    /* \u8FB9\u6846 */
}

/* \u5982\u679C\u6CA1\u6709\u8BED\u6CD5\u9AD8\u4EAE\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u6837\u5F0F */
#wemd pre code:not(.hljs) {
    color: #333;
    /* \u9ED8\u8BA4\u6587\u5B57\u989C\u8272 */
    background: #f5f5f5;
    border: 1px solid #ddd;
}

/* ============================================
 * 10. \u56FE\u7247\u6837\u5F0F
 * ============================================
 */
#wemd img {
    display: block;
    /* \u5757\u7EA7\u5143\u7D20 */
    margin: 20px auto;
    /* \u5C45\u4E2D\uFF1A\u4E0A\u4E0B 20px\uFF0C\u5DE6\u53F3\u81EA\u52A8 */
    max-width: 100%;
    /* \u6700\u5927\u5BBD\u5EA6\uFF1A\u4E0D\u8D85\u51FA\u5BB9\u5668 */
    border-radius: 4px;
    /* \u5706\u89D2 */
}

/* \u56FE\u7247\u5BB9\u5668\uFF08figure\uFF09 */
#wemd figure {
    margin: 20px 0;
    text-align: center;
}

/* \u56FE\u7247\u8BF4\u660E\u6587\u5B57\uFF08figcaption\uFF09 */
#wemd figcaption {
    margin-top: 8px;
    color: #999;
    font-size: 14px;
}

/* ============================================
 * 11. \u8868\u683C\u6837\u5F0F
 * ============================================
 */
#wemd table {
    width: 100%;
    /* \u5BBD\u5EA6\uFF1A100% */
    border-collapse: collapse;
    /* \u8FB9\u6846\u5408\u5E76 */
    margin: 20px 0;
    /* \u5916\u8FB9\u8DDD */
    font-size: 14px;
}

/* \u8868\u5934 */
#wemd table tr th {
    background: #f5f5f5;
    /* \u80CC\u666F\u8272 */
    color: #333;
    border: 1px solid #ddd;
    /* \u8FB9\u6846 */
    padding: 10px;
    /* \u5185\u8FB9\u8DDD */
    font-weight: bold;
    /* \u52A0\u7C97 */
    text-align: left;
}

/* \u8868\u683C\u5355\u5143\u683C */
#wemd table tr td {
    border: 1px solid #ddd;
    padding: 10px;
    color: #333;
}

/* \u6591\u9A6C\u7EB9\uFF08\u9694\u884C\u53D8\u8272\uFF09 */
#wemd table tr:nth-child(even) td {
    background-color: #fafafa;
}

/* ============================================
 * 12. \u5206\u5272\u7EBF\u6837\u5F0F
 * ============================================
 */
#wemd hr {
    margin: 30px 0;
    /* \u5916\u8FB9\u8DDD */
    border: none;
    /* \u53BB\u9664\u9ED8\u8BA4\u8FB9\u6846 */
    border-top: 1px solid #ddd;
    /* \u9876\u90E8\u8FB9\u6846 */
    height: 1px;
}

/* ============================================
 * 13. \u811A\u6CE8\u6837\u5F0F
 * ============================================
 */
#wemd .footnote-word,
#wemd .footnote-ref {
    color: #1e6bb8;
    /* \u811A\u6CE8\u94FE\u63A5\u989C\u8272 */
    font-weight: bold;
}

#wemd .footnotes-sep {
    border-top: 1px solid #ddd;
    /* \u5206\u9694\u7EBF */
    padding-top: 20px;
    margin-top: 40px;
}

#wemd .footnote-num {
    font-weight: bold;
    color: #1e6bb8;
    margin-right: 4px;
}

#wemd .footnote-item p {
    color: #666;
    font-size: 14px;
    margin: 4px 0;
}

/* ============================================
 * 14. \u6570\u5B66\u516C\u5F0F\u6837\u5F0F
 * ============================================
 */
/* \u884C\u95F4\u516C\u5F0F */
#wemd .block-equation {
    display: block;
    text-align: center;
    margin: 20px 0;
    overflow-x: auto;
}

#wemd .block-equation svg {
    max-width: 100% !important;
    /* \u6700\u5927\u5BBD\u5EA6\uFF1A\u4E0D\u8D85\u51FA\u5BB9\u5668 */
}

/* \u884C\u5185\u516C\u5F0F */
#wemd .inline-equation {
    display: inline;
}

#wemd .inline-equation svg {
    max-width: 100%;
    vertical-align: middle;
    /* \u5782\u76F4\u5C45\u4E2D */
}

/* ============================================
 * 16. \u63D0\u793A\u5757\u6837\u5F0F\uFF08Callout\uFF09
 * ============================================
 * 
 * \u63D0\u793A\u5757\u7528\u4E8E\u663E\u793A\u4E0D\u540C\u7C7B\u578B\u7684\u63D0\u793A\u4FE1\u606F
 * \u652F\u6301\u7684\u7C7B\u578B\uFF1Anote\u3001info\u3001tip\u3001success\u3001warning\u3001danger
 */

/* \u63D0\u793A\u5757\u57FA\u7840\u6837\u5F0F */
#wemd .callout {
    margin: 20px 0;
    padding: 16px 20px;
    background: #f5f5f5;
    border-left: 4px solid #ddd;
    border-radius: 4px;
}

#wemd .callout-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: #333;
    font-size: 15px;
}

#wemd .callout-icon {
    margin-right: 6px;
}

/* \u4E0D\u540C\u7C7B\u578B\u7684\u63D0\u793A\u5757 */
#wemd .callout-note { 
    border-left-color: #6366f1; 
    background: #f5f5ff; 
}

#wemd .callout-tip { 
    border-left-color: #10b981; 
    background: #ecfdf5; 
}

#wemd .callout-important { 
    border-left-color: #8b5cf6; 
    background: #f5f3ff; 
}

#wemd .callout-warning { 
    border-left-color: #f59e0b; 
    background: #fffbeb; 
}

#wemd .callout-caution { 
    border-left-color: #ef4444; 
    background: #fff5f5; 
}

/* ============================================
 * 15. \u5176\u4ED6\u5143\u7D20
 * ============================================
 */
/* \u5B9A\u4E49\u5217\u8868 */
#wemd dl {
    margin: 15px 0;
}

#wemd dt {
    font-weight: bold;
    margin-top: 10px;
}

#wemd dd {
    margin-left: 20px;
    color: #666;
}

/* \u76EE\u5F55\uFF08TOC\uFF09 */
#wemd .table-of-contents {
    margin: 20px 0;
    padding: 15px;
    background: #f5f5f5;
    border-left: 3px solid #ddd;
    border-radius: 4px;
}

#wemd .table-of-contents a {
    color: #333;
    text-decoration: none;
}




/* ============================================
 * 17. \u56FE\u7247\u8F6E\u64AD\u6837\u5F0F (Imageflow)
 * ============================================
 */
#wemd .imageflow-layer1 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  /* white-space: normal; */
  border: 0px none;
  padding: 0px;
  overflow: hidden;
}

#wemd .imageflow-layer2 {
  white-space: nowrap;
  width: 100%;
  overflow-x: scroll;
}

#wemd .imageflow-layer3 {
  display: inline-block;
  word-wrap: break-word;
  white-space: normal;
  vertical-align: top;
  width: 80%;
  margin-right: 10px;
  flex-shrink: 0;
}

#wemd .imageflow-img {
  display: block;
  width: 100%;
  height: auto;
  max-height: 300px;
  object-fit: contain;
  border-radius: 4px;
}

#wemd .imageflow-caption {
  text-align: center;
  margin-top: 0px;
  padding-top: 0px;
  color: #888;
}
`;
  }
});

// ../../packages/core/dist/themes/index.js
var require_themes = __commonJS({
  "../../packages/core/dist/themes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_basic(), exports);
    __exportStar(require_code_github(), exports);
    __exportStar(require_custom_default(), exports);
    __exportStar(require_academic_paper(), exports);
    __exportStar(require_aurora_glass(), exports);
    __exportStar(require_bauhaus(), exports);
    __exportStar(require_cyberpunk_neon(), exports);
    __exportStar(require_knowledge_base(), exports);
    __exportStar(require_luxury_gold(), exports);
    __exportStar(require_morandi_forest(), exports);
    __exportStar(require_neo_brutalism(), exports);
    __exportStar(require_receipt(), exports);
    __exportStar(require_sunset_film(), exports);
    __exportStar(require_template(), exports);
  }
});

// ../../packages/core/dist/wechatDarkMode.js
var require_wechatDarkMode = __commonJS({
  "../../packages/core/dist/wechatDarkMode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToWeChatDarkMode = convertToWeChatDarkMode;
    exports.convertCssToWeChatDarkMode = convertCssToWeChatDarkMode;
    exports._convertCssToWeChatDarkModeInternal = convertCssInternal;
    var CSS_KEYWORDS_SKIP = /^(currentcolor|inherit|transparent|initial|unset|none)$/i;
    var DEFAULT_DARK_BG_COLOR_RGB = [25, 25, 25];
    var CONSTANTS = {
      WHITE_LIKE_COLOR_BRIGHTNESS: 250,
      MAX_LIMIT_BGCOLOR_BRIGHTNESS: 190,
      MIN_LIMIT_OFFSET_BRIGHTNESS: 65,
      HIGH_BGCOLOR_BRIGHTNESS: 100,
      HIGH_BLACKWHITE_HSL_BRIGHTNESS: 40,
      LOW_BLACKWHITE_HSL_BRIGHTNESS: 22,
      IGNORE_ALPHA: 0.05,
      DEFAULT_DARK_BG_L_OFFSET: 10
    };
    var CONVERSION_MARK = "/* wemd-wechat-dark-converted */";
    var convertCssCache = /* @__PURE__ */ new Map();
    var convertCssCacheQueue = [];
    var CACHE_LIMIT = 200;
    var hashCss = (css) => {
      let hash = 0;
      for (let i = 0; i < css.length; i++) {
        hash = hash * 31 + css.charCodeAt(i) | 0;
      }
      return `${css.length}:${hash >>> 0}`;
    };
    var cacheSet = (key, value) => {
      if (convertCssCache.has(key))
        return;
      convertCssCache.set(key, value);
      convertCssCacheQueue.push(key);
      if (convertCssCacheQueue.length > CACHE_LIMIT) {
        const oldKey = convertCssCacheQueue.shift();
        if (oldKey)
          convertCssCache.delete(oldKey);
      }
    };
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
    }
    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map((x) => {
        const hex = Math.round(Math.max(0, Math.min(255, x))).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join("");
    }
    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;
      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return [h * 360, s * 100, l * 100];
    }
    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      h /= 360;
      if (s === 0)
        return [l * 255, l * 255, l * 255];
      const hue2rgb = (p2, q2, t2) => {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p2 + (q2 - p2) * 6 * t2;
        if (t2 < 1 / 2)
          return q2;
        if (t2 < 2 / 3)
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        return p2;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      return [hue2rgb(p, q, h + 1 / 3) * 255, hue2rgb(p, q, h) * 255, hue2rgb(p, q, h - 1 / 3) * 255];
    }
    function getColorPerceivedBrightness(rgb) {
      return (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
    }
    function adjustBrightnessTo(target, rgb) {
      const current = getColorPerceivedBrightness(rgb);
      if (current < 1e-3)
        return [target, target, target];
      const ratio = target / current;
      let r = Math.min(255, rgb[0] * ratio), g = Math.min(255, rgb[1] * ratio), b = Math.min(255, rgb[2] * ratio);
      if (g === 0 || r === 255 || b === 255) {
        g = (target * 1e3 - r * 299 - b * 114) / 587;
      } else if (r === 0) {
        r = (target * 1e3 - g * 587 - b * 114) / 299;
      } else if (b === 0 || g === 255) {
        b = (target * 1e3 - r * 299 - g * 587) / 114;
      }
      return [Math.max(0, Math.min(255, r)), Math.max(0, Math.min(255, g)), Math.max(0, Math.min(255, b))];
    }
    function adjustBackgroundBrightness(rgb, hsl) {
      const [h, s, l] = hsl;
      const perceived = getColorPerceivedBrightness(rgb);
      if (s < 10 && l > CONSTANTS.HIGH_BLACKWHITE_HSL_BRIGHTNESS || perceived > CONSTANTS.WHITE_LIKE_COLOR_BRIGHTNESS) {
        return hslToRgb(0, 0, Math.min(100, 100 + CONSTANTS.DEFAULT_DARK_BG_L_OFFSET - l));
      }
      if (perceived > CONSTANTS.MAX_LIMIT_BGCOLOR_BRIGHTNESS) {
        return adjustBrightnessTo(CONSTANTS.MAX_LIMIT_BGCOLOR_BRIGHTNESS, rgb);
      }
      if (l < CONSTANTS.LOW_BLACKWHITE_HSL_BRIGHTNESS) {
        return hslToRgb(h, s, CONSTANTS.LOW_BLACKWHITE_HSL_BRIGHTNESS);
      }
      return [rgb[0], rgb[1], rgb[2]];
    }
    function adjustCodeBackgroundBrightness(rgb, hsl) {
      const [h, s, l] = hsl;
      const perceived = getColorPerceivedBrightness(rgb);
      if (s < 10 && l > CONSTANTS.HIGH_BLACKWHITE_HSL_BRIGHTNESS || perceived > CONSTANTS.WHITE_LIKE_COLOR_BRIGHTNESS) {
        return hslToRgb(0, 0, Math.min(100, 100 + CONSTANTS.DEFAULT_DARK_BG_L_OFFSET - l));
      }
      const CODE_MAX_BG_PERCEIVED = 40;
      if (perceived > CODE_MAX_BG_PERCEIVED) {
        return adjustBrightnessTo(CODE_MAX_BG_PERCEIVED, rgb);
      }
      return [rgb[0], rgb[1], rgb[2]];
    }
    function adjustTextBrightness(textRgb, textHsl, bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      const textPerceived = getColorPerceivedBrightness(textRgb);
      const bgPerceived = getColorPerceivedBrightness(bgRgb);
      const offset = Math.abs(bgPerceived - textPerceived);
      if (textPerceived >= CONSTANTS.WHITE_LIKE_COLOR_BRIGHTNESS)
        return [textRgb[0], textRgb[1], textRgb[2]];
      const MAX_LIMIT_OFFSET = 138;
      if (offset > MAX_LIMIT_OFFSET && bgPerceived <= 27) {
        return adjustBrightnessTo(MAX_LIMIT_OFFSET + bgPerceived, textRgb);
      }
      if (offset >= CONSTANTS.MIN_LIMIT_OFFSET_BRIGHTNESS)
        return [textRgb[0], textRgb[1], textRgb[2]];
      if (bgPerceived >= CONSTANTS.HIGH_BGCOLOR_BRIGHTNESS) {
        if (textHsl[2] > 90 - CONSTANTS.HIGH_BLACKWHITE_HSL_BRIGHTNESS) {
          const newL = 90 - textHsl[2];
          return adjustTextBrightness(hslToRgb(textHsl[0], textHsl[1], newL), [textHsl[0], textHsl[1], newL], bgRgb);
        }
        return adjustBrightnessTo(Math.min(MAX_LIMIT_OFFSET, bgPerceived - CONSTANTS.MIN_LIMIT_OFFSET_BRIGHTNESS), textRgb);
      } else {
        if (textHsl[2] <= CONSTANTS.HIGH_BLACKWHITE_HSL_BRIGHTNESS) {
          const newL = 90 - textHsl[2];
          return adjustTextBrightness(hslToRgb(textHsl[0], textHsl[1], newL), [textHsl[0], textHsl[1], newL], bgRgb);
        }
        return adjustBrightnessTo(Math.min(MAX_LIMIT_OFFSET, bgPerceived + CONSTANTS.MIN_LIMIT_OFFSET_BRIGHTNESS), textRgb);
      }
    }
    function adjustDecorativeDarkBrightness(rgb, hsl) {
      const [h, s, l] = hsl;
      return hslToRgb(h, s * 0.5, Math.max(10, Math.min(15, l)));
    }
    function adjustBlockquoteTextBrightness(textRgb, textHsl, bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      return adjustTextBrightness(textRgb, textHsl, bgRgb);
    }
    function adjustTableTextBrightness(textRgb, textHsl, bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      return adjustTextBrightness(textRgb, textHsl, bgRgb);
    }
    function adjustCodeTextBrightness(textRgb, textHsl) {
      const [h, s, l] = textHsl;
      if (l > 75)
        return [textRgb[0], textRgb[1], textRgb[2]];
      return hslToRgb(h, Math.min(100, s * 1.1 + 5), Math.max(78, l));
    }
    function stripComments(css) {
      return css.replace(/\/\*[\s\S]*?\*\//g, "");
    }
    function isEscaped(str, index) {
      let backslashes = 0;
      for (let i = index - 1; i >= 0; i--) {
        if (str[i] === "\\")
          backslashes++;
        else
          break;
      }
      return backslashes % 2 === 1;
    }
    function findMatchingBrace(str, start) {
      let depth = 0;
      let inSingle = false, inDouble = false;
      for (let i = start; i < str.length; i++) {
        const ch = str[i];
        if (ch === "'" && !inDouble && !isEscaped(str, i))
          inSingle = !inSingle;
        if (ch === '"' && !inSingle && !isEscaped(str, i))
          inDouble = !inDouble;
        if (inSingle || inDouble)
          continue;
        if (ch === "{")
          depth++;
        else if (ch === "}") {
          depth--;
          if (depth === 0)
            return i;
        }
      }
      return -1;
    }
    function splitDeclarations(body) {
      const decls = [];
      let buf = "";
      let depth = 0;
      let inSingle = false, inDouble = false;
      for (let i = 0; i < body.length; i++) {
        const ch = body[i];
        if (ch === "'" && !inDouble && !isEscaped(body, i)) {
          inSingle = !inSingle;
          buf += ch;
          continue;
        }
        if (ch === '"' && !inSingle && !isEscaped(body, i)) {
          inDouble = !inDouble;
          buf += ch;
          continue;
        }
        if (inSingle || inDouble) {
          buf += ch;
          continue;
        }
        if (ch === "(")
          depth++;
        else if (ch === ")")
          depth = Math.max(0, depth - 1);
        if (ch === ";" && depth === 0) {
          if (buf.trim())
            decls.push(buf.trim());
          buf = "";
          continue;
        }
        buf += ch;
      }
      if (buf.trim())
        decls.push(buf.trim());
      return decls;
    }
    function parseCssBlocks(css) {
      const nodes = [];
      let i = 0;
      const len = css.length;
      while (i < len) {
        while (i < len && /\s/.test(css[i]))
          i++;
        if (i >= len)
          break;
        const start = i;
        if (css[i] === "@") {
          while (i < len && css[i] !== "{" && css[i] !== ";")
            i++;
          const prelude = css.slice(start, i).trim();
          if (css[i] === ";") {
            nodes.push({ type: "atrule", name: prelude, params: "", body: "", children: [], isStandalone: true });
            i++;
            continue;
          }
          const braceStart = i;
          const braceEnd = findMatchingBrace(css, braceStart);
          if (braceEnd === -1)
            break;
          const inner = css.slice(braceStart + 1, braceEnd);
          const children = parseCssBlocks(inner);
          nodes.push({
            type: "atrule",
            name: prelude,
            params: "",
            body: children.length ? "" : inner,
            children
          });
          i = braceEnd + 1;
        } else {
          while (i < len && css[i] !== "{")
            i++;
          const selector = css.slice(start, i).trim();
          const braceStart = i;
          if (braceStart >= len || css[braceStart] !== "{") {
            const remaining = css.slice(start).trim();
            if (remaining)
              nodes.push({ type: "rule", selector: "*", body: remaining });
            break;
          }
          const braceEnd = findMatchingBrace(css, braceStart);
          if (braceEnd === -1)
            break;
          const body = css.slice(braceStart + 1, braceEnd);
          nodes.push({ type: "rule", selector, body });
          i = braceEnd + 1;
        }
      }
      return nodes;
    }
    function getElementType(selector) {
      const s = selector.toLowerCase();
      if (s.includes("ue-table-interlace-color-single"))
        return "table";
      if (s.includes("ue-table-interlace-color-double"))
        return "table";
      if (s.includes("js_darkmode__"))
        return "other";
      if (/blockquote|callout|multiquote/.test(s))
        return "blockquote";
      if (/\b(pre|code|hljs|language-)/.test(s))
        return "code";
      if (/table|tr|th|td/.test(s))
        return "table";
      if (/h[1-6]/.test(s))
        return "heading";
      if (/::selection/.test(s))
        return "selection";
      if (s.includes("body"))
        return "body";
      return "other";
    }
    function processColorRgb(rgb, type, bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
      const isBg = ["background", "table", "blockquote", "code", "vibrant-protected", "selection"].includes(type);
      if (type === "code")
        return adjustCodeBackgroundBrightness(rgb, hsl);
      if (isBg)
        return adjustBackgroundBrightness(rgb, hsl);
      if (type === "decorative-dark")
        return adjustDecorativeDarkBrightness(rgb, hsl);
      if (type === "table-text")
        return adjustTableTextBrightness(rgb, hsl, bgRgb);
      if (type === "code-text")
        return adjustCodeTextBrightness(rgb, hsl);
      if (type === "blockquote-text")
        return adjustBlockquoteTextBrightness(rgb, hsl, bgRgb);
      if (type === "selection-text")
        return adjustTextBrightness(rgb, hsl, bgRgb);
      return adjustTextBrightness(rgb, hsl, bgRgb);
    }
    function processImportant(val, suffix) {
      const isImportant = val.toLowerCase().includes("!important");
      if (!isImportant)
        return `${val}, ${suffix}`;
      const cleanVal = val.replace(/\s*!important/i, "").trim();
      return `${cleanVal}, ${suffix} !important`;
    }
    function convertToWeChatDarkMode(hex, type = "body", bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      const rgb = hexToRgb(hex);
      if (!rgb)
        return hex;
      const [r, g, b] = processColorRgb(rgb, type, bgRgb);
      return rgbToHex(r, g, b);
    }
    function convertColorValue(raw, type, bgRgb = DEFAULT_DARK_BG_COLOR_RGB) {
      const lower = raw.toLowerCase();
      if (lower.includes("var(") || lower.includes("gradient") || CSS_KEYWORDS_SKIP.test(lower.trim()))
        return raw;
      let res = raw.replace(/#([0-9a-fA-F]{3,8})\b/g, (m) => {
        let hex = m;
        if (m.length === 4)
          hex = "#" + m[1] + m[1] + m[2] + m[2] + m[3] + m[3];
        if (m.length === 5 || m.length === 9) {
          hex = hex.slice(0, 7);
        }
        return convertToWeChatDarkMode(hex, type, bgRgb);
      });
      const rgbPattern = /rgba?\(\s*([^)]+)\)/gi;
      res = res.replace(rgbPattern, (m, body) => {
        const parts = body.split(",").map((p) => p.trim());
        if (parts.length < 3)
          return m;
        const [r, g, b] = parts.slice(0, 3).map(parseFloat);
        const a = parts[3] !== void 0 ? parseFloat(parts[3]) : 1;
        if ([r, g, b].some((n) => Number.isNaN(n)))
          return m;
        const [nr, ng, nb] = processColorRgb([r, g, b], type, bgRgb);
        return a < 1 ? `rgba(${Math.round(nr)}, ${Math.round(ng)}, ${Math.round(nb)}, ${a})` : `rgb(${Math.round(nr)}, ${Math.round(ng)}, ${Math.round(nb)})`;
      });
      const hslPattern = /hsla?\(\s*([^)]+)\)/gi;
      res = res.replace(hslPattern, (m, body) => {
        const parts = body.split(",").map((p) => p.trim().replace("%", ""));
        if (parts.length < 3)
          return m;
        const [h, s, l] = parts.slice(0, 3).map(parseFloat);
        const a = parts[3] !== void 0 ? parseFloat(parts[3]) : 1;
        if ([h, s, l].some((n) => Number.isNaN(n)))
          return m;
        const [nr, ng, nb] = processColorRgb(hslToRgb(h, s, l), type, bgRgb);
        return a < 1 ? `rgba(${Math.round(nr)}, ${Math.round(ng)}, ${Math.round(nb)}, ${a})` : `rgb(${Math.round(nr)}, ${Math.round(ng)}, ${Math.round(nb)})`;
      });
      return res;
    }
    function transformDeclarations(selector, props) {
      const baseType = getElementType(selector);
      const lowerSelector = selector.toLowerCase();
      const isCode = /\b(pre|code|hljs|language-)/.test(lowerSelector);
      const decls = splitDeclarations(props);
      const parsedDecls = decls.map((decl) => {
        const colonIndex = decl.indexOf(":");
        if (colonIndex === -1)
          return { name: "", lowerName: "", val: "", raw: decl };
        return {
          name: decl.slice(0, colonIndex).trim(),
          lowerName: decl.slice(0, colonIndex).trim().toLowerCase(),
          val: decl.slice(colonIndex + 1).trim()
        };
      }).filter((d) => d.name !== "");
      let currentBgRgb = DEFAULT_DARK_BG_COLOR_RGB;
      let convertedBgColorHex = "";
      for (const d of parsedDecls) {
        const lowerName = d.lowerName;
        const lowerVal = d.val.toLowerCase();
        const isShorthand = lowerName === "background";
        const isBgColorName = lowerName === "background-color";
        if ((isShorthand || isBgColorName) && !lowerVal.includes("gradient")) {
          const colorMatch = d.val.match(/#([0-9a-fA-F]{3,8})|rgba?\(\s*([^)]+)\)/i);
          if (colorMatch) {
            let rgb = null;
            if (colorMatch[1]) {
              const h = colorMatch[1];
              const hex = h.length === 3 ? "#" + h[0] + h[0] + h[1] + h[1] + h[2] + h[2] : "#" + h.slice(0, 6);
              rgb = hexToRgb(hex);
            } else if (colorMatch[2]) {
              const parts = colorMatch[2].split(",").map((p) => parseFloat(p.trim()));
              if (parts.length >= 3)
                rgb = [parts[0], parts[1], parts[2]];
            }
            if (rgb) {
              const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
              const darkRgb = adjustBackgroundBrightness(rgb, hsl);
              currentBgRgb = darkRgb;
              convertedBgColorHex = rgbToHex(darkRgb[0], darkRgb[1], darkRgb[2]);
            }
          }
        }
      }
      const finalDecls = [];
      for (const d of parsedDecls) {
        const name = d.name;
        const lowerName = d.lowerName;
        const val = d.val;
        const isBg = /background|bgcolor/i.test(lowerName);
        const isText = /color|-webkit-text-stroke|-webkit-text-fill-color|text-decoration-color|text-emphasis-color/i.test(lowerName);
        const isShadow = /shadow/i.test(lowerName);
        const isBorder = /border|outline|column-rule|box-shadow/i.test(lowerName);
        let type = baseType;
        if (isBg) {
          type = baseType === "table" ? "table" : baseType === "blockquote" ? "blockquote" : baseType === "selection" ? "selection" : baseType === "code" || isCode ? "code" : "background";
        } else if (isShadow || isBorder) {
          const colorMatch = val.match(/#([0-9a-fA-F]{3,8})|rgba?\(\s*([^)]+)\)/i);
          if (colorMatch) {
            let rgb = null;
            if (colorMatch[1]) {
              const h = colorMatch[1];
              const hex = h.length === 3 ? "#" + h[0] + h[0] + h[1] + h[1] + h[2] + h[2] : "#" + h.slice(0, 6);
              rgb = hexToRgb(hex);
            } else if (colorMatch[2]) {
              const parts = colorMatch[2].split(",").map((p) => parseFloat(p.trim()));
              if (parts.length >= 3)
                rgb = [parts[0], parts[1], parts[2]];
            }
            if (rgb) {
              const lum = getColorPerceivedBrightness(rgb);
              const [, s] = rgbToHsl(rgb[0], rgb[1], rgb[2]);
              if (lum < 20)
                type = "decorative-dark";
              else if (s > 15)
                type = "vibrant-protected";
              else
                type = baseType === "table" ? "table-text" : baseType === "blockquote" ? "blockquote-text" : baseType === "selection" ? "selection-text" : baseType === "code" || isCode ? "code-text" : baseType;
            }
          }
        } else if (isText) {
          type = baseType === "table" ? "table-text" : baseType === "blockquote" ? "blockquote-text" : baseType === "selection" ? "selection-text" : baseType === "code" || isCode ? "code-text" : baseType;
        }
        let convertedVal = convertColorValue(val, type, currentBgRgb);
        const isInheritOrPredefined = /^(inherit|initial|unset|none)$/i.test(val.trim());
        if (!isInheritOrPredefined && convertedBgColorHex) {
          if ((lowerName === "background-image" || lowerName === "background") && val.toLowerCase().includes("url(")) {
            if (!convertedVal.includes("linear-gradient")) {
              convertedVal = processImportant(convertedVal, `linear-gradient(${convertedBgColorHex}, ${convertedBgColorHex})`);
            }
          } else if (lowerName === "background-position") {
            convertedVal = processImportant(convertedVal, "top left");
          } else if (lowerName === "background-size") {
            convertedVal = processImportant(convertedVal, "100%");
          }
        }
        finalDecls.push({ name, val: convertedVal, lowerName });
      }
      finalDecls.sort((a, b) => {
        const na = a.lowerName;
        const nb = b.lowerName;
        if (na.startsWith("-webkit-text"))
          return -1;
        if (nb.startsWith("-webkit-text"))
          return 1;
        if (na === "color")
          return 1;
        if (nb === "color")
          return -1;
        if (na.includes("image") && nb.includes("color"))
          return 1;
        if (nb.includes("image") && na.includes("color"))
          return -1;
        return 0;
      });
      return `${selector}{${finalDecls.map((d) => `${d.name}: ${d.val}`).join(";")}}`;
    }
    function convertCssInternal(css) {
      const cleaned = stripComments(css);
      const nodes = parseCssBlocks(cleaned);
      const renderNodes = (items) => {
        return items.map((node) => {
          if (node.type === "rule") {
            return transformDeclarations(node.selector, node.body);
          }
          if (node.isStandalone) {
            return `${node.name};`;
          }
          if (node.children.length) {
            return `${node.name}{${renderNodes(node.children)}}`;
          }
          const body = node.body.trim();
          if (body) {
            return `${node.name}{${transformDeclarations(node.name, body)}}`;
          }
          return `${node.name}{}`;
        }).join("");
      };
      const res = renderNodes(nodes);
      return `${CONVERSION_MARK}
${res}`;
    }
    function convertCssToWeChatDarkMode(css) {
      if (css.includes(CONVERSION_MARK))
        return css;
      const key = hashCss(css);
      const cached = convertCssCache.get(key);
      if (cached)
        return cached;
      const res = convertCssInternal(css);
      cacheSet(key, res);
      return res;
    }
  }
});

// ../../packages/core/dist/index.js
var require_dist = __commonJS({
  "../../packages/core/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToWeChatDarkMode = exports.convertCssToWeChatDarkMode = void 0;
    __exportStar(require_MarkdownParser(), exports);
    __exportStar(require_ThemeProcessor(), exports);
    __exportStar(require_themes(), exports);
    var wechatDarkMode_1 = require_wechatDarkMode();
    Object.defineProperty(exports, "convertCssToWeChatDarkMode", { enumerable: true, get: function() {
      return wechatDarkMode_1.convertCssToWeChatDarkMode;
    } });
    Object.defineProperty(exports, "convertToWeChatDarkMode", { enumerable: true, get: function() {
      return wechatDarkMode_1.convertToWeChatDarkMode;
    } });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MDBeautifyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/i18n.ts
var import_obsidian = require("obsidian");
var translations = {
  en: {
    preview_ribbon_tooltip: "Preview Beautified Layout",
    copy_command_name: "Copy current file with beautification",
    preview_command_name: "Preview beautified rendering",
    view_display_text: "MD Beautify Preview",
    no_active_markdown: "No active Markdown file",
    no_active_view: "No active Markdown view found",
    copy_success: "Successfully copied!",
    copy_failed: "Failed to copy: ",
    setting_theme: "Theme",
    setting_image_host: "Image Host",
    btn_copy: "Copy Beautified",
    btn_upload: "Upload",
    settings_header: "MD Beautify Settings",
    tab_general: "General",
    tab_theme: "Theme",
    tab_image_host: "Image Host",
    setting_copy_as_html: "Copy as HTML",
    setting_copy_as_html_desc: "Whether to include HTML formatting when copying to clipboard",
    setting_base_theme: "Select Theme",
    custom_style_title: "Custom Style for ",
    custom_style_desc: "Add your own CSS variables or styles here to override the base theme.",
    msg_style_saved: "Custom style for {themeId} saved",
    setting_active_image_host: "Active Image Host",
    setting_active_image_host_desc: "Choose where to upload images",
    setting_auto_upload: "Auto Upload Images",
    setting_auto_upload_desc: "Automatically upload local images when pasting or dragging to the editor",
    official_host_desc: "Default MD Beautify image hosting is enabled. No configuration required.",
    setting_official_url: "Default Upload URL",
    setting_official_url_desc: "The API endpoint for default image hosting",
    theme_basic: "Basic",
    theme_codeGithub: "GitHub Code",
    theme_academicPaper: "Academic Paper",
    theme_auroraGlass: "Aurora Glass",
    theme_bauhaus: "Bauhaus",
    theme_cyberpunkNeon: "Cyberpunk Neon",
    theme_knowledgeBase: "Knowledge Base",
    theme_luxuryGold: "Luxury Gold",
    theme_morandiForest: "Morandi Forest",
    theme_neoBrutalism: "Neo Brutalism",
    theme_receipt: "Receipt",
    theme_sunsetFilm: "Sunset Film",
    theme_template: "Template",
    host_official: "Default",
    host_qiniu: "Qiniu",
    host_aliyun: "Aliyun",
    host_tencent: "Tencent",
    host_s3: "S3",
    btn_create_theme: "Create Theme",
    new_theme_placeholder: "My New Theme",
    setting_custom_css: "Custom CSS",
    preview_title: "Live Preview",
    preview_placeholder: "# Hello World\n\nThis is a live preview.",
    label_theme: "Theme",
    label_host: "Host",
    btn_toggle_controls: "Toggle Settings",
    btn_cancel: "Cancel",
    msg_enter_theme_name: "Please enter a theme name",
    btn_manage_themes: "Manage Themes",
    title_theme_manager: "Theme Manager",
    btn_delete: "Delete",
    msg_confirm_delete_theme: "Are you sure you want to delete the theme '{themeName}'?",
    msg_uploading_image: "Uploading image...",
    msg_upload_success: "Image uploaded successfully",
    msg_upload_failed: "Failed to upload image: ",
    command_upload_all_images: "Upload all local images in current file",
    msg_no_local_images: "No local images found",
    msg_uploading_all: "Uploading {count} images...",
    msg_upload_all_done: "Successfully uploaded {count} images"
  },
  zh: {
    preview_ribbon_tooltip: "\u9884\u89C8\u7F8E\u5316\u6392\u7248",
    copy_command_name: "\u7F8E\u5316\u5E76\u590D\u5236\u5F53\u524D\u6587\u4EF6",
    preview_command_name: "\u9884\u89C8\u7F8E\u5316\u6E32\u67D3\u6548\u679C",
    view_display_text: "MD Beautify \u9884\u89C8",
    no_active_markdown: "\u6CA1\u6709\u6253\u5F00\u7684 Markdown \u6587\u4EF6",
    no_active_view: "\u672A\u627E\u5230\u6D3B\u8DC3\u7684 Markdown \u89C6\u56FE",
    copy_success: "\u5DF2\u6210\u529F\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01",
    copy_failed: "\u590D\u5236\u5931\u8D25: ",
    setting_theme: "\u4E3B\u9898",
    setting_image_host: "\u56FE\u5E8A",
    btn_copy: "\u7F8E\u5316\u590D\u5236",
    btn_upload: "\u4E0A\u4F20",
    settings_header: "MD Beautify \u8BBE\u7F6E",
    tab_general: "\u5E38\u89C4",
    tab_theme: "\u4E3B\u9898",
    tab_image_host: "\u56FE\u5E8A",
    setting_copy_as_html: "\u590D\u5236\u4E3A HTML",
    setting_copy_as_html_desc: "\u590D\u5236\u5230\u526A\u8D34\u677F\u65F6\u662F\u5426\u5305\u542B HTML \u683C\u5F0F",
    setting_base_theme: "\u57FA\u7840\u4E3B\u9898",
    setting_base_theme_desc: "\u9009\u62E9\u7528\u4E8E\u5BFC\u51FA\u7684\u57FA\u7840\u4E3B\u9898",
    custom_style_title: "\u81EA\u5B9A\u4E49\u6837\u5F0F - ",
    custom_style_desc: "\u5728\u6B64\u6DFB\u52A0\u4F60\u81EA\u5DF1\u7684 CSS \u53D8\u91CF\u6216\u6837\u5F0F\u4EE5\u8986\u76D6\u57FA\u7840\u4E3B\u9898\u3002",
    msg_style_saved: "{themeId} \u7684\u81EA\u5B9A\u4E49\u6837\u5F0F\u5DF2\u4FDD\u5B58",
    setting_active_image_host: "\u5F53\u524D\u56FE\u5E8A",
    setting_active_image_host_desc: "\u9009\u62E9\u4E0A\u4F20\u56FE\u7247\u7684\u56FE\u5E8A",
    setting_auto_upload: "\u81EA\u52A8\u4E0A\u4F20\u56FE\u7247",
    setting_auto_upload_desc: "\u5728\u7F16\u8F91\u5668\u7C98\u8D34\u6216\u62D6\u62FD\u672C\u5730\u56FE\u7247\u65F6\u81EA\u52A8\u4E0A\u4F20\u5230\u56FE\u5E8A",
    official_host_desc: "\u5DF2\u542F\u7528 MD Beautify \u9ED8\u8BA4\u56FE\u5E8A\u3002\u65E0\u9700\u989D\u5916\u914D\u7F6E\u3002",
    setting_official_url: "\u9ED8\u8BA4\u4E0A\u4F20 URL",
    setting_official_url_desc: "\u9ED8\u8BA4\u56FE\u5E8A\u7684 API \u63A5\u53E3\u5730\u5740",
    theme_basic: "\u57FA\u7840\u98CE\u683C",
    theme_codeGithub: "GitHub \u4EE3\u7801",
    theme_academicPaper: "\u5B66\u672F\u8BBA\u6587",
    theme_auroraGlass: "\u6781\u5149\u73BB\u7483",
    theme_bauhaus: "\u5305\u8C6A\u65AF",
    theme_cyberpunkNeon: "\u8D5B\u535A\u670B\u514B\u9713\u8679",
    theme_knowledgeBase: "\u77E5\u8BC6\u5E93",
    theme_luxuryGold: "\u8F7B\u5962\u91D1",
    theme_morandiForest: "\u83AB\u5170\u8FEA\u68EE\u6797",
    theme_neoBrutalism: "\u65B0\u91CE\u517D\u4E3B\u4E49",
    theme_receipt: "\u5C0F\u7968\u6837\u5F0F",
    theme_sunsetFilm: "\u843D\u65E5\u80F6\u7247",
    theme_template: "\u6A21\u677F",
    host_official: "\u9ED8\u8BA4",
    host_qiniu: "\u4E03\u725B\u4E91",
    host_aliyun: "\u963F\u91CC\u4E91",
    host_tencent: "\u817E\u8BAF\u4E91",
    host_s3: "S3 \u517C\u5BB9",
    btn_create_theme: "\u65B0\u5EFA\u4E3B\u9898",
    new_theme_placeholder: "\u6211\u7684\u65B0\u4E3B\u9898",
    setting_custom_css: "\u81EA\u5B9A\u4E49 CSS",
    preview_title: "\u5B9E\u65F6\u9884\u89C8",
    preview_placeholder: "# \u4F60\u597D\uFF0C\u4E16\u754C\n\n\u8FD9\u662F\u4E00\u4E2A\u5B9E\u65F6\u9884\u89C8\u3002",
    label_theme: "\u4E3B\u9898",
    label_host: "\u56FE\u5E8A",
    btn_toggle_controls: "\u5207\u6362\u8BBE\u7F6E\u663E\u793A",
    btn_cancel: "\u53D6\u6D88",
    msg_enter_theme_name: "\u8BF7\u8F93\u5165\u4E3B\u9898\u540D\u79F0",
    btn_manage_themes: "\u7BA1\u7406\u4E3B\u9898",
    title_theme_manager: "\u4E3B\u9898\u7BA1\u7406",
    btn_delete: "\u5220\u9664",
    msg_confirm_delete_theme: "\u786E\u5B9A\u8981\u5220\u9664\u4E3B\u9898 '{themeName}' \u5417\uFF1F",
    msg_uploading_image: "\u6B63\u5728\u4E0A\u4F20\u56FE\u7247...",
    msg_upload_success: "\u56FE\u7247\u4E0A\u4F20\u6210\u529F",
    msg_upload_failed: "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25: ",
    command_upload_all_images: "\u4E0A\u4F20\u5F53\u524D\u6587\u4EF6\u4E2D\u7684\u6240\u6709\u672C\u5730\u56FE\u7247",
    msg_no_local_images: "\u672A\u53D1\u73B0\u672C\u5730\u56FE\u7247",
    msg_uploading_all: "\u6B63\u5728\u4E0A\u4F20 {count} \u5F20\u56FE\u7247...",
    msg_upload_all_done: "\u6210\u529F\u4E0A\u4F20 {count} \u5F20\u56FE\u7247"
  }
};
var t = (key, vars) => {
  const lang = import_obsidian.moment.locale() === "zh-cn" || import_obsidian.moment.locale() === "zh" ? "zh" : "en";
  let text = translations[lang][key] || translations.en[key];
  if (vars) {
    Object.keys(vars).forEach((v) => {
      text = text.replace(`{${v}}`, vars[v]);
    });
  }
  return text;
};

// src/main.ts
var import_core = __toESM(require_dist());
var defaultMarkdown = `# Welcome to MD Beautify

This is a modern Markdown editor designed for **beautiful layout and presentation**.

## 1. Basic Syntax
**Bold text**

*Italic text*

***Bold and italic text***

~~Strikethrough text~~

==Highlighted text==

This is a [link](https://github.com/qingu-x/md-editor)

## 2. Special Formats
### Subscript and Superscript

Water: H~2~O

Einstein's equation: E=mc^2^

### Emojis
The weather is great today :sunny: 

Let's learn together :books: 

Go for it :rocket:

## 3. Lists
### Unordered List
- Item 1
- Item 2
  - Sub-item 2.1
  - Sub-item 2.2

### Ordered List
1. Step 1
2. Step 2
3. Step 3

## 4. Blockquotes
> This is a level 1 blockquote
> 
> > This is a level 2 blockquote
> > 
> > > This is a level 3 blockquote
> 

> [!TIP]
> This is a tip callout

> [!NOTE]
> This is a note callout

> [!IMPORTANT]
> This is an important callout
`;
var VIEW_TYPE_MDBEAUTIFY_PREVIEW = "md-beautify-preview-view";
var allThemes = {
  basic: import_core.basicTheme + "\n" + import_core.customDefaultTheme + "\n" + import_core.codeGithubTheme,
  codeGithub: import_core.basicTheme + "\n" + import_core.codeGithubTheme,
  academicPaper: import_core.basicTheme + "\n" + import_core.academicPaperTheme + "\n" + import_core.codeGithubTheme,
  auroraGlass: import_core.basicTheme + "\n" + import_core.auroraGlassTheme + "\n" + import_core.codeGithubTheme,
  bauhaus: import_core.basicTheme + "\n" + import_core.bauhausTheme + "\n" + import_core.codeGithubTheme,
  cyberpunkNeon: import_core.basicTheme + "\n" + import_core.cyberpunkNeonTheme + "\n" + import_core.codeGithubTheme,
  knowledgeBase: import_core.basicTheme + "\n" + import_core.knowledgeBaseTheme + "\n" + import_core.codeGithubTheme,
  luxuryGold: import_core.basicTheme + "\n" + import_core.luxuryGoldTheme + "\n" + import_core.codeGithubTheme,
  morandiForest: import_core.basicTheme + "\n" + import_core.morandiForestTheme + "\n" + import_core.codeGithubTheme,
  neoBrutalism: import_core.basicTheme + "\n" + import_core.neoBrutalismTheme + "\n" + import_core.codeGithubTheme,
  receipt: import_core.basicTheme + "\n" + import_core.receiptTheme + "\n" + import_core.codeGithubTheme,
  sunsetFilm: import_core.basicTheme + "\n" + import_core.sunsetFilmTheme + "\n" + import_core.codeGithubTheme,
  template: import_core.basicTheme + "\n" + import_core.templateTheme + "\n" + import_core.codeGithubTheme
};
var DEFAULT_SETTINGS = {
  defaultTheme: "basic",
  copyAsHtml: true,
  customThemeStyles: {},
  activeImageHost: "official",
  officialUploadUrl: "https://api.wemd.app/upload",
  imageHostConfigs: {
    official: {},
    qiniu: {},
    aliyun: {},
    tencent: {},
    s3: {}
  },
  autoUploadImages: false,
  customThemes: [],
  controlsVisible: false
};
var MDBeautifyPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.parser = (0, import_core.createMarkdownParser)();
    this.registerView(VIEW_TYPE_MDBEAUTIFY_PREVIEW, (leaf) => new MDBeautifyPreviewView(leaf, this));
    const ribbonIconEl = this.addRibbonIcon("eye", t("preview_ribbon_tooltip"), (evt) => {
      this.activateView();
    });
    ribbonIconEl.addClass("md-beautify-ribbon-class");
    this.addCommand({
      id: "copy-beautified",
      name: t("copy_command_name"),
      callback: () => {
        this.copyBeautified();
      }
    });
    this.addCommand({
      id: "preview-beautified",
      name: t("preview_command_name"),
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "upload-all-images",
      name: t("command_upload_all_images"),
      callback: () => {
        this.uploadAllImagesInActiveView();
      }
    });
    this.registerEvent(this.app.workspace.on("editor-paste", (evt, editor, view) => {
      if (this.settings.autoUploadImages) {
        this.onPaste(evt, editor);
      }
    }));
    this.registerEvent(this.app.workspace.on("editor-drop", (evt, editor, view) => {
      if (this.settings.autoUploadImages) {
        this.onPaste(evt, editor);
      }
    }));
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      const line = editor.getLine(editor.getCursor().line);
      const mdRegex = /!\[(.*?)\]\((.*?)\)/g;
      const wikiRegex = /!\[\[(.*?)(?:\|.*?)?\]\]/g;
      let match = null;
      let fullMatch = "";
      let path = "";
      let m;
      while ((m = mdRegex.exec(line)) !== null) {
        if (editor.getCursor().ch >= m.index && editor.getCursor().ch <= m.index + m[0].length) {
          match = m;
          fullMatch = m[0];
          path = m[2];
          break;
        }
      }
      if (!match) {
        while ((m = wikiRegex.exec(line)) !== null) {
          if (editor.getCursor().ch >= m.index && editor.getCursor().ch <= m.index + m[0].length) {
            match = m;
            fullMatch = m[0];
            path = m[1];
            break;
          }
        }
      }
      if (match && path) {
        if (!path.startsWith("http://") && !path.startsWith("https://") && !path.startsWith("data:")) {
          menu.addItem((item) => {
            item.setTitle(t("btn_upload")).setIcon("upload-cloud").onClick(async () => {
              await this.uploadImageFromLink(editor, fullMatch, path);
            });
          });
        }
      }
    }));
    this.addSettingTab(new MDBeautifySettingTab(this.app, this));
  }
  async onPaste(evt, editor) {
    var _a, _b;
    const items = evt instanceof ClipboardEvent ? (_a = evt.clipboardData) == null ? void 0 : _a.items : (_b = evt.dataTransfer) == null ? void 0 : _b.items;
    if (!items)
      return;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.type.startsWith("image/")) {
        const file = item.getAsFile();
        if (file) {
          evt.preventDefault();
          const notice = new import_obsidian2.Notice(t("msg_uploading_image"), 0);
          try {
            const url = await this.uploadImage(file);
            editor.replaceSelection(`![image](${url})`);
            notice.hide();
            new import_obsidian2.Notice(t("msg_upload_success"));
          } catch (err) {
            notice.hide();
            new import_obsidian2.Notice(t("msg_upload_failed") + err.message);
          }
        }
      }
    }
  }
  async uploadImageFromLink(editor, fullLink, path) {
    const notice = new import_obsidian2.Notice(t("msg_uploading_image"), 0);
    try {
      const decodedPath = decodeURIComponent(path);
      const file = this.app.metadataCache.getFirstLinkpathDest(decodedPath, "");
      if (!file) {
        throw new Error("File not found: " + decodedPath);
      }
      const arrayBuffer = await this.app.vault.readBinary(file);
      const blob = new Blob([arrayBuffer], { type: "image/" + file.extension });
      const fileObj = new File([blob], file.name, { type: "image/" + file.extension });
      const url = await this.uploadImage(fileObj);
      const cursor = editor.getCursor();
      const lineText = editor.getLine(cursor.line);
      const newLineText = lineText.replace(fullLink, `![image](${url})`);
      editor.setLine(cursor.line, newLineText);
      notice.hide();
      new import_obsidian2.Notice(t("msg_upload_success"));
    } catch (err) {
      notice.hide();
      new import_obsidian2.Notice(t("msg_upload_failed") + err.message);
    }
  }
  async uploadImage(file) {
    const host = this.settings.activeImageHost;
    if (host === "official") {
      const arrayBuffer = await file.arrayBuffer();
      const fileName = file.name || "image.png";
      const contentType = file.type || "image/png";
      const boundary = "----ObsidianBoundary" + Math.random().toString(36).substring(2);
      const header = `--${boundary}\r
Content-Disposition: form-data; name="file"; filename="${fileName}"\r
Content-Type: ${contentType}\r
\r
`;
      const footer = `\r
--${boundary}--`;
      const headerUint8 = new TextEncoder().encode(header);
      const footerUint8 = new TextEncoder().encode(footer);
      const bodyUint8 = new Uint8Array(arrayBuffer);
      const combinedBody = new Uint8Array(headerUint8.length + bodyUint8.length + footerUint8.length);
      combinedBody.set(headerUint8);
      combinedBody.set(bodyUint8, headerUint8.length);
      combinedBody.set(footerUint8, headerUint8.length + bodyUint8.length);
      const response = await (0, import_obsidian2.requestUrl)({
        url: this.settings.officialUploadUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: combinedBody.buffer
      });
      if (response.status !== 200) {
        throw new Error(`Upload failed with status ${response.status}`);
      }
      return response.json.url;
    }
    throw new Error("Unsupported image host: " + host);
  }
  async uploadAllImagesInActiveView() {
    let view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!view) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      if (leaves.length > 0) {
        const visibleLeaf = leaves.find((l) => l.view.isShowing && l.view.isShowing());
        view = (visibleLeaf == null ? void 0 : visibleLeaf.view) || leaves[0].view;
      }
    }
    if (!view || !view.file) {
      new import_obsidian2.Notice(t("no_active_view"));
      return;
    }
    const content = view.editor.getValue();
    const mdRegex = /!\[(.*?)\]\((?!https?:\/\/)(.*?)\)/g;
    const wikiRegex = /!\[\[(?!https?:\/\/)(.*?)\]\]/g;
    const matches = [];
    let match;
    while ((match = mdRegex.exec(content)) !== null) {
      matches.push({ full: match[0], alt: match[1], path: match[2], index: match.index });
    }
    while ((match = wikiRegex.exec(content)) !== null) {
      const contentInner = match[1];
      const [path, ...altParts] = contentInner.split("|");
      matches.push({ full: match[0], alt: altParts.join("|"), path, index: match.index });
    }
    if (matches.length === 0) {
      new import_obsidian2.Notice(t("msg_no_local_images"));
      return;
    }
    matches.sort((a, b) => b.index - a.index);
    new import_obsidian2.Notice(t("msg_uploading_all", { count: String(matches.length) }));
    let newContent = content;
    let successCount = 0;
    let failCount = 0;
    for (const m of matches) {
      try {
        const decodedPath = decodeURIComponent(m.path);
        const file = this.app.metadataCache.getFirstLinkpathDest(decodedPath, view.file.path);
        if (file instanceof import_obsidian2.TFile) {
          const binary = await this.app.vault.readBinary(file);
          const blob = new Blob([binary], { type: "image/" + file.extension });
          const url = await this.uploadImage(blob);
          const replacement = `![${m.alt || "image"}](${url})`;
          newContent = newContent.substring(0, m.index) + replacement + newContent.substring(m.index + m.full.length);
          successCount++;
        } else {
          console.warn("File not found for path:", m.path, "decoded:", decodedPath);
          failCount++;
        }
      } catch (err) {
        console.error("Failed to upload", m.path, err);
        failCount++;
      }
    }
    view.editor.setValue(newContent);
    if (failCount > 0) {
      new import_obsidian2.Notice(t("msg_upload_all_done", { count: String(successCount) }) + ` (${failCount} failed)`);
    } else {
      new import_obsidian2.Notice(t("msg_upload_all_done", { count: String(successCount) }));
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_MDBEAUTIFY_PREVIEW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_MDBEAUTIFY_PREVIEW, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  getThemeCss(themeId) {
    const id = themeId || this.settings.defaultTheme;
    if (this.settings.customThemeStyles[id]) {
      return this.settings.customThemeStyles[id];
    }
    return allThemes[id] || allThemes["basic"];
  }
  async copyBeautified() {
    let content = "";
    let sourceViewName = "";
    const previewLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_MDBEAUTIFY_PREVIEW);
    const activeLeaf = this.app.workspace.activeLeaf;
    let activePreviewView = null;
    if (activeLeaf && activeLeaf.view instanceof MDBeautifyPreviewView) {
      activePreviewView = activeLeaf.view;
    } else if (previewLeaves.length > 0) {
      activePreviewView = previewLeaves[0].view;
    }
    const activeMarkdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeMarkdownView) {
      content = activeMarkdownView.editor.getValue();
      sourceViewName = activeMarkdownView.getDisplayText();
    } else {
      const markdownLeaves = this.app.workspace.getLeavesOfType("markdown");
      if (markdownLeaves.length > 0) {
        const mostRecentMarkdownView = markdownLeaves[0].view;
        content = mostRecentMarkdownView.editor.getValue();
        sourceViewName = mostRecentMarkdownView.getDisplayText();
      }
    }
    if (!content) {
      new import_obsidian2.Notice(t("no_active_view"));
      return;
    }
    content = content.replace(/^---[\s\S]*?---/, "").trim();
    const themeCss = this.getThemeCss();
    try {
      const html = this.parser.render(content);
      const finalHtml = (0, import_core.processHtml)(html, themeCss, true);
      const blob = new Blob([finalHtml], { type: "text/html" });
      const data = [new ClipboardItem({
        "text/html": blob,
        "text/plain": new Blob([finalHtml], { type: "text/plain" })
      })];
      await navigator.clipboard.write(data);
      new import_obsidian2.Notice(t("copy_success") + (sourceViewName ? `: ${sourceViewName}` : ""));
    } catch (err) {
      console.error("MD Beautify copy error:", err);
      new import_obsidian2.Notice(t("copy_failed") + (err.message || String(err)));
    }
  }
  showPreviewModal() {
    this.activateView();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateAllPreviews(force = false) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_MDBEAUTIFY_PREVIEW);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof MDBeautifyPreviewView) {
        leaf.view.updatePreview(force);
      }
    });
  }
};
var MDBeautifyPreviewView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.lastScrollTime = 0;
    this.lastScrollSource = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MDBEAUTIFY_PREVIEW;
  }
  getDisplayText() {
    return t("view_display_text");
  }
  getIcon() {
    return "eye";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.classList.add("md-beautify-preview-view");
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.height = "100%";
    this.styleEl = container.createEl("style");
    const controlsEl = container.createDiv({ cls: "md-beautify-view-controls" });
    controlsEl.style.padding = "8px";
    controlsEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    controlsEl.style.display = "flex";
    controlsEl.style.flexDirection = "column";
    controlsEl.style.gap = "8px";
    const actionsRow = controlsEl.createDiv();
    actionsRow.style.display = "flex";
    actionsRow.style.gap = "8px";
    actionsRow.style.alignItems = "center";
    const copyBtn = actionsRow.createEl("button", { text: t("btn_copy"), cls: "mod-cta" });
    copyBtn.style.flex = "1";
    copyBtn.onclick = () => this.plugin.copyBeautified();
    const uploadBtn = actionsRow.createEl("button", { cls: "clickable-icon" });
    (0, import_obsidian2.setIcon)(uploadBtn, "upload-cloud");
    uploadBtn.setAttribute("aria-label", t("command_upload_all_images"));
    uploadBtn.onclick = () => this.plugin.uploadAllImagesInActiveView();
    const toggleBtn = actionsRow.createEl("button", { cls: "clickable-icon" });
    const updateToggleIcon = () => {
      (0, import_obsidian2.setIcon)(toggleBtn, this.plugin.settings.controlsVisible ? "chevron-up" : "chevron-down");
      toggleBtn.setAttribute("aria-label", t("btn_toggle_controls"));
    };
    updateToggleIcon();
    toggleBtn.onclick = async () => {
      this.plugin.settings.controlsVisible = !this.plugin.settings.controlsVisible;
      await this.plugin.saveSettings();
      selectorsRow.style.display = this.plugin.settings.controlsVisible ? "flex" : "none";
      updateToggleIcon();
    };
    const selectorsRow = controlsEl.createDiv();
    selectorsRow.style.display = this.plugin.settings.controlsVisible ? "flex" : "none";
    selectorsRow.style.gap = "12px";
    selectorsRow.style.alignItems = "center";
    selectorsRow.style.paddingTop = "4px";
    const themeContainer = selectorsRow.createDiv();
    themeContainer.style.display = "flex";
    themeContainer.style.alignItems = "center";
    themeContainer.style.gap = "4px";
    themeContainer.style.flex = "1";
    themeContainer.createSpan({ text: t("label_theme") + ":" }).style.fontSize = "12px";
    const themeSetting = new import_obsidian2.Setting(themeContainer).addDropdown((dropdown) => {
      Object.keys(allThemes).forEach((themeKey) => {
        const label = t(`theme_${themeKey}`) || themeKey;
        dropdown.addOption(themeKey, label);
      });
      this.plugin.settings.customThemes.forEach((themeName) => {
        dropdown.addOption(themeName, themeName);
      });
      dropdown.setValue(this.plugin.settings.defaultTheme).onChange(async (value) => {
        this.plugin.settings.defaultTheme = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllPreviews(true);
      });
    });
    themeSetting.infoEl.remove();
    themeSetting.settingEl.style.border = "none";
    themeSetting.settingEl.style.padding = "0";
    themeSetting.settingEl.style.flex = "1";
    const hostContainer = selectorsRow.createDiv();
    hostContainer.style.display = "flex";
    hostContainer.style.alignItems = "center";
    hostContainer.style.gap = "4px";
    hostContainer.style.flex = "1";
    hostContainer.createSpan({ text: t("label_host") + ":" }).style.fontSize = "12px";
    const hostSetting = new import_obsidian2.Setting(hostContainer).addDropdown((dropdown) => {
      const hosts = ["official", "qiniu", "aliyun", "tencent", "s3"];
      hosts.forEach((host) => {
        const label = t(`host_${host}`) || host;
        dropdown.addOption(host, label);
      });
      dropdown.setValue(this.plugin.settings.activeImageHost).onChange(async (value) => {
        this.plugin.settings.activeImageHost = value;
        await this.plugin.saveSettings();
      });
    });
    hostSetting.infoEl.remove();
    hostSetting.settingEl.style.border = "none";
    hostSetting.settingEl.style.padding = "0";
    hostSetting.settingEl.style.flex = "1";
    this.scrollContainer = container.createDiv({ cls: "md-beautify-view-preview-scroll" });
    this.scrollContainer.style.flex = "1";
    this.scrollContainer.style.overflowY = "auto";
    this.scrollContainer.style.backgroundColor = "#ffffff";
    this.scrollContainer.style.padding = "20px";
    this.scrollContainer.addEventListener("scroll", () => {
      if (this.lastScrollSource === "editor" && Date.now() - this.lastScrollTime < 100)
        return;
      this.lastScrollSource = "preview";
      this.lastScrollTime = Date.now();
      this.syncPreviewToEditor();
    });
    this.previewEl = this.scrollContainer.createDiv({ cls: "md-beautify-view-preview-content" });
    this.updatePreview();
    this.registerEvent(this.app.workspace.on("editor-change", () => {
      this.updatePreview();
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.updatePreview();
      this.setupEditorScrollListener();
    }));
    this.registerInterval(window.setInterval(() => {
      this.syncScroll();
    }, 100));
    this.setupEditorScrollListener();
  }
  setupEditorScrollListener() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView || !activeView.editor)
      return;
    const editor = activeView.editor;
    const cm = editor.cm;
    const scrollDOM = (cm == null ? void 0 : cm.scrollDOM) || editor.scrollDOM;
    if (scrollDOM && !scrollDOM.dataset.mdBeautifyHasListener) {
      scrollDOM.dataset.mdBeautifyHasListener = "true";
      this.registerDomEvent(scrollDOM, "scroll", () => {
        this.syncScroll();
      });
    }
  }
  syncScroll() {
    if (!this.scrollContainer)
      return;
    if (this.lastScrollSource === "preview" && Date.now() - this.lastScrollTime < 150) {
      return;
    }
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      if (leaves.length > 0) {
        const visibleLeaf = leaves.find((l) => l.view.isShowing && l.view.isShowing());
        activeView = (visibleLeaf == null ? void 0 : visibleLeaf.view) || leaves[0].view;
      }
    }
    if (!activeView || !activeView.editor)
      return;
    const editor = activeView.editor;
    try {
      let ratio = 0;
      let hasRatio = false;
      const cm = editor.cm;
      const scrollDOM = (cm == null ? void 0 : cm.scrollDOM) || editor.scrollDOM;
      if (scrollDOM) {
        const { scrollTop, scrollHeight, clientHeight } = scrollDOM;
        const totalScrollableHeight = scrollHeight - clientHeight;
        if (totalScrollableHeight > 0) {
          ratio = scrollTop / totalScrollableHeight;
          hasRatio = true;
        }
      } else if (editor.getScrollInfo) {
        const scrollInfo = editor.getScrollInfo();
        const totalScrollableHeight = scrollInfo.height - scrollInfo.clientHeight;
        if (totalScrollableHeight > 0) {
          ratio = scrollInfo.top / totalScrollableHeight;
          hasRatio = true;
        }
      }
      if (!hasRatio)
        return;
      const previewTotalHeight = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;
      if (previewTotalHeight <= 0)
        return;
      const newScrollTop = ratio * previewTotalHeight;
      if (Math.abs(this.scrollContainer.scrollTop - newScrollTop) > 1) {
        this.lastScrollSource = "editor";
        this.lastScrollTime = Date.now();
        this.scrollContainer.scrollTop = newScrollTop;
      }
    } catch (e) {
    }
  }
  syncPreviewToEditor() {
    if (!this.scrollContainer)
      return;
    const previewTotalHeight = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;
    if (previewTotalHeight <= 0)
      return;
    const ratio = this.scrollContainer.scrollTop / previewTotalHeight;
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      if (leaves.length > 0) {
        activeView = leaves[0].view;
      }
    }
    if (!activeView || !activeView.editor)
      return;
    const editor = activeView.editor;
    try {
      const cm = editor.cm;
      const scrollDOM = (cm == null ? void 0 : cm.scrollDOM) || editor.scrollDOM;
      if (scrollDOM) {
        const { scrollHeight, clientHeight } = scrollDOM;
        const totalScrollableHeight = scrollHeight - clientHeight;
        if (totalScrollableHeight > 0) {
          const newScrollTop = ratio * totalScrollableHeight;
          if (Math.abs(scrollDOM.scrollTop - newScrollTop) > 1) {
            scrollDOM.scrollTop = newScrollTop;
          }
        }
      } else if (editor.getScrollInfo) {
        const scrollInfo = editor.getScrollInfo();
        const totalScrollableHeight = scrollInfo.height - scrollInfo.clientHeight;
        if (totalScrollableHeight > 0) {
          const newScrollTop = ratio * totalScrollableHeight;
          editor.scrollTo(null, newScrollTop);
        }
      }
    } catch (e) {
    }
  }
  updatePreview(force = false) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView) {
      this.renderContent(activeView);
      return;
    }
    if (force) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      if (leaves.length > 0 && leaves[0].view instanceof import_obsidian2.MarkdownView) {
        this.renderContent(leaves[0].view);
        return;
      }
    }
    const markdownLeaves = this.app.workspace.getLeavesOfType("markdown");
    if (markdownLeaves.length === 0) {
      this.previewEl.innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">${t("no_active_markdown")}</p>`;
    }
  }
  renderContent(view) {
    try {
      let scrollRatio = 0;
      if (this.scrollContainer) {
        const total = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;
        if (total > 0) {
          scrollRatio = this.scrollContainer.scrollTop / total;
        }
      }
      let content = view.editor.getValue();
      content = content.replace(/^---[\s\S]*?---/, "").trim();
      const themeCss = this.plugin.getThemeCss();
      this.styleEl.innerHTML = themeCss;
      const html = this.plugin.parser.render(content);
      const finalHtml = (0, import_core.processHtml)(html, themeCss, false, false, true);
      this.previewEl.innerHTML = finalHtml;
      if (scrollRatio > 0) {
        const restoreScroll = () => {
          if (!this.scrollContainer)
            return;
          const newTotal = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;
          if (newTotal > 0) {
            this.scrollContainer.scrollTop = scrollRatio * newTotal;
          }
        };
        restoreScroll();
        setTimeout(restoreScroll, 100);
        setTimeout(restoreScroll, 300);
        setTimeout(restoreScroll, 1e3);
      }
    } catch (err) {
      this.previewEl.innerHTML = `<p style="color: red; padding: 20px;">Preview Error: ${err.message || String(err)}</p>`;
    }
  }
};
var ThemeManagerModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, onChanged) {
    super(app);
    this.plugin = plugin;
    this.onChanged = onChanged;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("title_theme_manager") });
    const createSection = contentEl.createDiv();
    createSection.style.marginBottom = "20px";
    createSection.style.padding = "15px";
    createSection.style.backgroundColor = "var(--background-secondary)";
    createSection.style.borderRadius = "8px";
    const nameSetting = new import_obsidian2.Setting(createSection).setName(t("btn_create_theme")).addText((text) => text.setPlaceholder(t("new_theme_placeholder")).onChange(() => {
    }));
    const createBtn = createSection.createEl("button", {
      text: t("btn_create_theme"),
      cls: "mod-cta"
    });
    createBtn.style.marginTop = "10px";
    createBtn.style.width = "100%";
    createBtn.onclick = async () => {
      const input = nameSetting.controlEl.querySelector("input");
      const name = input.value.trim();
      if (name) {
        if (!this.plugin.settings.customThemes.includes(name)) {
          this.plugin.settings.customThemes.push(name);
          this.plugin.settings.customThemeStyles[name] = "";
          await this.plugin.saveSettings();
          input.value = "";
          this.renderThemeList(listContainer);
          this.onChanged();
        }
      } else {
        new import_obsidian2.Notice(t("msg_enter_theme_name"));
      }
    };
    const listContainer = contentEl.createDiv();
    this.renderThemeList(listContainer);
  }
  renderThemeList(container) {
    container.empty();
    if (this.plugin.settings.customThemes.length === 0)
      return;
    container.createEl("h3", { text: t("tab_theme"), cls: "md-beautify-list-title" });
    const list = container.createDiv({ cls: "md-beautify-theme-list" });
    list.style.display = "flex";
    list.style.flexDirection = "column";
    list.style.gap = "8px";
    this.plugin.settings.customThemes.forEach((themeName) => {
      const item = list.createDiv();
      item.style.display = "flex";
      item.style.justifyContent = "space-between";
      item.style.alignItems = "center";
      item.style.padding = "8px 12px";
      item.style.border = "1px solid var(--background-modifier-border)";
      item.style.borderRadius = "4px";
      item.createSpan({ text: themeName });
      const deleteBtn = item.createEl("button", {
        text: t("btn_delete"),
        cls: "mod-warning"
      });
      deleteBtn.style.padding = "4px 8px";
      deleteBtn.style.fontSize = "12px";
      deleteBtn.onclick = async () => {
        const confirmMsg = t("msg_confirm_delete_theme", { themeName });
        if (confirm(confirmMsg)) {
          this.plugin.settings.customThemes = this.plugin.settings.customThemes.filter((t2) => t2 !== themeName);
          delete this.plugin.settings.customThemeStyles[themeName];
          if (this.plugin.settings.defaultTheme === themeName) {
            this.plugin.settings.defaultTheme = "basic";
          }
          await this.plugin.saveSettings();
          this.renderThemeList(container);
          this.onChanged();
          this.plugin.updateAllPreviews(true);
        }
      };
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var MDBeautifySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "general";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const header = containerEl.createDiv({ cls: "md-beautify-settings-header" });
    header.createEl("h2", { text: t("settings_header") });
    const nav = containerEl.createDiv({ cls: "md-beautify-settings-nav" });
    nav.style.display = "flex";
    nav.style.gap = "10px";
    nav.style.marginBottom = "20px";
    nav.style.borderBottom = "1px solid var(--background-modifier-border)";
    nav.style.paddingBottom = "10px";
    const createTabBtn = (id, label) => {
      const btn = nav.createEl("button", { text: label });
      btn.style.padding = "5px 15px";
      if (this.activeTab === id) {
        btn.style.backgroundColor = "var(--interactive-accent)";
        btn.style.color = "var(--text-on-accent)";
      }
      btn.onclick = () => {
        this.activeTab = id;
        this.display();
      };
    };
    createTabBtn("general", t("tab_general"));
    createTabBtn("theme", t("tab_theme"));
    createTabBtn("imagehost", t("tab_image_host"));
    const content = containerEl.createDiv({ cls: "md-beautify-settings-content" });
    if (this.activeTab === "general") {
      this.renderGeneralSettings(content);
    } else if (this.activeTab === "theme") {
      this.renderThemeSettings(content);
    } else if (this.activeTab === "imagehost") {
      this.renderImageHostSettings(content);
    }
  }
  renderGeneralSettings(container) {
    new import_obsidian2.Setting(container).setName(t("setting_copy_as_html")).setDesc(t("setting_copy_as_html_desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.copyAsHtml).onChange(async (value) => {
      this.plugin.settings.copyAsHtml = value;
      await this.plugin.saveSettings();
    }));
  }
  renderThemeSettings(container) {
    const themeId = this.plugin.settings.defaultTheme;
    const actionContainer = container.createDiv({ cls: "md-beautify-theme-actions" });
    actionContainer.style.marginBottom = "20px";
    actionContainer.style.display = "flex";
    actionContainer.style.justifyContent = "flex-start";
    const manageBtn = actionContainer.createEl("button", {
      text: t("btn_manage_themes"),
      cls: "mod-cta"
    });
    manageBtn.onclick = () => {
      new ThemeManagerModal(this.app, this.plugin, () => {
        this.display();
      }).open();
    };
    new import_obsidian2.Setting(container).setName(t("setting_base_theme")).addDropdown((dropdown) => {
      Object.keys(allThemes).forEach((themeKey) => {
        const label = t(`theme_${themeKey}`) || themeKey;
        dropdown.addOption(themeKey, label);
      });
      this.plugin.settings.customThemes.forEach((themeName) => {
        dropdown.addOption(themeName, themeName);
      });
      dropdown.setValue(themeId).onChange(async (value) => {
        this.plugin.settings.defaultTheme = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllPreviews(true);
        this.display();
      });
    });
    const themeLabel = t(`theme_${themeId}`) || themeId;
    const editorContainer = container.createDiv({ cls: "md-beautify-theme-editor-container" });
    editorContainer.style.display = "grid";
    editorContainer.style.gridTemplateColumns = "1fr 1fr";
    editorContainer.style.gap = "20px";
    editorContainer.style.height = "70vh";
    editorContainer.style.maxHeight = "600px";
    editorContainer.style.minHeight = "400px";
    editorContainer.style.marginTop = "20px";
    const cssSection = editorContainer.createDiv();
    cssSection.style.display = "flex";
    cssSection.style.flexDirection = "column";
    cssSection.style.height = "100%";
    cssSection.style.overflow = "hidden";
    cssSection.createEl("h3", { text: t("setting_custom_css") });
    const cssEditor = cssSection.createEl("textarea");
    cssEditor.style.flex = "1";
    cssEditor.style.height = "0";
    cssEditor.style.fontFamily = "var(--font-monospace)";
    cssEditor.style.fontSize = "12px";
    cssEditor.style.padding = "10px";
    cssEditor.style.resize = "none";
    cssEditor.value = this.plugin.getThemeCss(themeId);
    const previewSection = editorContainer.createDiv();
    previewSection.style.display = "flex";
    previewSection.style.flexDirection = "column";
    previewSection.style.height = "100%";
    previewSection.style.overflow = "hidden";
    previewSection.createEl("h3", { text: t("preview_title") });
    const previewFrame = previewSection.createDiv({ cls: "md-beautify-settings-preview" });
    previewFrame.style.flex = "1";
    previewFrame.style.overflowY = "auto";
    previewFrame.style.border = "1px solid var(--background-modifier-border)";
    previewFrame.style.padding = "20px";
    previewFrame.style.backgroundColor = "#ffffff";
    const previewStyle = previewFrame.createEl("style");
    const previewContent = previewFrame.createDiv();
    const updateSettingsPreview = () => {
      const css = this.plugin.getThemeCss(themeId);
      previewStyle.innerHTML = css.replace(/#wemd/g, ".md-beautify-preview-wrapper");
      const html = this.plugin.parser.render(defaultMarkdown);
      previewContent.innerHTML = `<div class="md-beautify-preview-wrapper">${html}</div>`;
    };
    updateSettingsPreview();
    let debounceTimer;
    cssEditor.oninput = () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        this.plugin.settings.customThemeStyles[themeId] = cssEditor.value;
        await this.plugin.saveSettings();
        updateSettingsPreview();
        this.plugin.updateAllPreviews(true);
      }, 500);
    };
  }
  renderImageHostSettings(container) {
    const host = this.plugin.settings.activeImageHost;
    new import_obsidian2.Setting(container).setName(t("setting_auto_upload")).setDesc(t("setting_auto_upload_desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoUploadImages).onChange(async (value) => {
      this.plugin.settings.autoUploadImages = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(container).setName(t("setting_active_image_host")).setDesc(t("setting_active_image_host_desc")).addDropdown((dropdown) => {
      const hosts = ["official", "qiniu", "aliyun", "tencent", "s3"];
      hosts.forEach((h) => {
        const label = t(`host_${h}`) || h;
        dropdown.addOption(h, label);
      });
      dropdown.setValue(host).onChange(async (value) => {
        this.plugin.settings.activeImageHost = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (host === "official") {
      container.createEl("p", { text: t("official_host_desc") });
      new import_obsidian2.Setting(container).setName(t("setting_official_url")).setDesc(t("setting_official_url_desc")).addText((text) => text.setPlaceholder("https://api.wemd.app/upload").setValue(this.plugin.settings.officialUploadUrl).onChange(async (value) => {
        this.plugin.settings.officialUploadUrl = value;
        await this.plugin.saveSettings();
      }));
    } else {
      this.renderHostConfigFields(container, host);
    }
  }
  renderHostConfigFields(container, type) {
    const config = this.plugin.settings.imageHostConfigs[type] || {};
    if (type === "qiniu") {
      this.createConfigInput(container, type, "Access Key", "accessKey", true);
      this.createConfigInput(container, type, "Secret Key", "secretKey", true);
      this.createConfigInput(container, type, "Bucket", "bucket");
      this.createConfigInput(container, type, "Domain", "domain", false, "e.g., http://images.yourdomain.com");
    } else if (type === "aliyun" || type === "tencent" || type === "s3") {
      this.createConfigInput(container, type, "Access Key ID", "accessKeyId", true);
      this.createConfigInput(container, type, "Secret Access Key", "secretAccessKey", true);
      this.createConfigInput(container, type, "Bucket", "bucket");
      this.createConfigInput(container, type, "Region", "region");
      if (type === "s3") {
        this.createConfigInput(container, type, "Endpoint", "endpoint");
      }
    }
  }
  createConfigInput(container, type, name, key, isPassword = false, placeholder = "") {
    const s = new import_obsidian2.Setting(container).setName(name).addText((text) => text.setPlaceholder(placeholder).setValue(this.plugin.settings.imageHostConfigs[type][key] || "").onChange(async (value) => {
      this.plugin.settings.imageHostConfigs[type][key] = value;
      await this.plugin.saveSettings();
    }));
    if (isPassword) {
      s.controlEl.querySelector("input").type = "password";
    }
  }
};
/**
 * Returns an array of the selectors.
 *
 * @license Sizzle CSS Selector Engine - MIT
 * @param {String} selectorText from mensch
 * @api public
 */
